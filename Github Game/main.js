import {
  tileSheets,
  dwarfSpriteSheets,
  orcSpriteSheets,
  dungeonPlayerSpriteSheets,
  characterCreatorPortraitAssets,
  characterCreatorBeardAssetMap,
  characterCreatorHairAssetMap,
  characterCreatorHairStyleCategoryMap,
  characterCreatorDefaultSkinColor,
  characterCreatorDefaultHairColor,
  getCharacterCreatorSkinTintLayers,
  getCharacterCreatorHairTintLayers,
  baseTileCoords,
  ROAD_DIRECTION_BITS,
  roadTileSpriteDefinitions,
  riverTileCoords,
  icebergTileCoords,
  tileLookup,
  registerTiles,
  registerCustomStructure
} from './src/assets.js';
import { clamp } from './src/utils/math.js';
import {
  elements,
  hydrateElements,
  getMusicToggleElements,
  getMusicVolumeInputs,
  getMusicNowPlayingDisplays
} from './src/ui/elements.js';
import { attachEvents } from './src/ui/events.js';
import { createStateModule } from './src/state/index.js';
import {
  drawHamletStructure,
  drawDarkDwarfholdStructure,
  drawRoadsideTavernStructure,
  drawAmbientHuntingLodgeStructure,
  drawAmbientMoonwellStructure
} from './src/world/structures.js';
import { updateDwarfPortrait, updateDwarfTraitSummary, updateRosterList } from './src/dwarves/customizer.js';
import { populateClanSelectFromOptions } from './src/main/clan-select.js';
import { populateProfessionSelectFromOptions } from './src/main/profession-select.js';
import {
  applyMapSizePresetToState,
  defaultForestFrequency,
  defaultMapSize,
  defaultMountainFrequency,
  getMapSizeLabel,
  getMapSizePreset
} from './src/main/map-config.js';
import { getRandomWorldName } from './src/main/world-names.js';
import { generateDwarfholdMap } from './src/local/dwarfhold-map.js';

let cachedDwarfholdGeneratorPromise = null;

async function loadDwarfholdGenerator() {
  if (!cachedDwarfholdGeneratorPromise) {
    cachedDwarfholdGeneratorPromise = Promise.resolve(generateDwarfholdMap);
  }
  return cachedDwarfholdGeneratorPromise;
}

const drawSize = 32;
const defaultWorldGenerationType = 'normal';
const defaultLoadingStatusMessage = 'Calculating terrain layers…';
const icebergOverlayKeySet = new Set(Object.keys(icebergTileCoords || {}));

registerTiles('base', baseTileCoords);
registerTiles('worldDetails', riverTileCoords);
registerTiles('base', icebergTileCoords);

registerCustomStructure('HAMLET', (ctx, drawOptions) =>
  drawHamletStructure(ctx, drawOptions, { state })
);
registerCustomStructure('ROADSIDE_TAVERN', (ctx, drawOptions) =>
  drawRoadsideTavernStructure(ctx, drawOptions, { state })
);
registerCustomStructure('DARK_DWARFHOLD', (ctx, drawOptions) =>
  drawDarkDwarfholdStructure(ctx, drawOptions, { state })
);
// AMBIENT_HOMESTEAD draws directly from the base sprite sheet via baseTileCoords.
registerCustomStructure('AMBIENT_HUNTING_LODGE', (ctx, drawOptions) =>
  drawAmbientHuntingLodgeStructure(ctx, drawOptions, { state })
);
registerCustomStructure('AMBIENT_MOONWELL', (ctx, drawOptions) =>
  drawAmbientMoonwellStructure(ctx, drawOptions, { state })
);


if (!tileLookup.has('EVIL_WIZARDS_TOWER')) {
  const fallbackTower = tileLookup.get('TOWER');
  if (fallbackTower) {
    tileLookup.set('EVIL_WIZARDS_TOWER', { ...fallbackTower });
  }
}

const TOWN_ROAD_OVERLAY_KEY = 'TOWN_ROAD';

const hillOverlayKeySet = new Set([
  'HILLS',
  'HILLS_VARIANT_A',
  'HILLS_VARIANT_B',
  'HILLS_SNOW',
  'HILLS_BADLANDS'
]);
const treeOverlayKeySet = new Set(['TREE', 'TREE_LONE', 'TREE_SNOW', 'JUNGLE_TREE']);
const cutTreeOverlayKey = tileLookup.has('CUT_TREES') ? 'CUT_TREES' : null;
const farmCropOverlayKey = tileLookup.has('FARM_CROPS') ? 'FARM_CROPS' : null;
const jungleOverlayKey = 'JUNGLE_TREE';
const woodElfGroveStructureKeys = ['WOOD_ELF_GROVES', 'WOOD_ELF_GROVES_LARGE', 'WOOD_ELF_GROVES_GRAND'];
const woodElfGroveStructureKeySet = new Set(woodElfGroveStructureKeys);
const isWoodElfGroveStructureKey = (key) =>
  typeof key === 'string' && woodElfGroveStructureKeySet.has(key);

const volcanoOverlayKeySet = new Set(['VOLCANO', 'ACTIVE_VOLCANO']);
const isVolcanoOverlayKey = (key) => typeof key === 'string' && volcanoOverlayKeySet.has(key);
const isMountainOverlayKey = (key) =>
  typeof key === 'string' && (key.startsWith('MOUNTAIN') || isVolcanoOverlayKey(key));
const isHillOverlayKey = (key) => typeof key === 'string' && hillOverlayKeySet.has(key);
const isTreeOverlayKey = (key) => typeof key === 'string' && treeOverlayKeySet.has(key);
const tileHasTreeOverlay = (tile) =>
  Boolean(tile) && (isTreeOverlayKey(tile.overlay) || isTreeOverlayKey(tile.hillOverlay));
const isJungleOverlayKey = (key) => typeof key === 'string' && key === jungleOverlayKey;
const tileHasJungleOverlay = (tile) =>
  Boolean(tile) && (isJungleOverlayKey(tile.overlay) || isJungleOverlayKey(tile.hillOverlay));
const darkDwarfholdVolcanoRadius = 4;
const townSettlementTypes = new Set(['town', 'city', 'village']);
const isTownSettlementDetails = (details) =>
  Boolean(details) &&
  details.isSettlement === true &&
  typeof details.type === 'string' &&
  townSettlementTypes.has(details.type);
const tileHasTownSettlement = (tile) => isTownSettlementDetails(tile?.structureDetails);

function evaluateFactionTileSuitability(faction, tile, x, y) {
  if (!faction || !tile) {
    return 0;
  }

  const type =
    (faction.capital && typeof faction.capital.type === 'string' && faction.capital.type) || 'settlement';

  switch (type) {
    case 'hillhold':
    case 'dwarfhold': {
      if (
        tile.structure === 'DWARFHOLD' ||
        tile.structure === 'GREAT_DWARFHOLD' ||
        tile.structure === 'ABANDONED_DWARFHOLD' ||
        tile.structure === 'HILLHOLD'
      ) {
        return 1;
      }
      if (isMountainOverlayKey(tile.overlay) || isMountainOverlayKey(tile.hillOverlay)) {
        return 1;
      }
      if (isHillOverlayKey(tile.overlay) || isHillOverlayKey(tile.hillOverlay)) {
        return 0.45;
      }
      return 0;
    }
    case 'woodElfGrove': {
      if (isWoodElfGroveStructureKey(tile.structure)) {
        return 1;
      }
      if (tileHasTreeOverlay(tile)) {
        return 1;
      }
      return 0;
    }
    case 'lizardmenCity': {
      if (tile.structure === 'LIZARDMEN_CITY') {
        return 1;
      }
      if (tile.base === 'WATER') {
        return 0;
      }
      if (tileHasJungleOverlay(tile)) {
        return 1;
      }
      if (tileHasTreeOverlay(tile)) {
        return 0.3;
      }
      return 0;
    }
    case 'tower':
    case 'evilWizardTower': {
      if (tile.base === 'WATER') {
        return 0;
      }

      const overlayIsMountain = isMountainOverlayKey(tile.overlay) || isMountainOverlayKey(tile.hillOverlay);
      const overlayIsHill = isHillOverlayKey(tile.overlay) || isHillOverlayKey(tile.hillOverlay);
      const overlayIsForest = isTreeOverlayKey(tile.overlay);

      let suitability = 1;

      if (overlayIsMountain) {
        if (Number.isFinite(x) && Number.isFinite(y)) {
          const dx = x - faction.capital.x;
          const dy = y - faction.capital.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance <= Math.SQRT2) {
            suitability *= 0.35;
          } else {
            return 0.05;
          }
        } else {
          return 0.05;
        }
      }

      if (overlayIsHill) {
        suitability *= 0.35;
      }

      if (overlayIsForest) {
        suitability *= 0.35;
      }

      return suitability;
    }
    case 'village': {
      if (tile.base === 'WATER') {
        return 0;
      }

      const overlayIsMountain = isMountainOverlayKey(tile.overlay) || isMountainOverlayKey(tile.hillOverlay);
      const overlayIsHill = isHillOverlayKey(tile.overlay) || isHillOverlayKey(tile.hillOverlay);
      const overlayIsForest = isTreeOverlayKey(tile.overlay);

      let suitability = 1;

      if (overlayIsMountain) {
        suitability *= 0.2;
      } else if (overlayIsHill) {
        suitability *= 0.45;
      }

      if (overlayIsForest) {
        suitability *= 0.5;
      }

      return suitability;
    }
    case 'town': {
      if (tile.base === 'WATER') {
        return 0;
      }

      const overlayIsMountain = isMountainOverlayKey(tile.overlay) || isMountainOverlayKey(tile.hillOverlay);
      const overlayIsHill = isHillOverlayKey(tile.overlay) || isHillOverlayKey(tile.hillOverlay);
      const overlayIsForest = isTreeOverlayKey(tile.overlay);

      let suitability = 1;

      if (overlayIsMountain) {
        suitability *= 0.3;
      } else if (overlayIsHill) {
        suitability *= 0.6;
      }

      if (overlayIsForest) {
        suitability *= 0.75;
      }

      return suitability;
    }
    default:
      return 1;
  }
}



const realmNameAdjectives = [
  'Azure',
  'Gilded',
  'Obsidian',
  'Verdant',
  'Crimson',
  'Sable',
  'Ivory',
  'Stormborn',
  'Radiant',
  'Umbral',
  'Ember',
  'Frostbound',
  'Sunlit',
  'Twilight',
  'Shattered',
  'Celestial',
  'Runed',
  'Eclipsed'
];

const realmNameNouns = [
  'Dominion',
  'Compact',
  'Marches',
  'Concord',
  'Throne',
  'Hegemony',
  'Alliance',
  'Syndicate',
  'Banner',
  'Legion',
  'Pact',
  'Confederacy',
  'Circle',
  'Assembly',
  'Holdings',
  'Enclave',
  'Sovereignty',
  'Ward'
];

const factionColorPalette = [
  '#ef4444',
  '#3b82f6',
  '#22c55e',
  '#eab308',
  '#a855f7',
  '#f97316',
  '#0ea5e9',
  '#ec4899',
  '#14b8a6',
  '#c084fc',
  '#facc15',
  '#38bdf8'
];

function pickFactionColor(index) {
  if (!Array.isArray(factionColorPalette) || factionColorPalette.length === 0) {
    return '#f97316';
  }
  const size = factionColorPalette.length;
  if (!Number.isFinite(index)) {
    return factionColorPalette[0];
  }
  const normalized = ((Math.floor(index) % size) + size) % size;
  return factionColorPalette[normalized];
}

const dwarfholdCuratedNames = [
  'Khazadûn Kharn',
  'Dhurnomli Bûr',
  'Zarak-az-Garaz',
  'Barûn-karag',
  'Gundûm Garmak',
  'Azar-khazad',
  'Thûrdrim Duraz',
  'Kazad-grimil',
  'Bêrdûm Barak',
  'Zirak-khazad',
  'Uzbad-az-Narg',
  'Karag Gor',
  'Dûmthûr Mîn',
  'Gûndâl Grum',
  'Thrâng-khazad',
  'Khirûn-karag',
  'Gazad-az-Bôr',
  'Dûrgrim Dûm',
  'Bazâr-durin',
  'Kharak-khazad',
  'Thûrdûn Thrum',
  'Gazûl-dûm',
  'Gor Dûrgheled',
  'Khûrmak Dûm',
  'Barak-dûrûn',
  'Gadrin-karag',
  'Mornûl Khazad',
  'Tharûm Barûn',
  'Dûr-az-Gor',
  'Kûzad Thrang',
  'Grumkhaz Dûm',
  'Narûm-barak',
  'Khûldar Narg',
  'Azûl-az-Khazad',
  'Dûmthrûn Garaz',
  'Grom-dûrin',
  'Khazdûl Garm',
  'Burin-dûm',
  'Zarak-nâl',
  'Thuldûn Karag',
  'Durgrûn Khazad',
  'Garak-dûm',
  'Tharn-az-Dûr',
  'Kharûm Grimdûm',
  'Balzûr Karûn',
  'Mûrkhaz Barak',
  'Thrûm-az-Garaz',
  'Gundûl-dûm',
  'Bârgrin Khazad',
  'Dûmbar Thûr',
  'Nûrgrim Karag',
  'Thûlûm Dûrûn',
  'Kharn-dûm-nâl',
  'Throgar-Mâl',
  'Krundûn Barak',
  'Dûrkhal Varrum',
  'Ghazdûr Grimbar',
  'Kuldûn-Dûr',
  'Brakûl Thrang',
  'Zarnak-dûm',
  'Throldar Kharn',
  'Mûldûn Grakhaz',
  'Durmûr Barûn',
  'Merûn Barin',
  'Dûldar Harnûm',
  'Bronarûm',
  'Kharalûn Dûr',
  'Garûn-kaz',
  'Thûrli Barûn',
  'Balnar Dûm',
  'Orûn Khazal',
  'Dûmren Thûr',
  'Beldûr Karûn',
  'Uldûm Nargaz',
  'Khardûl Barzûn',
  'Thûrkûn-Môr',
  'Zuldarûn',
  'Dûrthang Kharûz',
  'Brûm-dûl',
  'Gûldûn Thazrak',
  'Khazûr-Dumli',
  'Thrûnûl Barûz',
  'Mûrzan-Dûm',
  'Grendûl Varrin',
  'Kharnfell',
  'Dûmholm',
  'Barakdel',
  'Thûrdûn Holdfast',
  'Gromir Karûn',
  'Kharûm Tor',
  "Thulgar's Deep",
  'Brumkeldûm',
  'Dûrmar Hollow',
  'the Great Halls of Thorbardin',
  'Hammerguard',
  'Gor Karakazol',
  'Dur-Vazhatun',
  'Throal',
  'Dun-Ôrdstun',
  'Dûrandur',
  'Black Rock Hold',
  'Barat Nûmenz',
  'Dun Toruhm',
  'Karad-Graef',
  'Dûmthûr Mînrth',
  "Y'olazad-az-Bôr",
  'Gor Dûrgheld',
  'Dwemerhelm',
  'Tuwad-Dhumakon',
  'Skomdihir',
  'Hul-Jorkad',
  'Hul-Az-Krakazol',
  'Ovdal-az-An',
  'Orocarni',
  'Dun-Gardro',
  'Azrak Ordrim',
  'Dal Dulrah',
  'Dungrum',
  "Dun'ragram",
  'Karak Isural',
  'Sinterholm',
  'Karak-Dûmankon',
  'Grozumdihr',
  'Gor Ozumbrog',
  'Azad-Khas',
  'Karag Burag',
  'Hul-Kargdrum',
  'Karak-Duraz',
  'Tharn Khazrim',
  'Karak Grumdril',
  'Mirabar',
  'Dun Ashborun',
  'Avlar-Thrûn',
  "Grom's Peak",
  'Karak Gorûmzra',
  'Ostapchuk',
  'Dammerhall',
  'Almharaz',
  'Haraz Oldrum',
  'Elaig Drum',
  'Karak Ozambrald',
  'Ironhold',
  'Alvar-Baroag',
  'Ondrehrdin',
  'Azrak Zarak',
  'Dun Ezmar',
  'Azgark Metzger'
];

const dwarfholdNamePrefixes = [
  'Stone',
  'Iron',
  'Granite',
  'Amber',
  'Bronze',
  'Deep',
  'Rune',
  'Frost',
  'Obsidian',
  'Storm',
  'Thunder',
  'Gilded',
  'Anvil',
  'Forge',
  'Hammer',
  'High',
  'Cinder',
  'Mithril',
  'Coal',
  'Crag',
  'Beryl',
  'Bright',
  'Shield',
  'Ember',
  'Crystal',
  'Bastion',
  'Vault'
];

const dwarfholdNameSuffixes = [
  'hold',
  'hall',
  'gate',
  'delve',
  'keep',
  'reach',
  'spire',
  'guard',
  'vault',
  'crown',
  'forge',
  'fast',
  'home',
  'rest',
  'watch',
  'deep',
  'peak'
];

const dwarfholdNameDescriptors = [
  'Citadel',
  'Stronghold',
  'Holdfast',
  'Sanctum',
  'Throne',
  'Bastion',
  'Redoubt',
  'Garrison',
  'Watch',
  'Reliquary',
  'Enclave',
  'Caverns',
  'Fortress',
  'Outpost',
  'Ward'
];

const dwarfholdNameRegions = [
  'the North',
  'the Deep',
  'the First Kings',
  'the Ancients',
  'Stonehome',
  'Stormpeak',
  'Ember Range',
  'Thunderholt',
  'the Underway',
  'Skyforge',
  'the Iron Sea',
  'Grimspire',
  'Highstone',
  'Runecrest',
  'the Brass Line'
];

function getPrimaryClanName(label, fallback = '') {
  const source = typeof label === 'string' && label.trim().length > 0 ? label : fallback;
  if (!source) {
    return '';
  }
  const primary = source.split('—')[0] || source;
  return primary.trim();
}

function getClanFamilyNames(clanValue) {
  if (!clanValue) {
    return [];
  }
  const familyNames = dwarfClanFamilyNames.get(clanValue);
  return Array.isArray(familyNames) ? familyNames : [];
}

function generateAdditionalDwarfClanNames(count, randomFn) {
  const names = new Set();
  while (names.size < count) {
    const styleRoll = randomFn();
    let name = '';

    if (styleRoll < 0.3) { // Prefix + Suffix
      const prefix = pickRandomFrom(dwarfholdNamePrefixes, randomFn);
      const suffix = pickRandomFrom(dwarfholdNameSuffixes, randomFn);
      if (prefix && suffix) {
        name = `${prefix}${suffix.charAt(0).toUpperCase() + suffix.slice(1)}`;
      }
    } else if (styleRoll < 0.6) { // Prefix + Descriptor
      const prefix = pickRandomFrom(dwarfholdNamePrefixes, randomFn);
      const descriptor = pickRandomFrom(dwarfholdNameDescriptors, randomFn);
      if (prefix && descriptor) {
        name = `${prefix} ${descriptor}`;
      }
    } else { // Descriptor + Suffix
      const descriptor = pickRandomFrom(dwarfholdNameDescriptors, randomFn);
      const suffix = pickRandomFrom(dwarfholdNameSuffixes, randomFn);
      if (descriptor && suffix) {
        name = `${descriptor} ${suffix}`;
      }
    }

    if (name) {
      names.add(name);
    }
  }
  return Array.from(names).map(name => ({
    value: name.toLowerCase().replace(/[^a-z0-9]+/g, ''),
    label: name
  }));
}

const dwarfholdRulerTitles = {
  female: [
    'High Thane',
    'Forge Matron',
    'Hearthmother',
    'Deepwarden',
    'Queen',
    'Thane',
    'High Queen'
  ],
  male: [
    'High Thane',
    'Forge Lord',
    'Mountain King',
    'Deepwarden',
    'Thane',
    'King',
    'King Under The Mountain',
    'Prince',
    'High Runesmith'
  ]
};

const darkDwarfholdLeaderTitles = [
  'Emperor',
  'Sorcerer-Thane',
  'Warlork High Lord',
  'Sorcerer-Prophet',
  'Lawgiver',
  'Dark-Thane'
];

const dwarfholdHallmarks = [
  'Renowned for adamantine vaults that hum with runic wards.',
  'Brews ember-ale said to warm even a dragonborn heart.',
  'Forges battleaxes tempered in magmafall cascades.',
  'Gemcutters here carve prisms that sing when struck.',
  'Hosts archives of rune-scribed lore older than empires.',
  'Its sentry golems stand watch over sealed deep-gates.',
  'Stonewrights sculpt living statues of honoured ancestors.',
  'Traders deal in starlight opals mined from midnight caverns.',
  'Their forges are stoked by dragonfire bound in crystal cages.',
  'Tunnel gardens yield luminous mushrooms for distant markets.'
];

const dwarfholdExportOptions = [
  'Cut gemstones and faceted crystals',
  'Masterwork steel arms and armor',
  'Runic circuitry and precision mechanisms',
  'Barrels of triple-aged stout and spirits',
  'Thunderpowder and blasting charges',
  'Refined mithril ingots and alloys',
  'Architectural plans and rune-etched stonework',
  'Highland woolens and leatherwork',
  'Engraved jewelry and heirloom trinkets'
];

const mineNamePrefixes = [
  'Iron',
  'Silver',
  'Copper',
  'Gold',
  'Mithril',
  'Coal',
  'Gem',
  'Obsidian',
  'Crystal',
  'Rune',
  'Ember',
  'Thunder',
  'Star',
  'Deep'
];

const mineNameSuffixes = [
  'delve',
  'reach',
  'shaft',
  'vein',
  'hollow',
  'works',
  'forge',
  'deep',
  'spire',
  'gate'
];

const mineNameDescriptors = ['Mine', 'Delve', 'Excavation', 'Works', 'Prospect'];

const mineResourceProfiles = [
  {
    resource: 'iron ore',
    export: 'pig iron billets',
    description: 'Magnetite seams glow ember-red beneath rune lanterns.'
  },
  {
    resource: 'silver ore',
    export: 'refined silver ingots',
    description: 'Silver veins lace the rock like moonlight trapped in stone.'
  },
  {
    resource: 'gold ore',
    export: 'gold dust and ingots',
    description: 'Gold threads shimmer in quartz pockets with every pick strike.'
  },
  {
    resource: 'mithril ore',
    export: 'mithril flakes and bars',
    description: 'Mithril filaments sing softly when teased free of the bedrock.'
  },
  {
    resource: 'coal seams',
    export: 'smokeless coke bricks',
    description: 'Coal seams burn clean and hot, prized by deep forges.'
  },
  {
    resource: 'gemstone geodes',
    export: 'uncut gemstones',
    description: 'Geodes crack open to reveal lantern-lit caverns of colour.'
  },
  {
    resource: 'copper ore',
    export: 'worked copper ingots',
    description: 'Copper veins patina the tunnels with a verdant sheen.'
  }
];

const mineHazardOptions = [
  'sulfur vents that hiss until rune chimneys release the pressure',
  'echo spirits that steal tools left unattended in dark galleries',
  'shatterstone pockets that collapse without rune-braced timbers',
  'flood-prone shafts kept dry by steam-powered pumps',
  'tunnelwyrms that gnaw the deepest stopes if watchfires go dim',
  'glittermote swarms that daze miners who forget their goggles'
];

const mineCrewNames = [
  'Deepdelver Crew',
  'Amberpick Syndicate',
  'Runehammer Shift',
  'Thunderpick Assembly',
  'Glowforge Line',
  'Stonebite League'
];

const mineSecondaryExports = [
  'runed support struts',
  'cut granite blocks',
  'slagglass baubles',
  'precision drill heads',
  'barrels of blasting powder'
];

const hillholdNamePrefixes = [
  'Stone',
  'Amber',
  'Bronze',
  'Granite',
  'Cloud',
  'Storm',
  'Frost',
  'Ember',
  'Ridge',
  'Hearth',
  'Rune',
  'Copper',
  'Oak',
  'Pine',
  'Crown',
  'Deep',
  'Iron'
];

const hillholdNameSuffixes = [
  'watch',
  'guard',
  'hold',
  'fast',
  'hearth',
  'delve',
  'gate',
  'spire',
  'tor',
  'bastion'
];

const hillholdNameDescriptors = [
  'Hill',
  'Heights',
  'Tor',
  'Rise',
  'Overlook',
  'Sentinel',
  'Cairn',
  'Keep'
];

const hillholdHallmarks = [
  'Terraced stone halls clutch the hillside with iron-rooted buttresses.',
  'Signal beacons line the ridge, flaring to warn the mountain clans.',
  'Stonecut breweries age ember-ale in vaults carved into the slope.',
  'A ring of rune-warded cairns keeps avalanches at bay.',
  'Watchful ballistae peer over the passes, ready for skyborne threats.',
  'Ancestral murals glow softly where the hill meets the mountain.',
  'Tunnel orchards cultivate silverleaf whose sap steeps hardy brews.',
  'Gear-driven lifts ferry caravans up the steep approach roads.'
];

const hillholdWatchOrders = [
  'Ridgeguard Brotherhood',
  'Hearthward Sentinels',
  'Torwatch Lodge',
  'Amberhorn Vigil',
  'Thunderpeak Watch',
  'Mistveil Wardens',
  'Stoneflare Rangers',
  'Copper Torches'
];

const hillholdWardenTitles = [
  'Holdthane',
  'Ridgekeeper',
  'Beacon Marshal',
  'Hearthwarden',
  'Overthane',
  'Watch Captain',
  'Stoneward',
  'Beaconwarden'
];

const hillholdExports = [
  'Granite keystones for mountain keeps',
  'Casks of ember-aged hill ale',
  'Runic beacons and signal braziers',
  'Polished horn trumpets for war warnings',
  'Refined copper filigree and fastenings',
  'Carved cairn-stones blessed by runepriests',
  'Seasoned pine from terraced groves',
  'Skybridge chains and hoist mechanisms'
];

const hillholdDefensiveTraits = [
  'Triple-beacon towers crown the ridgeline.',
  'Hidden sally tunnels open behind the hill.',
  'Rampart ballistae track the mountain pass day and night.',
  'Iron portcullises seal the ascent at a gesture.',
  'Seismic wards rumble whenever giants near.',
  'Water-driven sirens wail when the beacons ignite.'
];

const hillholdSentinelFocuses = [
  'guarding the trade-lanes that skirt the mountains',
  'keeping troll warbands from spilling onto the plains',
  'escorting caravans between hill clans and deep holds',
  'tracking wyvern flights that nest in the cliffs',
  'holding vigil for goblin raiders slipping through the passes',
  'surveying avalanche-prone slopes for signs of collapse',
  'maintaining the beacon-chain that links the northern holds',
  'patrolling ancient roads carved before the age of kings'
];

const goblinCaveNamePrefixes = [
  'Murkfang',
  'Skullcleft',
  'Rotlash',
  'Gloomspine',
  'Ashknuckle',
  'Blightvein',
  'Snarltooth',
  'Festerwick'
];

const goblinCaveNameSuffixes = ['Warrens', 'Lair', 'Grotto', 'Den', 'Burrows', 'Hollow', 'Tunnels'];

const goblinCaveHallmarks = [
  'Smoke-stained vents belch the scent of tallow and fungus brew.',
  'Caged cave wolves snarl from pits lining the main approach.',
  'Raid trophies dangle from sinew cords woven between stalactites.',
  'Alarm drums echo through the tunnels at the slightest intrusion.',
  'Glowmoss lanterns trace the paths of nightly war parties.',
  'Entrances are trapped with bone chimes and caltrop pits.',
  'Goblin glyphs warn trespassers of feasting clans within.'
];

const goblinCaveActivities = [
  'plotting raids on passing caravans',
  'brewing acrid fungus ales',
  'training warg packs for night assaults',
  'hammering crude iron spikes into jagged armour',
  'chanting to cavern spirits for luck in plunder',
  'bartering stolen steel with hidden hobgoblin envoys',
  'raising squirming litters of goblin young'
];

const goblinClanNames = [
  'Spitebite Clan',
  'Murkmaw Mob',
  'Rotcap Ragers',
  'Gloomlash Gang',
  'Ashgullet Horde',
  'Festerwick Rabble',
  'Skulknock Tribe',
  'Snarlfang Pack'
];

const dwarfholdPopulationRaceOptions = [
  { key: 'dwarves', label: 'Dwarves', color: '#f4c069' },
  { key: 'humans', label: 'Humans', color: '#9bb6d8' },
  { key: 'halflings', label: 'Halflings', color: '#f7a072' },
  { key: 'gnomes', label: 'Gnomes', color: '#c9a3e6' },
  { key: 'goblins', label: 'Goblins', color: '#7f8c4d' },
  { key: 'kobolds', label: 'Kobolds', color: '#b1c8ff' },
  { key: 'others', label: 'Others', color: '#9e9e9e' }
];

const dwarfholdOccupationRaces = [
  { key: 'orcs', label: 'Orcs', color: '#6b8f23' },
  { key: 'trolls', label: 'Trolls', color: '#4f6d7a' },
  { key: 'ratkin', label: 'Ratkin', color: '#7b5e57' },
  { key: 'kobolds', label: 'Kobolds', color: '#b1c8ff' }
];

const dwarfholdNearbyTownRadius = 12;

const evilWizardTowerBasePopulationOptions = [
  { key: 'wizards', label: 'Wizards', color: '#9c5cff' }
];

const evilWizardArchetypes = [
  {
    key: 'necromancer',
    label: 'Necromancer',
    populationOptions: [
      { key: 'undead', label: 'Undead', color: '#b1b1b1' }
    ]
  },
  {
    key: 'warlock',
    label: 'Warlock',
    populationOptions: [
      { key: 'undead', label: 'Undead', color: '#b1b1b1' },
      { key: 'humans', label: 'Humans', color: '#9bb6d8' }
    ]
  },
  {
    key: 'artificer',
    label: 'Artificer',
    populationOptions: [
      { key: 'elementals', label: 'Elementals', color: '#48cae4' }
    ]
  },
  {
    key: 'elementalist',
    label: 'Elementalist',
    populationOptions: [
      { key: 'elementals', label: 'Elementals', color: '#48cae4' },
      { key: 'mindflayers', label: 'Mindflayers', color: '#845ec2' }
    ]
  },
  {
    key: 'voidcaller',
    label: 'Voidcaller',
    populationOptions: [
      { key: 'mindflayers', label: 'Mindflayers', color: '#845ec2' },
      { key: 'undead', label: 'Undead', color: '#b1b1b1' }
    ]
  }
];

const towerCommanderTitles = [
  'Castellan',
  'Commander of the Watch',
  'High Warden',
  'Beacon Marshal',
  'Captain of the Rampart',
  'Signal Master'
];

const towerCommanderGivenNames = [
  'Aldren',
  'Briala',
  'Cordan',
  'Davia',
  'Elric',
  'Faelan',
  'Garrick',
  'Helena',
  'Ivor',
  'Jasra',
  'Kaelin',
  'Liora',
  'Marek',
  'Neriah',
  'Orin',
  'Phaedra',
  'Rothan',
  'Selene',
  'Tarin',
  'Vaelis'
];

const towerCommanderSurnames = [
  'Stonewatch',
  'Dawnshield',
  'Greybanner',
  'Stormgaze',
  'Ironflame',
  'Swiftspire',
  'Highward',
  'Lighthelm',
  'Crownguard',
  'Starwall',
  'Deepward',
  'Brightmarch'
];

const towerOrderNames = [
  'Order of the Dawnwatch',
  'Azure Sentinel Brigade',
  'Wardens of the Highroad',
  'Gilded Lantern Cohort',
  'Scarlet Banner Watch',
  'Guardians of the Stormline',
  'Emerald Rampart Order'
];

const towerDetachmentOptions = [
  'Hawkrider Wing',
  'Rune-Signal Corps',
  'Ballista Battery',
  'Skysteel Artillery',
  'Shadow Lanterners',
  'Emberguard Phalanx',
  'Stormlance Cavalry'
];

const towerDutyOptions = [
  'Guarding the high pass road',
  'Maintaining the beacon chain',
  'Patrolling the border marches',
  'Escorting vital trade caravans',
  'Watching over ancient ruins nearby',
  'Shielding frontier villages from raiders'
];

const towerHallmarks = [
  'Beacon flames that can be seen clear across the frontier.',
  'Clockwork lifts that carry scouts to the highest parapets.',
  'Signal mirrors that flash messages to distant allies at dusk.',
  'A vaulted armoury stocked with relic blades and bannered shields.',
  'An observatory dome charting the movements of stormclouds and foes alike.',
  'Stone walls etched with oath-runes that glow at the approach of danger.'
];

const towerPopulationRaceOptions = [
  { key: 'elves', label: 'Elves', color: '#6ecf85' },
  { key: 'humans', label: 'Humans', color: '#9bb6d8' },
  { key: 'dwarves', label: 'Dwarves', color: '#f4c069' },
  { key: 'halflings', label: 'Halflings', color: '#f7a072' },
  { key: 'dragonborn', label: 'Dragonborn', color: '#c16a6a' },
  { key: 'tieflings', label: 'Tieflings', color: '#b064b0' },
  { key: 'others', label: 'Others', color: '#9e9e9e' }
];

const townRulerTitles = {
  male: ['Mayor', 'Lord Mayor', 'High Steward', 'Burgomaster', 'Castellan'],
  female: ['Mayor', 'Lady Mayor', 'High Steward', 'Burgomistress', 'Castellan'],
  neutral: ['Governor', 'Magistrate', 'Marshal', 'Chamberlain', 'Steward']
};

const townHallmarks = [
  'Celebrated for its midsummer lantern festivals that light the riverways.',
  'Known for bustling markets where spices and silks trade hands till dusk.',
  'Renowned scribes illuminate tomes commissioned by distant courts.',
  'Shipwrights here launch swift river cutters and stout coastal cogs.',
  'Bards gather nightly in its echoing amphitheatre for tale and song.',
  'Town gardens brim with rare herbs prized by alchemists abroad.',
  'Its watchfires are said to be seen from the bordering highlands.',
  'Pilgrims arrive seasonally to venerate relics kept in the hilltop chapel.',
  'Stone bridges arch over canals lined with copper-roofed warehouses.',
  'Famous for street performers who juggle embers without being burned.'
];

const townExportOptions = [
  'Fine woolens and dyed textiles',
  'Barrels of spiced wine and cordial',
  'Carved hardwood furniture and cabinetry',
  'Glazed ceramics and painted pottery',
  'Ironmongery tools and horseshoes',
  'Salted riverfish and smoked eel',
  'Illuminated manuscripts and scrolls',
  'Perfumed oils and soaps',
  'Handcrafted musical instruments',
  'Leather saddles and tack'
];

const townPopulationRaceOptions = [
  { key: 'humans', label: 'Humans', color: '#9bb6d8' },
  { key: 'dwarves', label: 'Dwarves', color: '#f4c069' },
  { key: 'elves', label: 'Elves', color: '#6ecf85' },
  { key: 'halflings', label: 'Halflings', color: '#f7a072' },
  { key: 'gnomes', label: 'Gnomes', color: '#c9a3e6' },
  { key: 'dragonborn', label: 'Dragonborn', color: '#c16a6a' },
  { key: 'tieflings', label: 'Tieflings', color: '#b064b0' },
  { key: 'others', label: 'Others', color: '#9e9e9e' }
];

const townProminentFamilyNames = [
  'Ambermere',
  'Briarhelm',
  'Crownhill',
  'Dunleigh',
  'Emberfast',
  'Fairbloom',
  'Hallowmere',
  'Kestrelbourne',
  'Marrowind',
  'Ravenbrook',
  'Stormholt',
  'Thornwall',
  'Underford',
  'Wintermere'
];

const townGuildOptions = [
  'Merchants Consortium',
  'River Bargemen Union',
  'Artisan Collective',
  'Scribes and Illuminators Guild',
  'Shipwrights Assembly',
  'Alchemists Conclave',
  'Vintners Circle',
  'Weavers Syndicate',
  'Stevedores Brotherhood',
  'Stonemasons Chapter',
  'Cartographers Fellowship',
  'Apothecaries Guild',
  'Wrights and Carpenters Lodge',
  'Guard Captains Council',
  'Miners Exchange'
];

const snowVillageNamePrefixes = [
  'Aput',
  'Nanu',
  'Siku',
  'Qimmi',
  'Tuktu',
  'Aklaq',
  'Sila',
  'Ukpik',
  'Imaq',
  'Nuna',
  'Kangi',
  'Talir'
];

const snowVillageNameSuffixes = [
  'vik',
  'ruq',
  'naq',
  'lik',
  'juq',
  'toq',
  'riaq',
  'suk',
  'aluk',
  'tuuq'
];

const snowVillageNameDescriptors = ['Camp', 'Harbor', 'Haven', 'Settlement', 'Encampment'];

const snowVillageLeaderNamePools = {
  male: ['Aputi', 'Tulugaq', 'Inuk', 'Panik', 'Qajaq', 'Nanuq'],
  female: ['Sila', 'Nukka', 'Pipaluk', 'Kaya', 'Tala', 'Tekkeitsertok'],
  neutral: ['Siku', 'Atka', 'Ilu', 'Tuktu', 'Amaruq']
};

const snowVillageClanNames = ['Qimmiq', 'Sirmiq', 'Ukialik', 'Auyuittuq', 'Nunavik', 'Kugluktuk', 'Panaq', 'Talur'];

const snowVillageRulerTitles = {
  male: ['Isumataq', 'Angakkuq', 'Head Elder'],
  female: ['Isumataq', 'Angakkuq', 'Head Elder'],
  neutral: ['Isumataq', 'Angakkuq', 'Storykeeper']
};

const townFirstNamePools = {
  male: ['Aldric', 'Berend', 'Cedric', 'Darian', 'Edric', 'Garran', 'Henric', 'Loric', 'Rowan', 'Therin'],
  female: ['Adela', 'Brienne', 'Celia', 'Elowen', 'Fiora', 'Gwendolyn', 'Isolde', 'Maren', 'Rowena', 'Seren'],
  neutral: ['Arlen', 'Ember', 'Finley', 'Morgan', 'Robin', 'Sage', 'Tarian']
};

const settlementDetailTypes = new Set([
  'dwarfhold',
  'greatDwarfhold',
  'abandonedDwarfhold',
  'mine',
  'town',
  'city',
  'village',
  'hamlet',
  'evilWizardTower',
  'tower',
  'woodElfGrove',
  'lizardmenCity',
  'cave'
]);

function resolveTownRulerTitle(gender, randomFn) {
  const genderPool =
    (gender === 'male' && townRulerTitles.male) ||
    (gender === 'female' && townRulerTitles.female) ||
    townRulerTitles.neutral;
  const fallbackPool = townRulerTitles.neutral.length > 0 ? townRulerTitles.neutral : townRulerTitles.male;
  return pickRandomFrom(genderPool && genderPool.length > 0 ? genderPool : fallbackPool, randomFn) || 'Magistrate';
}

const townNamePrefixes = [
  'Oak',
  'River',
  'Stone',
  'Amber',
  'Green',
  'Silver',
  'Gold',
  'Iron',
  'Autumn',
  'Frost',
  'Sun',
  'Star',
  'Moon',
  'Wolf',
  'Wind',
  'Bright',
  'High',
  'Low',
  'Cedar',
  'Elm',
  'Maple',
  'Ash',
  'Willow',
  'King',
  'Queens',
  'Dragon',
  'Hearth',
  'North',
  'South',
  'East',
  'West'
];

const townNameSuffixes = [
  'ford',
  'field',
  'holm',
  'stead',
  'wich',
  'wick',
  'haven',
  'crest',
  'gate',
  'watch',
  'brook',
  'ton',
  'ham',
  'bridge',
  'moor',
  'port',
  'fall',
  'mere',
  'bury',
  'ridge',
  'moor',
  'bank',
  'view',
  'grove',
  'vale',
  'reach',
  'cross',
  'run',
  'rise',
  'pass'
];

const townNameDescriptors = [
  'Market',
  'Crossroads',
  'Commons',
  'Harbor',
  'Square',
  'Heights',
  'Heath',
  'Village',
  'Town',
  'Hold',
  'Keep',
  'Exchange',
  'Quarter',
  'Reach',
  'Hollow'
];

const towerNamePrefixes = [
  'Obsidian',
  'Gilded',
  'Runed',
  'Frost',
  'Storm',
  'Ivory',
  'Crimson',
  'Verdant',
  'Azure',
  'Shadow',
  'Sunset',
  'Moonrise',
  'Starfall',
  'Ember',
  'Sapphire'
];

const towerNameNouns = [
  'Tower',
  'Spire',
  'Watch',
  'Keep',
  'Pinnacle',
  'Bastion',
  'Citadel',
  'Lantern'
];

const towerNameQualifiers = [
  'of Dawn',
  'of Twilight',
  'of Storms',
  'of Secrets',
  'of Embers',
  'of Whispers',
  'of the North',
  'of the Veil',
  'of Echoes',
  'of the First Light',
  'of the Last Watch',
  'of the Silent Choir'
];

const evilWizardRulerTitles = [
  'Archwizard',
  'Grand Warlock',
  'Mistress of Hexes',
  'Dread Magister',
  'Shadow Thaumaturge',
  'High Necromancer'
];

const evilWizardGivenNames = [
  'Malachar',
  'Ilyria',
  'Vorstag',
  'Seraphine',
  'Kharzul',
  'Nymera',
  'Vaelix',
  'Thalorin',
  'Mordra',
  'Zephyros',
  'Elandra',
  'Raziel'
];

const evilWizardSurnames = [
  'Nightweaver',
  'Grimspire',
  'Voidbinder',
  'Dusksong',
  'Ashmantle',
  'Frostvein',
  'Starshroud',
  'Runeveil'
];

const evilWizardEpithets = [
  'the Unseen',
  'the Cruel',
  'the Whisperer',
  'the Pale Flame',
  'the Crimson Star',
  'the Endless',
  'the Voidcalled',
  'the Shadowed',
  'the Withering Gale',
  'the Stormbinder'
];

const evilWizardCabalNames = [
  'Circle of Nightglass',
  'Order of the Ebon Star',
  'Covenant of Ashen Veils',
  'Cabal of Thorned Sigils',
  'Symphony of Hollow Suns',
  'Chorus of Silent Bells'
];

const evilWizardTowerHallmarks = [
  'Shrouded perpetually in stormclouds that crackle with violet lightning.',
  'Whispers say its halls rearrange themselves with each moonrise.',
  'The central spire hums with runes that siphon magic from the ley.',
  'Populated by constructs wrought from obsidian and bone.',
  'Its beacon pulses nightly, summoning spirits from distant graves.',
  'Said to house a library bound in the memories of captured heroes.'
];

const woodElfGrovePrefixes = [
  'Sylvan',
  'Moon',
  'Star',
  'Silver',
  'Verdant',
  'Thorn',
  'Whisper',
  'Autumn',
  'Lark',
  'Eversong',
  'Glimmer',
  'Sun',
  'Briar',
  'Moss',
  'Willow'
];

const woodElfGroveSuffixes = [
  'Grove',
  'Glade',
  'Haven',
  'Refuge',
  'Circle',
  'Hollow',
  'Sanctum',
  'Enclave',
  'Retreat',
  'Thicket'
];

const woodElfGroveDescriptors = [
  'of the Dawn Chorus',
  'of Whispering Leaves',
  'of Starlit Boughs',
  'of the Emerald Court',
  'of the Eternal Spring',
  'of the Moonlit Vale',
  'of the Verdant Watch',
  'of the First Trees',
  'of Glimmering Dew',
  'of the Silver Song'
];

const woodElfGroveElderTitles = [
  'Grove Warden',
  'Verdant Speaker',
  'Circle Elder',
  'Keeper of Boughs',
  'Songwarden',
  'Dawnwatcher'
];

const woodElfGroveElderGivenNames = [
  'Aelar',
  'Lethariel',
  'Thamior',
  'Keyleth',
  'Varis',
  'Nymeria',
  'Caelynn',
  'Theren',
  'Sylvar',
  'Ilyana',
  'Faelar',
  'Lunessa'
];

const woodElfGroveElderSurnames = [
  'Silversong',
  'Oakenshade',
  'Nightbloom',
  'Moonglade',
  'Thornweaver',
  'Starpetal',
  'Sunshadow',
  'Mistralwind',
  'Fernstep',
  'Willowstrand'
];

const woodElfGroveHallmarks = [
  'Moonlit rites that weave auroras between the branches.',
  'Ancient treants stand guard over every winding path.',
  'Hidden pools shimmer with restorative starlight dew.',
  'The groves chorus echoes across the forest at dusk.',
  'Bough-bridges knit the canopy into spiralling promenades.',
  'Druidic songcraft summons blossoms even in winter.'
];

const forestRegionNamePrefixes = [
  'Verdant',
  'Whispering',
  'Emerald',
  'Silver',
  'Shadow',
  'Golden',
  'Moonlit',
  'Ancient',
  'Wild',
  'Sunset'
];

const forestRegionNameSuffixes = [
  'Groves',
  'Woods',
  'Thicket',
  'Wilds',
  'Canopy',
  'Boughs',
  'Hollows',
  'Glade',
  'Expanse',
  'Reserve'
];

const forestRegionNameMotifs = [
  'Echoes',
  'Mists',
  'Cicadas',
  'Fables',
  'Starlight',
  'Owls',
  'Whispers',
  'Lanterns',
  'Spirits',
  'Willows'
];

const mountainRangeNamePrefixes = [
  'Stone',
  'Iron',
  'Storm',
  'Thunder',
  'Frost',
  'Dragon',
  'Obsidian',
  'Moon',
  'Sunspire',
  'Titan'
];

const mountainRangeNameSuffixes = [
  'Peaks',
  'Range',
  'Highlands',
  'Crown',
  'Mountains',
  'Spines',
  'Escarpment',
  'Ridge',
  'Tor',
  'Bastions'
];

const mountainRangeNameMotifs = [
  'Storms',
  'Giants',
  'Dawn',
  'Ash',
  'Echoes',
  'Legends',
  'Stars',
  'Anvils',
  'Dragons',
  'Auroras'
];

const desertNameDescriptors = [
  'Shifting',
  'Burning',
  'Golden',
  'Silent',
  'Glass',
  'Crimson',
  'Howling',
  'Endless',
  'Scoured',
  'Sunken'
];

const desertNameNouns = [
  'Dunes',
  'Waste',
  'Expanse',
  'Sea',
  'Desert',
  'Reach',
  'Barrens',
  'Quarter',
  'Wastes',
  'Sands'
];

const desertNameMotifs = [
  'Mirages',
  'Ashes',
  'Suns',
  'Bones',
  'Scorpions',
  'Dust',
  'Secrets',
  'Hollows',
  'Echoes',
  'Zephyrs'
];

const tundraNameDescriptors = [
  'Frozen',
  'Ivory',
  'Bleak',
  'Glimmering',
  'Shivering',
  'Frostbound',
  'Auric',
  'Pale',
  'Windshorn',
  'Starlit'
];

const tundraNameNouns = [
  'Tundra',
  'Reach',
  'Steppes',
  'Barrens',
  'Fields',
  'Expanse',
  'Marches',
  'Plateau',
  'Glade',
  'March'
];

const tundraNameMotifs = [
  'Auroras',
  'Frost',
  'Comets',
  'Stars',
  'Echoes',
  'Drifts',
  'Owls',
  'Lights',
  'Mammoths',
  'Silence'
];

const grasslandNameDescriptors = [
  'Windward',
  'Emerald',
  'Golden',
  'Rolling',
  'Open',
  'Skylit',
  'Silver',
  'Gentle',
  'Breezy',
  'Sunlit'
];

const grasslandNameNouns = [
  'Plains',
  'Meadows',
  'Fields',
  'Prairies',
  'Steppes',
  'Expanse',
  'Downs',
  'Reach',
  'Hearth',
  'Lowlands'
];

const grasslandNameMotifs = [
  'Larks',
  'Horizon',
  'Harvests',
  'Echoes',
  'Sunsets',
  'Breezes',
  'Lanterns',
  'Auroras',
  'Stones',
  'Dreams'
];

const jungleNameDescriptors = [
  'Emerald',
  'Verdant',
  'Sun-dappled',
  'Obsidian',
  'Mist-shrouded',
  'Ancient',
  'Thundering',
  'Canopy',
  'Moonlit',
  'Serpent'
];

const jungleNameNouns = [
  'Jungle',
  'Wilds',
  'Canopy',
  'Rainforest',
  'Tangle',
  'Deepwood',
  'Labyrinth',
  'Greenway',
  'Expanse',
  'Verdure'
];

const jungleNameMotifs = [
  'Serpents',
  'Drums',
  'Monsoons',
  'Spirits',
  'Cenotes',
  'Orchids',
  'Tempests',
  'Roots',
  'Jaguar Spirits',
  'Emerald Dawn'
];

const marshNameDescriptors = [
  'Glimmer',
  'Mire',
  'Gloom',
  'Low',
  'Sodden',
  'Willow',
  'Brackish',
  'Sable',
  'Sunken',
  'Twilight'
];

const marshNameNouns = [
  'Bog',
  'Fen',
  'Morass',
  'Quagmire',
  'Wetlands',
  'Mires',
  'Marsh',
  'Reeds',
  'Pools',
  'Sinks'
];

const marshNameMotifs = [
  'Fireflies',
  'Lilies',
  'Secrets',
  'Mist',
  'Echoes',
  'Cranes',
  'Reeds',
  'Moss',
  'Shadows',
  'Frogs'
];

const badlandsNameDescriptors = [
  'Shattered',
  'Redstone',
  'Sundered',
  'Dustfallen',
  'Sunblasted',
  'Windswept',
  'Bleached',
  'Broken',
  'Scorched',
  'Cracked'
];

const badlandsNameNouns = [
  'Badlands',
  'Wastes',
  'Breaks',
  'Barrens',
  'Tablelands',
  'Escarpment',
  'Canyons',
  'Bluffs',
  'Ridges',
  'Maze'
];

const badlandsNameMotifs = [
  'Bones',
  'Dust',
  'Echoes',
  'Thunderheads',
  'Vultures',
  'Ash',
  'Mirages',
  'Sunstorms',
  'Ruins',
  'Storms'
];

const oceanNameDescriptors = [
  'Sapphire',
  'Tempest',
  'Sunken',
  'Cerulean',
  'Midnight',
  'Gilded',
  'Storm',
  'Azure',
  'Silent',
  'Everdeep'
];

const oceanNameNouns = [
  'Sea',
  'Ocean',
  'Gulf',
  'Sound',
  'Reach',
  'Current',
  'Depths',
  'Expanse',
  'Waters',
  'Strait'
];

const oceanNameMotifs = [
  'Sirens',
  'Stars',
  'Moons',
  'Whales',
  'Voyagers',
  'Storms',
  'Legends',
  'Coral',
  'Mists',
  'Echoes'
];

const lakeNameDescriptors = [
  'Silver',
  'Crystal',
  'Mirror',
  'Still',
  'Glimmer',
  'Duskwater',
  'Bright',
  'Moon',
  'Amber',
  'Serene'
];

const lakeNameNouns = [
  'Lake',
  'Mere',
  'Loch',
  'Pond',
  'Basin',
  'Reservoir',
  'Waters',
  'Lagoon',
  'Pool',
  'Bay'
];

const lakeNameMotifs = [
  'Echoes',
  'Willows',
  'Lanterns',
  'Dreams',
  'Reflections',
  'Whispers',
  'Herons',
  'Lilies',
  'Dawn',
  'Stars'
];

const woodElfGroveCircleNames = [
  'Circle of the Silver Bough',
  'Circle of Verdant Stars',
  'Circle of Whispering Winds',
  'Circle of Dawnpetals',
  'Circle of the Emerald Veil',
  'Circle of Moonshadow Paths',
  'Circle of the Luminous Seed',
  'Circle of the Elder Stag'
];

const woodElfGroveOrders = [
  'Wardens of the High Canopy',
  'Rangers of the Verdant Way',
  'Singers of the Luminous Thread',
  'Druids of the Moonwell Accord',
  'Keepers of the Auric Grove',
  'Mistwalkers of the Emerald Watch'
];

const woodElfGroveExports = [
  'Phials of rejuvenating moonwater',
  'Runed arrowheads carved from starwood',
  'Perfumed resins and incense petals',
  'Luminous moss for healing rituals',
  'Silken banners woven from leaf-fibres',
  'Seedstones that sprout protective thickets'
];

const woodElfGrovePopulationRoleOptions = [
  { key: 'elves', label: 'Wood Elves', color: '#6ecf85' },
  { key: 'satyrs', label: 'Satyrs', color: '#c18c5d' },
  { key: 'nymphs', label: 'Nymphs', color: '#9bd4a9' },
  { key: 'ents', label: 'Ents', color: '#8bbbcf' }
];

const woodElfGroveClassificationPopulationMax = {
  'Forest Retreat': 180,
  'Canopy Sanctuary': 240,
  'Hidden Enclave': 360,
  'Sacred Grove': 500,
  'Ancient Grove': 560
};

const lizardmenCityPopulationRoleOptions = [
  { key: 'lizardmen', label: 'Lizardmen', color: '#3a9f68' }
];

const lizardmenCityPrefixes = ['Ix', 'Zan', 'Tla', 'Chal', 'Maz', 'Quet', 'Ssz', 'Olo', 'Yax', 'Huac'];
const lizardmenCitySuffixes = ['atl', 'tlan', 'co', 'maz', 'naka', 'zotl', 'chan', 'poc', 'quil', 'pan'];
const lizardmenCityClassifications = [
  'Temple City',
  'Sacred Ziggurat',
  'Jungle Metropolis',
  'Canal Citadel',
  'Sun Pyramid Enclave'
];
const lizardmenCityHallmarks = [
  'Sun-drenched step pyramids rising above the canopy.',
  'Mist-draped terraces fed by warm jungle springs.',
  'Obsidian causeways linking flooded plazas.',
  'Crocodilian cavalry drilling in emerald plazas.',
  'Sacred cenotes ringed with chanting acolytes.',
  'Jade-lined canals glowing with bioluminescent algae.'
];
const lizardmenCityRulerTitles = [
  'High Scale-Priest',
  'Sunblood Speaker',
  'Serpent King',
  'Celadon Oracle',
  'Dawn-Caller',
  'Mist Matron'
];
const lizardmenCityRulerNames = [
  'Xilqua',
  'Mazaton',
  'Tezcali',
  'Chakli',
  'Zazamet',
  'Itzali',
  'Qaztil',
  'Sszara',
  'Olotec',
  'Tzimek'
];
const lizardmenCityOrders = [
  'Order of the Dawnfang',
  'Jade Sentinel Cohort',
  'Scaled Oracle Council',
  'Mistfang Navigators',
  'Emerald Tide Wardens',
  'Obsidian Fang Legion',
  'Sunblood Procession',
  'Stormscale Tidewatch'
];
const lizardmenCityExports = [
  'Sun-baked obsidian blades',
  'Jade ritual masks',
  'Rare dyes pressed from jungle blooms',
  'Sacred incense cones',
  'Feathered cloaks lacquered in gold',
  'Fermented serpentwine',
  'Glittering shell mosaics'
];

const orcTribeAdjectives = [
  'Ironjaw',
  'Bloodfang',
  'Stormhide',
  'Ashen',
  'Bonegnaw',
  'Thunderhoof',
  'Grimgaze',
  'Skullsplitter',
  'Nightscar',
  'Rageborn'
];
const orcTribeNouns = [
  'Clan',
  'Warband',
  'Legion',
  'Brood',
  'Horde',
  'Reavers',
  'Marauders',
  'Prowlers'
];
const orcCampFeatures = [
  'War drums thunder at dusk from within the palisade.',
  'Spiked palisades bear trophies from raided caravans.',
  'Tattered war banners crackle in the smoky wind.',
  'An arena of packed earth hosts nightly combat rites.',
  'Blacksmith forges belch sparks as crude blades are hammered.',
  'Watchfires burn green with alchemical fumes.',
  'Captured standards hang as warnings to intruders.',
  'Siege totems ring the muster fields with carved skulls.',
  'Wolf pens echo with snarls as wargs are blooded for war.',
  'Smouldering pyres roast slabs of captured game beneath iron spits.',
  "Runic totems glow faintly, channeling the shamans' war magic.",
  'War shamans trace scars of conquest in ash across the ground.'
];
const orcWarLeaders = [
  'Gorath the Red',
  'Mazrak One-Eye',
  'Thura Ironhide',
  'Balgrom Spinebreaker',
  'Igra Wildfang',
  'Vorgh the Thunderer',
  'Sagra the Ember Fist',
  'Druza Stormchant'
];
const orcThreatDescriptors = ['Elevated', 'Severe', 'Dire', 'Menacing'];
const gnollPackAdjectives = [
  'Dustmane',
  'Howling',
  'Sunscar',
  'Nightmaw',
  'Boneclaw',
  'Ashsnout',
  'Stormsnout',
  'Ragged',
  'Skullmuzzle',
  'Emberfang'
];
const gnollPackNouns = [
  'Pack',
  'Raid',
  'Howlers',
  'Hunters',
  'Warband',
  'Maw',
  'Snarl',
  'Scavengers'
];
const gnollCampFeatures = [
  'Hyena laughter ripples through the night around bone-festooned totems.',
  'Racks of scavenged shields rattle in the dusty wind.',
  'Smoke from marrow fires mingles with the copper scent of fresh kills.',
  'Bone fetishes clatter from lines strung between crude hide tents.',
  'Fresh tracks circle the camp where scouts prowl for prey.',
  'Hidebound drums pulse with erratic, feral rhythms.',
  'Stolen banners flutter from poles, their colors daubed over in ochre runes.'
];
const gnollWarLeaders = [
  'Szimri Bone-Eater',
  'Raka Sun-Scar',
  'Yagra Laughing Maw',
  'Thokha Dusthowl',
  'Mekri Clawtaker',
  'Zharri Emberfur',
  'Gkala Night-Cackle',
  'Fenrik Thornsnout'
];
const gnollThreatDescriptors = ['Elevated', 'Severe', 'Ravenous', 'Unstable'];
const trollDenAdjectives = [
  'Bog',
  'Stone',
  'Mire',
  'Frost',
  'Grim',
  'Thunder',
  'Rot',
  'Boulder',
  'Moss',
  'Brine'
];
const trollDenNouns = [
  'Den',
  'Brood',
  'Hollow',
  'Pit',
  'Haunt',
  'Grotto',
  'Crag',
  'Hold'
];
const trollCampFeatures = [
  'Sodden logs reinforce earthen berms slick with algae.',
  'Cauldrons bubble with pungent stews of swamp herbs and bone.',
  'Huge footprints sink deep into the mud around crude watchposts.',
  'Petrified trophies hang from stalagmites that jut through the camp.',
  'Pools of regeneration glow faintly beneath dangling charms.',
  'Stone totems scarred by claw marks mark the brood\'s territory.',
  'Fetid mists coil low where shamans chant to forgotten spirits.'
];
const trollWarLeaders = [
  'Gorvul the Regrown',
  'Svara Mireblood',
  'Thrum Rockhide',
  'Ulmak Bone-Twister',
  'Yrog the Trollfather',
  'Brelga Marsh-Eye',
  'Drumm Stonebelly',
  'Hulra Riverbane'
];
const trollThreatDescriptors = ['Elevated', 'Severe', 'Dire', 'Relentless'];
const ogreClanAdjectives = [
  'Crushjaw',
  'Bonegrinder',
  'Thundermaul',
  'Ironbelly',
  'Boulderfist',
  'Skullsmash',
  'Stormbreaker',
  'Gorehammer',
  'Rubblehide',
  'Maulbrand'
];
const ogreClanNouns = [
  'Clan',
  'Muster',
  'Warband',
  'Brutes',
  'Crushers',
  'Maulers',
  'Slam',
  'Rend'
];
const ogreCampFeatures = [
  'Enormous clubs lean against boulders beside shattered siege engines.',
  'Meat racks sag beneath the weight of whole roasted beasts.',
  'Stone drums boom as ogres challenge one another for dominance.',
  'Piles of splintered shields form makeshift barricades.',
  'Massive footprints churn the earth into muddy pits.',
  'Bone totems crowned with cracked helms tower over the encampment.',
  'Wagons stripped for timber bolster crude siege towers.'
];
const ogreWarLeaders = [
  'Grunak Boulderborn',
  'Mazga Skullsplit',
  'Durmag the Slammer',
  'Olra Ironbelly',
  'Thurg Grudgebite',
  'Rendha Thunderhand',
  'Krolf Meat-Hewer',
  'Vorga Stonecrusher'
];
const ogreThreatDescriptors = ['Severe', 'Dire', 'Overwhelming', 'Menacing'];
const banditCrewAdjectives = [
  'Red',
  'Black',
  'Iron',
  'Rust',
  'Shadow',
  'Amber',
  'Silver',
  'Wild',
  'Gravel',
  'Broken'
];
const banditCrewNouns = [
  'Knives',
  'Riders',
  'Coyotes',
  'Lanterns',
  'Vultures',
  'Hands',
  'Blades',
  'Company',
  'Road',
  'Hollows'
];
const banditCampFeatures = [
  'Lookouts with hooded lanterns signal across hidden paths.',
  'A palisade of wagons shields caches of stolen goods.',
  'Practice dummies are riddled with crossbow bolts by moonlight.',
  'Cookfires smoke with the scent of spiced trail stew and black powder.',
  'Maps of trade routes lie weighted beneath daggers in the command tent.',
  'Captured banners hang upside down as trophies of defiance.',
  'Hidden pitfall traps are dusted over to snare unwary pursuers.'
];
const banditLeaders = [
  'Captain Rysa Blackflint',
  'Ser Caldor the Spare',
  'Matron Vel Tallow',
  'Garrin Embercloak',
  'The Grinning Fox',
  'Jessa Quickthorn',
  'Marshal Darek Ironlace',
  'Nyra of the Broken Road'
];
const banditThreatDescriptors = ['Wary', 'Perilous', 'Severe', 'Menacing'];
const banditSpecialties = [
  'ambushing caravans that brave the frontier passes',
  'selling illicit guides across the border wilds',
  'smuggling relics through hidden ravines',
  'extorting frontier villages for tribute',
  'hijacking supply barges before they reach port',
  'raiding tax convoys returning to the heartland',
  'running contraband between rival duchies',
  'training cutthroat outriders for mercenary companies'
];
const warCampTypeBaseWeights = {
  orcCamp: 1.05,
  gnollCamp: 0.95,
  trollCamp: 0.85,
  ogreCamp: 0.8,
  banditCamp: 1.1
};
const centaurHerdAdjectives = [
  'Swiftwind',
  'Stormhoof',
  'Sunmane',
  'Moonstride',
  'Galeheart',
  'Starhoof',
  'Dawnrunner',
  'Thunderleaf',
  'Mistveil',
  'Wildsong'
];
const centaurHerdNouns = [
  'Herd',
  'Circle',
  'Moot',
  'Outriders',
  'Gathering',
  'Courers',
  'Skyriders',
  'Wardens'
];
const centaurEncampmentPurposes = [
  'holds council over the roaming tribes',
  'guards the border trails against marauders',
  'drills its outriders for the next great hunt',
  'prepares offerings to the sky-spirits',
  'keeps watch on encroaching warbands',
  'tends the wounded after a clash on the plains',
  'celebrates the seasonal moot beneath streaming banners'
];
const centaurEncampmentFeatures = [
  'Hoofbeat drums echo across a packed-earth arena.',
  'Banners woven from tall grasses ripple between painted wagons.',
  'Stone cairns ring a central fire that never dies.',
  'Archery buttes bristle with moon-feathered shafts.',
  'Totem poles carved with galloping figures mark each quarter of the camp.',
  'Bronze-lashed chariots gleam beside neatly stacked spear racks.'
];
const centaurLeaderTitles = [
  'Herdspeaker',
  'Skycaller',
  'Trail-Warden',
  'High Courser',
  'Windseer',
  'Spear Marshal'
];
const centaurLeaderNames = [
  'Thandros',
  'Mirael',
  'Koryn',
  'Ilys',
  'Brastan',
  'Velith',
  'Serane',
  'Oran',
  'Kaelith',
  'Drevan'
];
const centaurMajorClans = [
  'Sunmane Banner',
  'Stormhoof Lodge',
  'Mistplain Riders',
  'Starbrook Company',
  'Galehorn Cohort',
  'Ambertrail Scouts',
  'Stonehoof Fellowship',
  'Larksong Reavers'
];
const centaurSacredVows = ['Sky Oaths', 'Trailwatch Pledge', 'Galloping Accord', 'Sunfire Pact'];
const travelerCampHosts = [
  'the Emberlane siblings',
  'Matron Heila Oakshaw',
  'a circle of veteran rangers',
  'Quartermaster Brond of the West March',
  'the caravan guild of Lanterntrail',
  'Scoutmaster Vessa Quillsong'
];
const travelerCampFocuses = [
  'guiding caravans through the border wilds',
  'trading maps and rumours for supplies',
  'harbouring refugees bound for safer lands',
  'drilling outriders to patrol the marches',
  'stockpiling goods for a distant expedition',
  'watching the roads for bandit movement'
];
const travelerCampSupplies = [
  'fresh water skins, smoked meats, and wagon grease',
  'oiled cloaks, mended harnesses, and hardy ponies',
  'herbal poultices, coil rope, and trimmed torches',
  'arrow sheaves, spare axles, and starlight charts',
  'travel bread, pitch tarps, and finely balanced spears'
];
const travelerCampAtmospheres = [
  'Lanterns sway from tall poles, casting amber halos across the tents.',
  'A cookfire crackles beside a ring of storytellers comparing pathfinding lore.',
  'Watchmen pace the palisade while scouts tally the night sky.',
  'Scribes annotate trail ledgers by the glow of rune-lit stones.',
  'Children chase one another between carts while lookouts scan the horizon.'
];
const travelerCampServices = [
  'fresh mounts for weary outriders',
  'hireling guards to bolster caravan ranks',
  'trail wardens who escort pilgrims between towns',
  'medics stitching wounds earned on the road',
  'scouts selling the latest safe passage reports'
];

const tavernAdjectives = ['Golden', 'Starlit', 'Roaring', 'Whispering', 'Copper', 'Moonlit', 'Wandering'];
const tavernNouns = ['Hearth', 'Steed', 'Keg', 'Anvil', 'Lantern', 'Drum', 'Oak'];
const tavernDescriptors = [
  'Crossroads Inn',
  'Wayside Rest',
  'Taphouse',
  'Roadhouse',
  "Pilgrim's Lodge",
  'Caravan Hostel'
];
const tavernInnkeepers = [
  'Innkeep Mara Hearthspoon',
  'Old Rulfen Barrelhelm',
  'Mistress Sera Dawnsong',
  'Tarin Embercoat and his wife Lysa',
  'The twins Peira and Pell',
  'Guilder Hask of the Wayfarer League'
];
const tavernSpecialties = [
  'cinder-spiced stout poured over hot stones',
  'wildberry mead and cedar-smoked trout',
  'poppyseed bread with cavern cheese',
  'applejack mulled with sprig-mint',
  'honey-glazed boar shanks carved tableside'
];
const tavernReputations = [
  'favoured by caravan guards trading tall tales',
  'famed for calming border disputes over shared cups',
  'whispered about by merchants chasing lucky omens',
  'beloved by pilgrims making the long journey north',
  'a trusted muster point for royal couriers'
];
const tavernAmenities = [
  'a roaring hearth and slate-tiled baths',
  'private loft bunks lined with fleece blankets',
  'secure stables tended through the night',
  'a stage for bards and a loft for dice games',
  'a stocked cellar with rare vintages on tap'
];
const tavernAtmospheres = [
  'Music drifts into the road while travellers warm chilled hands.',
  'Lantern light spills across wagon ruts like melted gold.',
  'Scented smoke and laughter mingle beneath the eaves.',
  'Patrons cluster around maps pinned to the main beam.',
  'Night watch bells hang ready beside the doorway.'
];
const tavernServices = [
  'message runners willing to brave the moonlit pass',
  'guides charting quick routes between duchies',
  'lockboxes for merchant tithes and purses',
  'farriers who shoe beasts while you dine',
  'scribes drafting contracts over candlelight'
];
const tavernRatePhrases = [
  'four silver a room with hearth-warmed blankets',
  "a single gold buys a week's board and fodder",
  'two silver a night, breakfast and stall included',
  'one silver for the common loft, five for a private suite',
  'coin or fresh news accepted for a bed and a meal'
];
const tavernSpecialGuests = [
  'wandering magi swapping spellcraft rumours',
  'dwarven merchants peddling gem-cut curios',
  'elves mapping safe shadow crossings',
  'lancers offering escort to the next hold',
  'minstrels composing sagas for generous patrons'
];

const dungeonNamePrefixes = [
  'Whispering',
  'Sunken',
  'Forsaken',
  'Crumbling',
  'Midnight',
  'Shrouded',
  'Veiled',
  'Obsidian'
];
const dungeonNameSuffixes = [
  'Vault',
  'Depths',
  'Catacomb',
  'Sepulchre',
  'Labyrinth',
  'Halls',
  'Crypt'
];
const dungeonPerils = [
  'echo with restless spirits',
  'are laced with shifting stonework traps',
  'are patrolled by tireless constructs',
  'hide relics bound with cursed wards',
  'are veiled in ever-burning witchfire',
  'conceal a slumbering wyrm'
];
const dungeonDepths = ['three', 'five', 'seven', 'nine'];

const monasteryOrders = [
  'Order of the Dawn Lantern',
  'Order of Silent Rivers',
  'Brotherhood of the Verdant Star',
  'Scribes of the Hidden Song',
  'Wardens of the Azure Flame',
  'Sisters of the Gentle Bell'
];
const monasteryVirtues = [
  'contemplation',
  'vigilance',
  'compassion',
  'illumination',
  'endurance',
  'harmony'
];
const monasteryRelics = [
  'a saintly bell that rings without wind',
  'scrolls penned in starlight ink',
  'the Ember Chalice of first dawn',
  'a reliquary of luminous feathers',
  'a mirror that remembers forgotten hymns'
];

const castleHouseNames = [
  'House Blackthorn',
  'House Rivenshield',
  'House Cindergate',
  'House Frostmere',
  'House Dawnspear',
  'House Emberhall'
];
const castleDefensiveTraits = [
  'Commands a triple-ring curtain wall.',
  'Boasts arrow-slitted towers overlooking the vale.',
  'Is girded by rune-carved gatehouses.',
  'Holds a hidden sally tunnel for swift sorties.',
  'Is anchored to living stone by dwarven masonry.'
];
const castleBanners = [
  'a silver gryphon on midnight blue',
  'twin suns over a crimson field',
  'a sable stag wreathed in ivy',
  'interlocked hammers upon gold',
  'a white phoenix rising from ash'
];

const saintlyNames = [
  'Saint Elowen',
  'Saint Calder',
  'Saint Miriel',
  'Saint Tharan',
  'Saint Ysoria',
  'Saint Brannoc'
];
const saintMiracles = [
  'calmed a wildfire with a whispered prayer',
  'healed an entire plague-struck village',
  'turned back a tide of marauding spirits',
  'walked across a frozen sea to guide refugees',
  'struck down a demon with a blade of light'
];
const shrineOfferings = [
  'garlands of moonpetals',
  'etched votive coins',
  'bottled starlight dew',
  'hand-carved icons',
  'woven prayer cords'
];
const shrinePilgrims = [
  'penitents seeking absolution',
  'knights pledging holy vows',
  'healers learning forgotten benedictions',
  'pilgrims chasing whispered visions',
  'shepherds praying for gentle winters'
];

function pickRandomFrom(array, random) {
  if (!Array.isArray(array) || array.length === 0) {
    return '';
  }
  const randomFn = typeof random === 'function' ? random : Math.random;
  const index = Math.floor(randomFn() * array.length);
  const clampedIndex = Math.max(0, Math.min(array.length - 1, index));
  return array[clampedIndex];
}

function shuffleArray(array, random) {
  // Shuffle an array using Fisher-Yates algorithm
  // Returns a new shuffled array, does not modify the original
  if (!Array.isArray(array) || array.length === 0) {
    return [];
  }
  const randomFn = typeof random === 'function' ? random : Math.random;
  const result = array.slice(); // Create a copy
  
  // Fisher-Yates shuffle
  for (let i = result.length - 1; i > 0; i -= 1) {
    const j = Math.floor(randomFn() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  
  return result;
}

function pickUniqueFrom(array, count, random) {
  if (!Array.isArray(array) || array.length === 0 || count <= 0) {
    return [];
  }
  const randomFn = typeof random === 'function' ? random : Math.random;
  const pool = array.slice();
  const picks = [];
  const maxCount = Math.min(Math.max(count, 0), pool.length);
  for (let i = 0; i < maxCount; i += 1) {
    const index = Math.floor(randomFn() * pool.length);
    const clampedIndex = Math.max(0, Math.min(pool.length - 1, index));
    const [choice] = pool.splice(clampedIndex, 1);
    if (choice !== undefined) {
      picks.push(choice);
    }
  }
  return picks;
}

function formatListWithConjunction(items, conjunction = 'and') {
  if (!Array.isArray(items)) {
    return '';
  }
  const filtered = items
    .map((item) => (typeof item === 'string' ? item.trim() : ''))
    .filter((item) => item.length > 0);

  if (filtered.length === 0) {
    return '';
  }

  if (filtered.length === 1) {
    return filtered[0];
  }

  if (filtered.length === 2) {
    return `${filtered[0]} ${conjunction} ${filtered[1]}`;
  }

  const parts = filtered.slice(0, -1);
  const last = filtered[filtered.length - 1];
  return `${parts.join(', ')}, ${conjunction} ${last}`;
}

function generateForestRegionName(random, context = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const prefix = pickRandomFrom(forestRegionNamePrefixes, randomFn) || 'Verdant';
  const suffix = pickRandomFrom(forestRegionNameSuffixes, randomFn) || 'Woods';
  const motif = pickRandomFrom(forestRegionNameMotifs, randomFn);
  if (motif && randomFn() < 0.65) {
    return `${prefix} ${suffix} of the ${motif}`;
  }
  if (randomFn() < 0.35) {
    return `The ${prefix} ${suffix}`;
  }
  return `${prefix} ${suffix}`;
}

function generateMountainRangeName(random, context = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const prefix = pickRandomFrom(mountainRangeNamePrefixes, randomFn) || 'Stone';
  const suffix = pickRandomFrom(mountainRangeNameSuffixes, randomFn) || 'Peaks';
  const motif = pickRandomFrom(mountainRangeNameMotifs, randomFn);
  if (motif && randomFn() < 0.6) {
    return `${prefix} ${suffix} of the ${motif}`;
  }
  return `The ${prefix} ${suffix}`;
}

function generateDesertName(random, context = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const descriptor = pickRandomFrom(desertNameDescriptors, randomFn) || 'Shifting';
  const noun = pickRandomFrom(desertNameNouns, randomFn) || 'Dunes';
  const motif = pickRandomFrom(desertNameMotifs, randomFn);
  if (motif && randomFn() < 0.5) {
    return `${noun} of the ${motif}`;
  }
  return `The ${descriptor} ${noun}`;
}

function generateTundraName(random, context = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const descriptor = pickRandomFrom(tundraNameDescriptors, randomFn) || 'Frozen';
  const noun = pickRandomFrom(tundraNameNouns, randomFn) || 'Tundra';
  const motif = pickRandomFrom(tundraNameMotifs, randomFn);
  if (motif && randomFn() < 0.55) {
    return `${noun} of the ${motif}`;
  }
  return `The ${descriptor} ${noun}`;
}

function generateGrasslandName(random, context = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const descriptor = pickRandomFrom(grasslandNameDescriptors, randomFn) || 'Golden';
  const noun = pickRandomFrom(grasslandNameNouns, randomFn) || 'Plains';
  const motif = pickRandomFrom(grasslandNameMotifs, randomFn);
  if (motif && randomFn() < 0.5) {
    return `${noun} of the ${motif}`;
  }
  if (randomFn() < 0.4) {
    return `The ${descriptor} ${noun}`;
  }
  return `${descriptor} ${noun}`;
}

function generateJungleName(random, context = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const descriptor = pickRandomFrom(jungleNameDescriptors, randomFn) || 'Emerald';
  const noun = pickRandomFrom(jungleNameNouns, randomFn) || 'Jungle';
  const motif = pickRandomFrom(jungleNameMotifs, randomFn);
  if (motif && randomFn() < 0.65) {
    return `${noun} of the ${motif}`;
  }
  if (randomFn() < 0.45) {
    return `The ${descriptor} ${noun}`;
  }
  return `${descriptor} ${noun}`;
}

function generateMarshlandName(random, context = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const descriptor = pickRandomFrom(marshNameDescriptors, randomFn) || 'Sunken';
  const noun = pickRandomFrom(marshNameNouns, randomFn) || 'Bog';
  const motif = pickRandomFrom(marshNameMotifs, randomFn);
  if (motif && randomFn() < 0.6) {
    return `${descriptor} ${noun} of the ${motif}`;
  }
  return `The ${descriptor} ${noun}`;
}

function generateBadlandsName(random, context = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const descriptor = pickRandomFrom(badlandsNameDescriptors, randomFn) || 'Shattered';
  const noun = pickRandomFrom(badlandsNameNouns, randomFn) || 'Badlands';
  const motif = pickRandomFrom(badlandsNameMotifs, randomFn);
  if (motif && randomFn() < 0.55) {
    return `${noun} of the ${motif}`;
  }
  if (randomFn() < 0.35) {
    return `The ${descriptor} ${noun}`;
  }
  return `${descriptor} ${noun}`;
}

function generateOceanName(random, context = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const descriptor = pickRandomFrom(oceanNameDescriptors, randomFn) || 'Sapphire';
  let noun = pickRandomFrom(oceanNameNouns, randomFn) || 'Sea';
  const motif = pickRandomFrom(oceanNameMotifs, randomFn);
  if (context && context.size && context.size < 120 && noun === 'Ocean') {
    noun = 'Sea';
  }
  if (motif && randomFn() < 0.65) {
    return `${noun} of the ${motif}`;
  }
  return `The ${descriptor} ${noun}`;
}

function generateLakeName(random, context = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const descriptor = pickRandomFrom(lakeNameDescriptors, randomFn) || 'Silver';
  const noun = pickRandomFrom(lakeNameNouns, randomFn) || 'Lake';
  const motif = pickRandomFrom(lakeNameMotifs, randomFn);
  const normalizedNoun = noun.toLowerCase();
  if (normalizedNoun === 'lake' || normalizedNoun === 'loch') {
    if (motif && randomFn() < 0.7) {
      return `${noun} ${motif}`;
    }
    return `${noun} ${descriptor}`;
  }
  if (motif && randomFn() < 0.6) {
    return `The ${descriptor} ${noun} of the ${motif}`;
  }
  return `The ${descriptor} ${noun}`;
}

function generateRealmName(random) {
  // Generate a name for a realm/kingdom using existing realm name arrays
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(realmNameAdjectives, randomFn);
  const noun = pickRandomFrom(realmNameNouns, randomFn);
  
  if (adjective && noun) {
    return `${adjective} ${noun}`;
  } else if (noun) {
    return noun;
  } else if (adjective) {
    return `${adjective} Realm`;
  }
  return 'The Realm';
}

const biomeTypeDefinitions = {
  forest: { label: 'Forest', generator: generateForestRegionName },
  jungle: { label: 'Jungle', generator: generateJungleName },
  mountain: { label: 'Mountain Range', generator: generateMountainRangeName },
  desert: { label: 'Desert', generator: generateDesertName },
  badlands: { label: 'Badlands', generator: generateBadlandsName },
  tundra: { label: 'Tundra', generator: generateTundraName },
  grassland: { label: 'Grassland', generator: generateGrasslandName },
  marsh: { label: 'Marsh', generator: generateMarshlandName },
  ocean: { label: 'Ocean', generator: generateOceanName },
  lake: { label: 'Lake', generator: generateLakeName }
};

function generateBiomeAreaName(biomeType, random, context = {}) {
  if (!biomeType) {
    return null;
  }
  const definition = biomeTypeDefinitions[biomeType];
  if (!definition || typeof definition.generator !== 'function') {
    return null;
  }
  const name = definition.generator(random, context);
  if (typeof name === 'string') {
    const trimmed = name.trim();
    if (trimmed.length > 0) {
      return trimmed;
    }
  }
  return null;
}

function generatePopulationBreakdownFromOptions(options, population, random, config = {}) {
  if (!Array.isArray(options) || options.length === 0) {
    return [];
  }

  const randomFn = typeof random === 'function' ? random : Math.random;
  const {
    majorityIndex = 0,
    majorityShareRange = [0, 1],
    ensureMajority = true
  } = config;

  const shares = [];
  const candidates = options.slice();
  let majorityShare = 0;

  if (ensureMajority && candidates.length > 0) {
    const rawIndex = Number.isFinite(majorityIndex) ? Math.round(majorityIndex) : 0;
    const index = clamp(rawIndex, 0, candidates.length - 1);
    const [rangeMinRaw, rangeMaxRaw] = Array.isArray(majorityShareRange)
      ? majorityShareRange
      : [0, 1];
    const rangeMin = clamp(Number.isFinite(rangeMinRaw) ? rangeMinRaw : 0, 0, 1);
    const rangeMax = clamp(Number.isFinite(rangeMaxRaw) ? rangeMaxRaw : 1, rangeMin, 1);
    const [selected] = candidates.splice(index, 1);
    if (selected) {
      const shareRange = rangeMax - rangeMin;
      const share = shareRange <= 0 ? rangeMin : rangeMin + randomFn() * shareRange;
      majorityShare = clamp(share, 0, 1);
      shares.push({ config: selected, share: majorityShare });
    }
  }

  const remainingConfigs = candidates;
  if (remainingConfigs.length > 0) {
    const remainingShare = ensureMajority ? Math.max(0, 1 - majorityShare) : 1;
    const weights = remainingConfigs.map(() => 0.2 + randomFn());
    const weightSum = weights.reduce((sum, value) => sum + value, 0) || 1;
    remainingConfigs.forEach((config, index) => {
      const portion = weights[index] / weightSum;
      shares.push({ config, share: remainingShare * portion });
    });
  }

  let totalShare = shares.reduce((sum, entry) => sum + entry.share, 0);
  if (shares.length > 0 && Number.isFinite(totalShare) && totalShare !== 1) {
    const lastEntry = shares[shares.length - 1];
    const adjustment = clamp(1 - totalShare, -1, 1);
    lastEntry.share = clamp(lastEntry.share + adjustment, 0, 1);
    totalShare = shares.reduce((sum, entry) => sum + entry.share, 0);
  }

  const safeTotalShare = totalShare > 0 ? totalShare : 1;
  const normalizedShares = shares.map((entry) => ({
    config: entry.config,
    share: clamp(entry.share / safeTotalShare, 0, 1)
  }));

  const percentageDecimals = 2;
  const percentageScale = 10 ** percentageDecimals;
  const totalUnits = 100 * percentageScale;

  const scaledEntries = normalizedShares.map(({ config, share }) => {
    const safeShare = clamp(share, 0, 1);
    const rawPercentage = safeShare * 100;
    const scaledRaw = rawPercentage * percentageScale;
    const baseUnit = Math.floor(scaledRaw);
    const fraction = Math.max(0, Math.min(1, scaledRaw - baseUnit));
    return {
      config,
      baseUnit,
      fraction
    };
  });

  const baseUnits = scaledEntries.map((entry) => entry.baseUnit);
  let remainderUnits = totalUnits - baseUnits.reduce((sum, value) => sum + value, 0);
  const fractionalOrder = scaledEntries
    .map((entry, index) => ({ index, fraction: entry.fraction }))
    .sort((a, b) => b.fraction - a.fraction);

  if (fractionalOrder.length > 0) {
    let incrementIndex = 0;
    while (remainderUnits > 0) {
      const target = fractionalOrder[incrementIndex % fractionalOrder.length];
      baseUnits[target.index] += 1;
      remainderUnits -= 1;
      incrementIndex += 1;
    }

    const ascending = fractionalOrder.slice().reverse();
    let decrementIndex = 0;
    while (remainderUnits < 0 && ascending.length > 0) {
      const target = ascending[decrementIndex % ascending.length];
      if (baseUnits[target.index] > 0) {
        baseUnits[target.index] -= 1;
        remainderUnits += 1;
      }
      decrementIndex += 1;
    }
  }

  if (remainderUnits !== 0 && baseUnits.length > 0) {
    const lastIndex = baseUnits.length - 1;
    const adjusted = Math.max(0, Math.min(totalUnits, baseUnits[lastIndex] + remainderUnits));
    remainderUnits -= adjusted - baseUnits[lastIndex];
    baseUnits[lastIndex] = adjusted;
  }

  const resolvedPopulation = Number.isFinite(population) ? Math.max(0, Math.round(population)) : null;

  return scaledEntries.map(({ config }, index) => {
    const percentage = clamp(baseUnits[index] / percentageScale, 0, 100);
    const count =
      resolvedPopulation === null
        ? null
        : Math.max(0, Math.round((resolvedPopulation * percentage) / 100));
    return {
      key: config.key,
      label: config.label,
      color: config.color,
      percentage,
      population: count
    };
  });
}

function generateTowerPopulationBreakdown(population, random) {
  return generatePopulationBreakdownFromOptions(towerPopulationRaceOptions, population, random, {
    majorityIndex: 0,
    majorityShareRange: [0.9, 0.98],
    ensureMajority: true
  });
}

function generateDwarfholdPopulationBreakdown(population, random, options = {}) {
  if (!Array.isArray(dwarfholdPopulationRaceOptions) || dwarfholdPopulationRaceOptions.length === 0) {
    return [];
  }

  const randomFn = typeof random === 'function' ? random : Math.random;
  const hasNearbyHumanSettlement = Boolean(options && options.hasNearbyHumanSettlement);
  const configMap = new Map(dwarfholdPopulationRaceOptions.map((config) => [config.key, config]));
  const dwarfConfig = configMap.get('dwarves');

  if (!dwarfConfig) {
    return [];
  }

  const resolvedPopulation = Number.isFinite(population) ? Math.max(0, Math.round(population)) : null;
  const majorityRange = hasNearbyHumanSettlement ? [0.85, 0.93] : [0.9, 0.96];
  const rangeMin = clamp(majorityRange[0], 0, 1);
  const rangeMax = clamp(majorityRange[1], rangeMin, 1);
  const shareRange = rangeMax - rangeMin;
  const dwarfShare = shareRange <= 0 ? rangeMin : rangeMin + randomFn() * shareRange;
  const shares = [{ config: dwarfConfig, share: clamp(dwarfShare, 0, 1) }];
  const remainderShare = Math.max(0, 1 - shares[0].share);

  const weightPlans = hasNearbyHumanSettlement
    ? [
        { key: 'humans', min: 0.9, max: 1.6 },
        { key: 'halflings', min: 0.7, max: 1.2 },
        { key: 'gnomes', min: 0.15, max: 0.4 },
        { key: 'goblins', min: 0.12, max: 0.35 },
        { key: 'kobolds', min: 0.12, max: 0.35 },
        { key: 'others', min: 0, max: 0.2 }
      ]
    : [
        { key: 'gnomes', min: 0.8, max: 1.4 },
        { key: 'goblins', min: 0.9, max: 1.5 },
        { key: 'kobolds', min: 0.7, max: 1.2 },
        { key: 'others', min: 0, max: 0.25 }
      ];

  const weightEntries = weightPlans
    .map((plan) => {
      const config = configMap.get(plan.key);
      if (!config) {
        return null;
      }
      const min = Math.max(0, Number.isFinite(plan.min) ? plan.min : 0);
      const max = Math.max(min, Number.isFinite(plan.max) ? plan.max : min);
      if (max <= 0) {
        return null;
      }
      const weight = min + randomFn() * (max - min);
      if (weight <= 0) {
        return null;
      }
      return { config, weight };
    })
    .filter(Boolean);

  const weightSum = weightEntries.reduce((sum, entry) => sum + entry.weight, 0);

  if (remainderShare > 0 && weightSum > 0) {
    weightEntries.forEach((entry) => {
      const share = (entry.weight / weightSum) * remainderShare;
      shares.push({ config: entry.config, share });
    });
  }

  const totalShare = shares.reduce((sum, entry) => sum + entry.share, 0);
  const safeTotalShare = totalShare > 0 ? totalShare : 1;
  const normalizedShares = shares.map((entry) => ({
    config: entry.config,
    share: clamp(entry.share / safeTotalShare, 0, 1)
  }));

  const percentageDecimals = 2;
  const percentageScale = 10 ** percentageDecimals;
  const totalUnits = 100 * percentageScale;

  const scaledEntries = normalizedShares.map(({ config, share }) => {
    const safeShare = clamp(share, 0, 1);
    const rawPercentage = safeShare * 100;
    const scaledRaw = rawPercentage * percentageScale;
    const baseUnit = Math.floor(scaledRaw);
    const fraction = Math.max(0, Math.min(1, scaledRaw - baseUnit));
    return {
      config,
      baseUnit,
      fraction
    };
  });

  const baseUnits = scaledEntries.map((entry) => entry.baseUnit);
  let remainderUnits = totalUnits - baseUnits.reduce((sum, value) => sum + value, 0);
  const fractionalOrder = scaledEntries
    .map((entry, index) => ({ index, fraction: entry.fraction }))
    .sort((a, b) => b.fraction - a.fraction);

  if (fractionalOrder.length > 0) {
    let incrementIndex = 0;
    while (remainderUnits > 0) {
      const target = fractionalOrder[incrementIndex % fractionalOrder.length];
      baseUnits[target.index] += 1;
      remainderUnits -= 1;
      incrementIndex += 1;
    }

    const ascending = fractionalOrder.slice().reverse();
    let decrementIndex = 0;
    while (remainderUnits < 0 && ascending.length > 0) {
      const target = ascending[decrementIndex % ascending.length];
      if (baseUnits[target.index] > 0) {
        baseUnits[target.index] -= 1;
        remainderUnits += 1;
      }
      decrementIndex += 1;
    }
  }

  if (remainderUnits !== 0 && baseUnits.length > 0) {
    const lastIndex = baseUnits.length - 1;
    const adjusted = Math.max(0, Math.min(totalUnits, baseUnits[lastIndex] + remainderUnits));
    remainderUnits -= adjusted - baseUnits[lastIndex];
    baseUnits[lastIndex] = adjusted;
  }

  return scaledEntries.map(({ config }, index) => {
    const percentage = clamp(baseUnits[index] / percentageScale, 0, 100);
    const count =
      resolvedPopulation === null
        ? null
        : Math.max(0, Math.round((resolvedPopulation * percentage) / 100));
    return {
      key: config.key,
      label: config.label,
      color: config.color,
      percentage,
      population: count
    };
  });
}

function generateEvilWizardTowerPopulationBreakdown(population, random, wizardCount, archetype) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const resolvedPopulation = Math.max(0, Math.round(Number.isFinite(population) ? population : 0));
  const resolvedWizardCount = Math.max(
    0,
    Math.min(
      Math.round(Number.isFinite(wizardCount) ? wizardCount : 0),
      resolvedPopulation
    )
  );
  const remainderPopulation = Math.max(0, resolvedPopulation - resolvedWizardCount);

  const baseOptions = Array.isArray(evilWizardTowerBasePopulationOptions)
    ? evilWizardTowerBasePopulationOptions
    : [];
  const wizardOption = baseOptions[0] || null;
  const remainderBaseOptions = baseOptions.length > 1 ? baseOptions.slice(1) : [];

  const specializationOptions = Array.isArray(archetype?.populationOptions)
    ? archetype.populationOptions.filter(
        (option) =>
          option &&
          typeof option.key === 'string' &&
          option.key &&
          typeof option.label === 'string' &&
          option.label.trim()
      )
    : [];

  const remainderOptions = [...specializationOptions, ...remainderBaseOptions];

  let remainderBreakdown = [];
  if (remainderPopulation > 0 && remainderOptions.length > 0) {
    const shareRange = specializationOptions.length > 0 ? [0.45, 0.7] : [0.35, 0.6];
    remainderBreakdown = generatePopulationBreakdownFromOptions(
      remainderOptions,
      remainderPopulation,
      randomFn,
      {
        majorityIndex: 0,
        majorityShareRange: shareRange,
        ensureMajority: true
      }
    );
  }

  if (!wizardOption) {
    return remainderBreakdown;
  }

  const wizardEntry = {
    ...wizardOption,
    percentage:
      resolvedPopulation === 0
        ? 0
        : clamp((resolvedWizardCount / resolvedPopulation) * 100, 0, 100),
    population: resolvedWizardCount
  };

  if (remainderBreakdown.length === 0) {
    return [wizardEntry];
  }

  const normalizedRemainder = remainderBreakdown.map((entry) => ({
    ...entry,
    percentage:
      resolvedPopulation === 0
        ? 0
        : clamp((entry.population / resolvedPopulation) * 100, 0, 100)
  }));

  return [wizardEntry, ...normalizedRemainder];
}

function generateTownPopulationBreakdown(population, random) {
  return generatePopulationBreakdownFromOptions(townPopulationRaceOptions, population, random, {
    majorityIndex: 0,
    majorityShareRange: [0.6, 0.85],
    ensureMajority: true
  });
}

function generateWoodElfGrovePopulationBreakdown(population, random) {
  return generatePopulationBreakdownFromOptions(
    woodElfGrovePopulationRoleOptions,
    population,
    random,
    {
      majorityIndex: 0,
      majorityShareRange: [0.9, 0.97],
      ensureMajority: true
    }
  );
}

function generateLizardmenCityPopulationBreakdown(population, random) {
  return generatePopulationBreakdownFromOptions(
    lizardmenCityPopulationRoleOptions,
    population,
    random,
    {
      majorityIndex: 0,
      majorityShareRange: [0.45, 0.6],
      ensureMajority: true
    }
  );
}

function generateDwarfholdName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  if (Array.isArray(dwarfholdCuratedNames) && dwarfholdCuratedNames.length > 0) {
    const curatedRoll = randomFn();
    if (curatedRoll < 0.8) {
      const curatedName = pickRandomFrom(dwarfholdCuratedNames, randomFn);
      if (typeof curatedName === 'string' && curatedName.length > 0) {
        return curatedName;
      }
    }
  }
  const prefix = pickRandomFrom(dwarfholdNamePrefixes, randomFn) || 'Stone';
  const suffix = pickRandomFrom(dwarfholdNameSuffixes, randomFn) || 'hold';
  const baseName = `${prefix}${suffix}`;
  const descriptor = pickRandomFrom(dwarfholdNameDescriptors, randomFn);
  const region = pickRandomFrom(dwarfholdNameRegions, randomFn);
  const styleRoll = randomFn();
  if (styleRoll < 0.4 && descriptor) {
    return `${baseName} ${descriptor}`;
  }
  if (styleRoll < 0.8 && region) {
    return `${baseName} of ${region}`;
  }
  if (descriptor && styleRoll < 0.95) {
    return `${baseName} ${descriptor}`;
  }
  return baseName;
}

function generateDwarfholdDetails(name, random, options = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const isAbandoned = Boolean(options && options.isAbandoned);
  const isDarkHold = Boolean(options && options.isDarkHold);

  if (isAbandoned) {
    const variantRoll = randomFn();
    if (variantRoll < 0.33) {
      return {
        type: 'abandonedDwarfhold',
        classification: 'Abandoned Dwarfhold',
        name,
        population: 0,
        populationLabel: 'Population',
        populationDescriptor: 'residents',
        isSettlement: true,
        ruler: null,
        foundedYearsAgo: null,
        prominentClan: null,
        prominentGroup: null,
        prominentGroupLabel: null,
        hallmark: 'Empty halls lie silent beneath the mountain.',
        majorGuilds: [],
        majorExports: [],
        populationBreakdown: [],
        description: 'Dust-choked corridors and sealed vaults are all that remain of the dwarves who once dwelt here.'
      };
    }

    if (variantRoll < 0.66) {
      const hasSurvivors = randomFn() < 0.45;
      const ruinedPopulation = hasSurvivors ? Math.max(8, Math.floor(20 + randomFn() * 220)) : 0;
      const ruinedBreakdown = hasSurvivors
        ? [
            {
              key: 'dwarves',
              label: 'Dwarves',
              population: ruinedPopulation,
              percentage: 1,
              color: defaultCultureColorByKey.dwarves
            }
          ]
        : [];
      return {
        type: 'ruinedDwarfhold',
        classification: 'Ruined Dwarfhold',
        name,
        population: ruinedPopulation,
        populationLabel: 'Population',
        populationDescriptor: 'residents',
        isSettlement: true,
        ruler: null,
        foundedYearsAgo: null,
        prominentClan: null,
        prominentGroup: null,
        prominentGroupLabel: null,
        hallmark: 'Collapsed chambers and shattered gates hint at the calamity that broke the hold.',
        majorGuilds: [],
        majorExports: [],
        populationBreakdown: ruinedBreakdown,
        description: hasSurvivors
          ? 'A battered handful of survivors keep watch over the broken halls.'
          : 'Only ruins and echoes remain after the fall of this hold.'
      };
    }

    const occupation = pickRandomFrom(dwarfholdOccupationRaces, randomFn) || dwarfholdOccupationRaces[0];
    const occupationLabel = occupation?.label || 'Orcs';
    const occupationKey = occupation?.key || 'orcs';
    const occupationColor = occupation?.color || '#6b8f23';
    const occupiedPopulation = Math.max(40, Math.floor(120 + randomFn() * 1500));
    const occupiedBreakdown = [
      {
        key: occupationKey,
        label: occupationLabel,
        population: occupiedPopulation,
        percentage: 1,
        color: occupationColor
      }
    ];
    const occupationDescriptor = occupationLabel.toLowerCase();
    return {
      type: 'occupiedDwarfhold',
      classification: 'Occupied Dwarfhold',
      name,
      population: occupiedPopulation,
      populationLabel: 'Population',
      populationDescriptor: 'residents',
      isSettlement: true,
      ruler: null,
      foundedYearsAgo: null,
      prominentClan: null,
      prominentGroup: null,
      prominentGroupLabel: null,
      hallmark: `Warbands of ${occupationDescriptor} have claimed these once-dwarven halls.`,
      majorGuilds: [],
      majorExports: [],
      populationBreakdown: occupiedBreakdown,
      description: `${occupationLabel} have seized the hold and repurposed its vaulted chambers as their lair.`
    };
  }

  const population = Math.max(120, Math.floor(450 + randomFn() * 4200));
  const genderRoll = randomFn();
  const gender = genderRoll < 0.9 ? 'male' : 'female';
  const namePool = dwarfNamePools[gender] || dwarfNamePools.male;
  const firstName = pickRandomFrom(namePool, randomFn) || 'Urist';
  const clanOption = pickRandomFrom(dwarfOptions.clan, randomFn) || dwarfOptions.clan?.[0];
  const clanName = clanOption?.label || 'Stonebeard';
  let rulerTitle;
  if (isDarkHold) {
    rulerTitle = pickRandomFrom(darkDwarfholdLeaderTitles, randomFn) || 'Sorcerer-Prophet';
  } else {
    const titlePool = dwarfholdRulerTitles[gender] || dwarfholdRulerTitles.male;
    const titleFallback = 'Thane';
    const thaneBiasRoll = randomFn();
    const nonThaneTitles = titlePool.filter((title) => title !== 'Thane');
    rulerTitle =
      thaneBiasRoll < 0.65 || nonThaneTitles.length === 0
        ? 'Thane'
        : pickRandomFrom(nonThaneTitles, randomFn) || titleFallback;
  }
  const hallmark = pickRandomFrom(dwarfholdHallmarks, randomFn) ||
    'Renowned for stout walls and heartier spirits.';
  const foundedYearsAgo = Math.max(30, Math.floor(80 + randomFn() * 3921));
  const prominentClanOption = randomFn() < 0.35 ? pickRandomFrom(dwarfOptions.clan, randomFn) : clanOption;
  const prominentClan = prominentClanOption?.label || clanName;
  const majorGuildCount = clamp(Math.floor(2 + randomFn() * 3), 1, dwarfGuildOptions.length);
  const majorGuilds = pickUniqueFrom(
    dwarfGuildOptions.map((option) => option.label),
    majorGuildCount,
    randomFn
  );
  const majorExportCount = clamp(Math.floor(2 + randomFn() * 2), 1, dwarfholdExportOptions.length);
  const majorExports = pickUniqueFrom(dwarfholdExportOptions, majorExportCount, randomFn);
  const majorClanPool = Array.isArray(dwarfOptions?.clan)
    ? dwarfOptions.clan.map((option) => option?.label).filter((label) => typeof label === 'string' && label.trim())
    : [];
  let majorClans = [];
  if (majorClanPool.length > 0) {
    const targetCount = clamp(Math.floor(2 + randomFn() * 3), 2, majorClanPool.length);
    const available = majorClanPool.filter((label) => label !== prominentClan);
    const additional = pickUniqueFrom(available, Math.max(0, targetCount - 1), randomFn);
    majorClans = [prominentClan, ...additional];
  }
  if (majorClans.length > 0) {
    majorClans = Array.from(new Set(majorClans));
  }
  const majorClansDescription = formatListWithConjunction(majorClans);
  const description = majorClansDescription ? `Major clans represented: ${majorClansDescription}.` : null;
  const populationBreakdown = generateDwarfholdPopulationBreakdown(population, randomFn, {
    hasNearbyHumanSettlement: Boolean(options && options.hasNearbyHumanSettlement)
  });
  const clanBreakdown = generateLabelBreakdown(majorClans, randomFn, {
    keyPrefix: 'clan',
    colorSeed: 'clan'
  });
  const guildBreakdown = generateLabelBreakdown(majorGuilds, randomFn, {
    keyPrefix: 'guild',
    colorSeed: 'guild'
  });

  const classification = population >= 4000 ? 'greatDwarfhold' : 'dwarfhold';
  const classificationLabel = classification === 'greatDwarfhold' ? 'Great Dwarfhold' : 'Dwarfhold';

  const baseDetails = {
    type: classification,
    classification: classificationLabel,
    name,
    population,
    populationLabel: 'Population',
    populationDescriptor: 'residents',
    isSettlement: true,
    ruler: {
      title: rulerTitle,
      name: `${firstName} ${clanName}`
    },
    foundedYearsAgo,
    prominentClan,
    prominentGroup: prominentClan,
    prominentGroupLabel: 'Prominent Clan',
    hallmark,
    majorGuilds,
    majorExports,
    majorClans,
    majorClansLabel: 'Major Clans',
    populationBreakdown,
    clanBreakdown,
    guildBreakdown,
    description
  };

  if (isDarkHold) {
    const moltenExports = Array.isArray(baseDetails.majorExports)
      ? baseDetails.majorExports.slice()
      : [];
    moltenExports.push('Obsidian Ingots');
    moltenExports.push('Sulfur-Glass Relics');
    const uniqueExports = Array.from(new Set(moltenExports));

    const augmentedGuilds = Array.isArray(baseDetails.majorGuilds)
      ? Array.from(new Set([...baseDetails.majorGuilds, 'Ashforged Covenant']))
      : ['Ashforged Covenant'];

    const darkPopulationBreakdown = Array.isArray(baseDetails.populationBreakdown)
      ? baseDetails.populationBreakdown.map((entry) =>
          entry && entry.key === 'dwarves'
            ? {
                ...entry,
                label: 'Dark Dwarves',
                color: '#3b2a3d'
              }
            : entry
        )
      : [];

    const darkHallmark = `${baseDetails.hallmark} Magma channels drawn from nearby volcanoes keep their forges blazing.`;
    const darkDescription = baseDetails.description
      ? `${baseDetails.description} Ash-stained banners and magma sluices define every hall.`
      : 'Ash-stained banners and magma sluices define every hall.';

    return {
      ...baseDetails,
      type: 'darkDwarfhold',
      classification: 'Dark Dwarfhold',
      populationDescriptor: 'residents',
      majorExports: uniqueExports,
      majorGuilds: augmentedGuilds,
      populationBreakdown: darkPopulationBreakdown,
      hallmark: darkHallmark,
      description: darkDescription
    };
  }

  return baseDetails;
}

function generateMineName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const prefix = pickRandomFrom(mineNamePrefixes, randomFn) || 'Iron';
  const suffix = pickRandomFrom(mineNameSuffixes, randomFn) || 'delve';
  const descriptor = pickRandomFrom(mineNameDescriptors, randomFn) || 'Mine';
  const combinedSuffix = suffix.charAt(0).toUpperCase() + suffix.slice(1);
  const style = randomFn();
  if (style < 0.35) {
    return `${prefix}${combinedSuffix} ${descriptor}`;
  }
  if (style < 0.65) {
    return `${prefix} ${descriptor}`;
  }
  if (style < 0.85) {
    return `${descriptor} of ${prefix}${combinedSuffix}`;
  }
  return `${prefix}${combinedSuffix}`;
}

function generateMineDetails(name, random, options = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const profile = pickRandomFrom(mineResourceProfiles, randomFn) || mineResourceProfiles[0];
  const hazard = pickRandomFrom(mineHazardOptions, randomFn) || mineHazardOptions[0];
  const crew = pickRandomFrom(mineCrewNames, randomFn) || mineCrewNames[0];
  const workforce = Math.max(28, Math.floor(60 + randomFn() * 220));
  const overseerRoll = randomFn();
  const overseerGender = overseerRoll < 0.6 ? 'male' : overseerRoll < 0.9 ? 'female' : 'male';
  const overseerPool = dwarfNamePools[overseerGender] || dwarfNamePools.male;
  const overseerFirst = pickRandomFrom(overseerPool, randomFn) || 'Urist';
  const clanOption = pickRandomFrom(dwarfClanOptions, randomFn) || dwarfClanOptions[0];
  const overseerClan = clanOption?.label || 'Stonebeard';
  const overseerName = `${overseerFirst} ${overseerClan}`;
  const foundedYearsAgo = Math.max(2, Math.floor(5 + randomFn() * 60));
  const shiftCount = Math.max(2, Math.round(2 + randomFn() * 2));
  const nearestHoldLabel = formatSettlementLabelForDetails(options?.nearestDwarfhold);
  const nearestHoldDistance = Number.isFinite(options?.nearestHoldDistance)
    ? Math.max(1, Math.round(options.nearestHoldDistance))
    : null;

  const guildSet = new Set(['Miners Guild']);
  if (randomFn() < 0.65) {
    guildSet.add('Smelters Guild');
  }
  if (randomFn() < 0.35) {
    guildSet.add('Engineers Guild');
  }
  const majorGuilds = Array.from(guildSet);

  const exports = [profile.export];
  if (randomFn() < 0.45) {
    exports.push(pickRandomFrom(mineSecondaryExports, randomFn) || mineSecondaryExports[0]);
  }
  const uniqueExports = Array.from(new Set(exports));

  const hallmarkParts = [profile.description];
  if (nearestHoldLabel) {
    hallmarkParts.push(
      `Ore caravans supply ${nearestHoldLabel}${
        nearestHoldDistance ? ` after ${nearestHoldDistance} leagues through the passes` : ''
      }.`
    );
  }
  const hazardSentence = `Hazard: ${hazard.charAt(0).toUpperCase()}${hazard.slice(1)}.`;
  hallmarkParts.push(hazardSentence);
  const hallmark = hallmarkParts.join(' ');

  const breakdownTemplate = [
    { key: 'dwarves', label: 'Dwarves', percentage: 0.72, color: '#c08452' },
    { key: 'humans', label: 'Humans', percentage: 0.1, color: '#d1b58f' },
    { key: 'gnomes', label: 'Gnomes', percentage: 0.08, color: '#b8a7d9' },
    { key: 'others', label: 'Others', percentage: 0.1, color: '#9e9e9e' }
  ];

  let assigned = 0;
  const populationBreakdown = breakdownTemplate.map((entry, index) => {
    let percentage = entry.percentage;
    if (index === breakdownTemplate.length - 1) {
      percentage = clamp(1 - assigned, 0, 1);
    }
    assigned += percentage;
    return {
      key: entry.key,
      label: entry.label,
      percentage,
      color: entry.color,
      population: Math.max(0, Math.round(workforce * percentage))
    };
  });

  return {
    type: 'mine',
    classification: 'Mine',
    name,
    population: workforce,
    populationLabel: 'Workforce',
    populationDescriptor: 'residents',
    isSettlement: true,
    ruler: {
      title: 'Overseer',
      name: overseerName
    },
    foundedYearsAgo,
    prominentGroup: `${crew} — Shift ${shiftCount}`,
    prominentGroupLabel: 'Crew in Charge',
    majorGuilds,
    majorGuildsLabel: 'Guild Presence',
    majorExports: uniqueExports,
    majorExportsLabel: 'Primary Exports',
    populationBreakdown,
    hallmark,
    hallmarkLabel: 'Notable Features'
  };
}

function generateHillholdName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const prefix = pickRandomFrom(hillholdNamePrefixes, randomFn) || 'Stone';
  const suffix = pickRandomFrom(hillholdNameSuffixes, randomFn) || 'hold';
  const descriptor = pickRandomFrom(hillholdNameDescriptors, randomFn);
  const baseName = `${prefix}${suffix}`;
  const style = randomFn();
  if (style < 0.3 && descriptor) {
    return `${baseName} ${descriptor}`;
  }
  if (style < 0.6 && descriptor) {
    return `${descriptor} Hillhold`;
  }
  if (style < 0.85) {
    return `${baseName} Hillhold`;
  }
  return `${baseName} Hold`;
}

function generateHillholdDetails(name, random, options = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const population = Math.max(90, Math.floor(180 + randomFn() * 1600));
  let classification = 'Hillhold Outpost';
  if (population >= 1500) {
    classification = 'Great Hillhold';
  } else if (population >= 900) {
    classification = 'Foothill Stronghold';
  } else if (population >= 420) {
    classification = 'Hillhold';
  }

  const genderRoll = randomFn();
  const gender = genderRoll < 0.82 ? 'male' : genderRoll < 0.95 ? 'female' : 'neutral';
  const namePool = dwarfNamePools[gender] || dwarfNamePools.male;
  const firstName = pickRandomFrom(namePool, randomFn) || 'Urist';
  const clanOption = pickRandomFrom(dwarfOptions.clan, randomFn) || dwarfOptions.clan?.[0];
  const clanName = clanOption?.label || 'Stonebeard';
  const wardenTitle = pickRandomFrom(hillholdWardenTitles, randomFn) || 'Holdthane';
  const hallmark = pickRandomFrom(hillholdHallmarks, randomFn) || hillholdHallmarks[0];
  const watchOrder = pickRandomFrom(hillholdWatchOrders, randomFn) || 'Ridgeguard Brotherhood';
  const exportCount = clamp(Math.floor(1 + randomFn() * 2), 1, hillholdExports.length);
  const exports = pickUniqueFrom(hillholdExports, exportCount, randomFn);
  const defensiveTrait = pickRandomFrom(hillholdDefensiveTraits, randomFn) || hillholdDefensiveTraits[0];
  const sentinelFocus = pickRandomFrom(hillholdSentinelFocuses, randomFn) || hillholdSentinelFocuses[0];
  const foundedYearsAgo = Math.max(18, Math.floor(40 + randomFn() * 260));
  const majorClanPool = Array.isArray(dwarfOptions?.clan)
    ? dwarfOptions.clan.map((option) => option?.label).filter((label) => typeof label === 'string' && label.trim())
    : [];
  let majorClans = [];
  if (majorClanPool.length > 0) {
    const targetCount = clamp(Math.floor(2 + randomFn() * 2), 2, majorClanPool.length);
    const available = majorClanPool.filter((label) => label !== clanName);
    const additional = pickUniqueFrom(available, Math.max(0, targetCount - 1), randomFn);
    majorClans = [clanName, ...additional];
  }
  if (majorClans.length > 0) {
    majorClans = Array.from(new Set(majorClans));
  }

  const nearestHoldInfo = options?.nearestDwarfhold || null;
  const nearestHoldPoint = nearestHoldInfo?.point || null;
  const nearestHoldName =
    nearestHoldPoint?.name ||
    nearestHoldPoint?.structureName ||
    (typeof nearestHoldPoint?.label === 'string' ? nearestHoldPoint.label : null);
  const dwarfholdDistance = Number.isFinite(nearestHoldInfo?.distance)
    ? Math.max(1, Math.round(nearestHoldInfo.distance))
    : null;
  const mountainDistance = Number.isFinite(options?.mountainDistance)
    ? Math.max(1, Math.round(options.mountainDistance))
    : null;

  const caravanSentence = nearestHoldName
    ? `Caravans from ${nearestHoldName} arrive after ${dwarfholdDistance || 'several'} leagues along the ridge paths.`
    : 'It stands as an independent bastion for scattered hill clans.';
  const beaconSentence = mountainDistance
    ? `Beacon-crews report the nearest crags are only ${mountainDistance} leagues away.`
    : 'Beacon-crews keep sight on the surrounding crags.';
  const descriptionParts = [
    `${watchOrder} keep watch here, ${sentinelFocus}. ${defensiveTrait} ${caravanSentence} ${beaconSentence}`.trim()
  ];
  const majorClansDescription = formatListWithConjunction(majorClans);
  if (majorClansDescription) {
    descriptionParts.push(`Major clans present: ${majorClansDescription}.`);
  }
  const description = descriptionParts.join(' ').trim();

  const populationBreakdown = generateDwarfholdPopulationBreakdown(population, randomFn, {
    hasNearbyHumanSettlement: Boolean(options?.hasNearbyHumanSettlement)
  });
  const clanBreakdown = generateLabelBreakdown(majorClans, randomFn, {
    keyPrefix: 'clan',
    colorSeed: 'clan'
  });

  return {
    type: 'hillhold',
    classification,
    name,
    population,
    populationLabel: 'Population',
    populationDescriptor: 'residents',
    isSettlement: true,
    ruler: {
      title: wardenTitle,
      name: `${firstName} ${clanName}`
    },
    foundedYearsAgo,
    prominentGroup: watchOrder,
    prominentGroupLabel: 'Sentinel Order',
    hallmark,
    hallmarkLabel: 'Renowned For',
    majorExports: exports,
    majorExportsLabel: 'Exports',
    majorClans,
    majorClansLabel: 'Major Clans',
    populationBreakdown,
    clanBreakdown,
    description
  };
}

function generateEvilWizardTowerDetails(name, random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const population = Math.max(1, Math.floor(1 + randomFn() * 599));
  const wizardRoll = randomFn();
  const wizardCount =
    wizardRoll < 0.7
      ? 1
      : 2 + Math.floor(randomFn() * 9);
  const resolvedWizardCount = Math.max(1, Math.min(wizardCount, population));
  let classification = 'Wizard Tower';
  if (population >= 400) {
    classification = 'Dread Citadel';
  } else if (population >= 240) {
    classification = 'Shadow Spire';
  } else if (population >= 140) {
    classification = 'Arcane Bastion';
  }

  const rulerTitle = pickRandomFrom(evilWizardRulerTitles, randomFn) || 'Archwizard';
  const rulerName = generateEvilWizardName(randomFn);
  const foundedYearsAgo = Math.max(6, Math.floor(20 + randomFn() * 240));
  const cabal = pickRandomFrom(evilWizardCabalNames, randomFn);
  const prominentGroup = cabal || null;
  const hallmark = pickRandomFrom(evilWizardTowerHallmarks, randomFn) ||
    'Shrouded in eldritch wards that thrum through the night.';
  const wizardArchetype = pickRandomFrom(evilWizardArchetypes, randomFn) || null;
  const populationBreakdown = generateEvilWizardTowerPopulationBreakdown(
    population,
    randomFn,
    resolvedWizardCount,
    wizardArchetype
  );

  return {
    type: 'evilWizardTower',
    classification,
    name,
    population,
    populationLabel: 'Population',
    populationDescriptor: 'residents',
    isSettlement: true,
    ruler: {
      title: rulerTitle,
      name: rulerName
    },
    foundedYearsAgo,
    prominentGroup,
    prominentGroupLabel: 'Dominant Cabal',
    hallmark,
    hallmarkLabel: 'Notorious For',
    wizardTradition: wizardArchetype ? wizardArchetype.label : null,
    wizardTraditionLabel: wizardArchetype ? 'Arcane Tradition' : null,
    populationBreakdown
  };
}

function generateTownName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const prefix = pickRandomFrom(townNamePrefixes, randomFn) || 'Oak';
  const suffix = pickRandomFrom(townNameSuffixes, randomFn) || 'ford';
  const baseName = `${prefix}${suffix}`;
  const descriptor = pickRandomFrom(townNameDescriptors, randomFn);
  const styleRoll = randomFn();
  if (styleRoll < 0.3 && descriptor) {
    return `${baseName} ${descriptor}`;
  }
  if (styleRoll < 0.65) {
    return baseName;
  }
  return `Town of ${baseName}`;
}

function generateSnowVillageName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const prefix = pickRandomFrom(snowVillageNamePrefixes, randomFn) || 'Siku';
  const suffix = pickRandomFrom(snowVillageNameSuffixes, randomFn) || 'vik';
  const baseName = `${prefix}${suffix}`;
  const descriptor = pickRandomFrom(snowVillageNameDescriptors, randomFn);
  const styleRoll = randomFn();
  if (descriptor && styleRoll < 0.35) {
    return `${baseName} ${descriptor}`;
  }
  if (descriptor && styleRoll > 0.85) {
    return `${descriptor} of ${baseName}`;
  }
  return baseName;
}

function generateTownDetails(name, random, options = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const isSnowVillage = Boolean(options.snowVillage);
  const population = isSnowVillage
    ? Math.max(20, Math.floor(30 + randomFn() * 70))
    : Math.max(20, Math.floor(20 + randomFn() * 6000));
  let classification = 'Village';
  if (!isSnowVillage) {
    if (population >= 6000) {
      classification = 'City';
    } else if (population >= 3600) {
      classification = 'Large Town';
    } else if (population >= 100) {
      classification = 'Town';
    }
  }

  const type = classification === 'City' ? 'city' : classification === 'Village' ? 'village' : 'town';
  const genderRoll = randomFn();
  const gender = genderRoll < 0.45 ? 'male' : genderRoll < 0.9 ? 'female' : 'neutral';
  const firstNamePool = isSnowVillage
    ? (gender === 'male' && snowVillageLeaderNamePools.male) ||
      (gender === 'female' && snowVillageLeaderNamePools.female) ||
      snowVillageLeaderNamePools.neutral
    : (gender === 'male' && townFirstNamePools.male) ||
      (gender === 'female' && townFirstNamePools.female) ||
      townFirstNamePools.neutral;
  const fallbackPool = isSnowVillage
    ? snowVillageLeaderNamePools.neutral || snowVillageLeaderNamePools.male || []
    : townFirstNamePools.male || townFirstNamePools.neutral || [];
  const firstName = pickRandomFrom(
    firstNamePool && firstNamePool.length > 0 ? firstNamePool : fallbackPool,
    randomFn
  ) || (isSnowVillage ? 'Siku' : 'Aldric');
  const familyNamePool = isSnowVillage ? snowVillageClanNames : townProminentFamilyNames;
  const defaultFamilyName = isSnowVillage ? 'Qimmiq' : 'Ambermere';
  const familyName = pickRandomFrom(familyNamePool, randomFn) || defaultFamilyName;
  const rulerTitle = isSnowVillage
    ? (pickRandomFrom(
        ((gender === 'male' && snowVillageRulerTitles.male) ||
          (gender === 'female' && snowVillageRulerTitles.female) ||
          snowVillageRulerTitles.neutral) ||
          snowVillageRulerTitles.neutral,
        randomFn
      ) || 'Isumataq')
    : resolveTownRulerTitle(gender, randomFn);
  const hallmark = pickRandomFrom(townHallmarks, randomFn) || 'Bustling markets draw traders from afar.';
  const foundedYearsAgo = Math.max(12, Math.floor(30 + randomFn() * 420));
  const prominentGroupLabel = isSnowVillage ? 'Prominent Clan' : 'Prominent House';
  const prominentFamily = pickRandomFrom(familyNamePool, randomFn) || familyName;
  const prominentGroup = isSnowVillage ? `${prominentFamily} Clan` : `House ${prominentFamily}`;
  let majorGuilds = [];
  if (classification !== 'Village') {
    const majorGuildCount = clamp(Math.floor(1 + randomFn() * 3), 1, townGuildOptions.length);
    majorGuilds = pickUniqueFrom(townGuildOptions, majorGuildCount, randomFn);
  }
  const majorExportCount = clamp(Math.floor(1 + randomFn() * 3), 1, townExportOptions.length);
  const majorExports = pickUniqueFrom(townExportOptions, majorExportCount, randomFn);
  const populationBreakdown = generateTownPopulationBreakdown(population, randomFn);

  if (classification === 'Village' && Array.isArray(populationBreakdown) && populationBreakdown.length > 0) {
    const gnomeIndex = populationBreakdown.findIndex((entry) => entry && entry.key === 'gnomes');
    const majorityEntry = populationBreakdown[0];
    if (gnomeIndex >= 0 && gnomeIndex !== 0 && majorityEntry) {
      const gnomeEntry = populationBreakdown[gnomeIndex];
      const villageGnomeCap = 6;
      const adjustedGnomeShare = Math.max(
        0,
        Math.min(villageGnomeCap, Number.isFinite(gnomeEntry.percentage) ? gnomeEntry.percentage : 0)
      );
      const resolvedPopulation = Number.isFinite(population) ? Math.max(0, Math.round(population)) : null;
      if (adjustedGnomeShare < (Number.isFinite(gnomeEntry.percentage) ? gnomeEntry.percentage : 0)) {
        const shareDelta = (gnomeEntry.percentage || 0) - adjustedGnomeShare;
        gnomeEntry.percentage = adjustedGnomeShare;
        if (resolvedPopulation !== null) {
          gnomeEntry.population = Math.max(0, Math.round((resolvedPopulation * adjustedGnomeShare) / 100));
        }

        const majorityShare = Number.isFinite(majorityEntry.percentage) ? majorityEntry.percentage : 0;
        const adjustedMajorityShare = clamp(majorityShare + shareDelta, 0, 100);
        majorityEntry.percentage = adjustedMajorityShare;
        if (resolvedPopulation !== null) {
          majorityEntry.population = Math.max(0, Math.round((resolvedPopulation * adjustedMajorityShare) / 100));
        }
      }
    }
  }
  const populationDescriptor = 'residents';

  return {
    type,
    classification,
    name,
    population,
    populationLabel: 'Population',
    populationDescriptor,
    isSettlement: true,
    ruler: {
      title: rulerTitle,
      name: `${firstName} ${familyName}`
    },
    foundedYearsAgo,
    prominentGroup,
    prominentGroupLabel,
    hallmark,
    majorGuilds,
    majorExports,
    populationBreakdown
  };
}

function generateHamletDetails(name, random, options = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const isSnowHamlet = Boolean(options.snowHamlet);
  const baseDetails = generateTownDetails(name, randomFn, { snowVillage: isSnowHamlet });
  const population = isSnowHamlet
    ? Math.max(18, Math.floor(24 + randomFn() * 60))
    : Math.max(22, Math.floor(28 + randomFn() * 140));
  const hallmark = pickRandomFrom(townHallmarks, randomFn) || baseDetails.hallmark;
  const exportCount = clamp(Math.floor(randomFn() * 2) + 1, 1, townExportOptions.length);
  const majorExports = pickUniqueFrom(townExportOptions, exportCount, randomFn);
  const resolvedPopulation = Number.isFinite(population) ? Math.max(0, Math.round(population)) : null;
  let populationBreakdown = baseDetails.populationBreakdown;
  if (isSnowHamlet) {
    const humanEntry = Array.isArray(baseDetails.populationBreakdown)
      ? baseDetails.populationBreakdown.find((entry) => entry && entry.key === 'humans')
      : null;
    const humanLabel = (humanEntry && humanEntry.label) || 'Humans';
    const humanColor = (humanEntry && humanEntry.color) || '#9bb6d8';
    populationBreakdown = [
      {
        key: 'humans',
        label: humanLabel,
        color: humanColor,
        percentage: 100,
        population: resolvedPopulation
      }
    ];
  }
  return {
    ...baseDetails,
    type: 'village',
    classification: 'Village',
    population,
    populationDescriptor: 'residents',
    majorGuilds: [],
    majorExports,
    hallmark,
    populationBreakdown
  };
}

function generateGoblinCaveName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const prefix = pickRandomFrom(goblinCaveNamePrefixes, randomFn) || 'Murkfang';
  const suffix = pickRandomFrom(goblinCaveNameSuffixes, randomFn) || 'Warrens';
  const styleRoll = randomFn();
  if (styleRoll < 0.4) {
    return `${prefix} ${suffix}`;
  }
  if (styleRoll < 0.75) {
    return `${prefix}'s ${suffix}`;
  }
  return `${suffix} of ${prefix}`;
}

function generateCaveDetails(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const name = generateGoblinCaveName(randomFn);
  const population = Math.max(28, Math.floor(40 + randomFn() * 180));
  const hallmark = pickRandomFrom(goblinCaveHallmarks, randomFn) ||
    'Warrens rattle with drums and warning chimes.';
  const activity = pickRandomFrom(goblinCaveActivities, randomFn);
  const clanName = pickRandomFrom(goblinClanNames, randomFn) || 'Murkmaw Mob';
  const descriptionParts = [`${clanName} ${activity ? `are ${activity}` : 'scheme in the shadowed tunnels'}.`];
  if (hallmark) {
    descriptionParts.push(hallmark);
  }
  const description = descriptionParts.join(' ');
  const resolvedPopulation = Number.isFinite(population) ? Math.max(0, Math.round(population)) : null;
  const populationBreakdown = [
    {
      key: 'goblins',
      label: 'Goblins',
      color: '#7f8c4d',
      percentage: 100,
      population: resolvedPopulation
    }
  ];

  return {
    type: 'cave',
    classification: 'Goblin Warrens',
    displayType: 'Goblin Warrens',
    name,
    population: resolvedPopulation,
    populationLabel: 'Population',
    populationDescriptor: 'residents',
    isSettlement: true,
    prominentGroup: clanName,
    prominentGroupLabel: 'Dominant Clan',
    hallmark,
    description,
    populationBreakdown
  };
}

function generateEvilWizardName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const givenName = pickRandomFrom(evilWizardGivenNames, randomFn) || 'Malachar';
  const surnameRoll = randomFn();
  let name = givenName;
  if (surnameRoll < 0.55) {
    const surname = pickRandomFrom(evilWizardSurnames, randomFn);
    if (surname) {
      name = `${givenName} ${surname}`;
    }
  }
  const epithet = pickRandomFrom(evilWizardEpithets, randomFn);
  if (epithet && randomFn() < 0.8) {
    const baseName = name || givenName;
    name = `${baseName} ${epithet}`;
  }
  return name;
}

function generateTowerName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const prefix = pickRandomFrom(towerNamePrefixes, randomFn) || 'Obsidian';
  const noun = pickRandomFrom(towerNameNouns, randomFn) || 'Tower';
  const qualifier = pickRandomFrom(towerNameQualifiers, randomFn);
  const styleRoll = randomFn();
  if (styleRoll < 0.35 && qualifier) {
    return `${prefix} ${noun} ${qualifier}`;
  }
  if (styleRoll < 0.65) {
    return `${prefix} ${noun}`;
  }
  if (qualifier) {
    return `Tower ${qualifier}`;
  }
  return `${prefix} ${noun}`;
}

function generateTowerDetails(name, random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const population = Math.max(24, Math.floor(60 + randomFn() * 360));
  let classification = 'Watchtower';
  if (population >= 320) {
    classification = 'Border Fortress';
  } else if (population >= 240) {
    classification = 'Signal Bastion';
  } else if (population >= 160) {
    classification = 'Garrison Keep';
  } else if (population >= 100) {
    classification = 'Beacon Tower';
  }

  const commanderTitle = pickRandomFrom(towerCommanderTitles, randomFn) || 'Castellan';
  const firstName = pickRandomFrom(towerCommanderGivenNames, randomFn) || 'Aldren';
  const surname = pickRandomFrom(towerCommanderSurnames, randomFn) || 'Stonewatch';
  const commanderName = `${firstName} ${surname}`;
  const foundedYearsAgo = Math.max(6, Math.floor(14 + randomFn() * 220));
  const prominentGroup = pickRandomFrom(towerOrderNames, randomFn) || 'Order of the Dawnwatch';
  const hallmark = pickRandomFrom(towerHallmarks, randomFn) ||
    'Maintains vigilant watch over the frontier beacons.';
  const detachmentCount = clamp(Math.floor(1 + randomFn() * 3), 1, towerDetachmentOptions.length);
  const detachments = pickUniqueFrom(towerDetachmentOptions, detachmentCount, randomFn);
  const dutyCount = clamp(Math.floor(1 + randomFn() * 2), 1, towerDutyOptions.length);
  const duties = pickUniqueFrom(towerDutyOptions, dutyCount, randomFn);
  const populationBreakdown = generateTowerPopulationBreakdown(population, randomFn);

  return {
    type: 'tower',
    classification,
    name,
    population,
    populationLabel: 'Garrison Strength',
    populationDescriptor: 'residents',
    isSettlement: true,
    ruler: {
      title: commanderTitle,
      name: commanderName
    },
    foundedYearsAgo,
    prominentGroup,
    prominentGroupLabel: 'Garrison Order',
    hallmark,
    hallmarkLabel: 'Renowned For',
    majorGuilds: detachments,
    majorGuildsLabel: 'Special Detachments',
    majorExports: duties,
    majorExportsLabel: 'Primary Duties',
    populationBreakdown
  };
}

function generateWoodElfGroveName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const prefix = pickRandomFrom(woodElfGrovePrefixes, randomFn) || 'Sylvan';
  const suffix = pickRandomFrom(woodElfGroveSuffixes, randomFn) || 'Grove';
  const baseName = `${prefix} ${suffix}`;
  const descriptor = pickRandomFrom(woodElfGroveDescriptors, randomFn);
  if (descriptor && randomFn() < 0.65) {
    return `${baseName} ${descriptor}`;
  }
  return baseName;
}

function generateWoodElfGroveDetails(name, random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const population = Math.max(60, Math.floor(140 + randomFn() * 420));
  let classification = 'Forest Retreat';
  if (population >= 500) {
    classification = 'Ancient Grove';
  } else if (population >= 360) {
    classification = 'Sacred Grove';
  } else if (population >= 240) {
    classification = 'Hidden Enclave';
  } else if (population >= 180) {
    classification = 'Canopy Sanctuary';
  }

  const populationMax = woodElfGroveClassificationPopulationMax[classification] || 560;

  const populationDescriptor = 'residents';

  const elderTitle = pickRandomFrom(woodElfGroveElderTitles, randomFn) || 'Grove Warden';
  const givenName = pickRandomFrom(woodElfGroveElderGivenNames, randomFn) || 'Aelar';
  const surname = pickRandomFrom(woodElfGroveElderSurnames, randomFn) || 'Silversong';
  const hallmark = pickRandomFrom(woodElfGroveHallmarks, randomFn) ||
    'Moonlit rites that weave auroras between the branches.';
  const foundedYearsAgo = Math.max(40, Math.floor(120 + randomFn() * 520));
  const prominentGroup = pickRandomFrom(woodElfGroveCircleNames, randomFn) || 'Circle of the Silver Bough';
  const majorGuildCount = clamp(Math.floor(1 + randomFn() * 2), 1, woodElfGroveOrders.length);
  const majorGuilds = pickUniqueFrom(woodElfGroveOrders, majorGuildCount, randomFn);
  const majorExportCount = clamp(Math.floor(1 + randomFn() * 2), 1, woodElfGroveExports.length);
  const majorExports = pickUniqueFrom(woodElfGroveExports, majorExportCount, randomFn);
  const populationBreakdown = generateWoodElfGrovePopulationBreakdown(population, randomFn);

  return {
    type: 'woodElfGrove',
    classification,
    name,
    population,
    populationMax,
    populationLabel: 'Population',
    populationDescriptor,
    isSettlement: true,
    ruler: {
      title: elderTitle,
      name: `${givenName} ${surname}`
    },
    foundedYearsAgo,
    prominentGroup,
    prominentGroupLabel: 'Circle in Residence',
    hallmark,
    hallmarkLabel: 'Revered For',
    majorGuilds,
    majorGuildsLabel: 'Sacred Orders',
    majorExports,
    majorExportsLabel: 'Seasonal Offerings',
    populationBreakdown
  };
}

function generateLizardmenCityName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const prefix = pickRandomFrom(lizardmenCityPrefixes, randomFn) || 'Ix';
  const suffix = pickRandomFrom(lizardmenCitySuffixes, randomFn) || 'tlan';
  const extraSuffix = randomFn() < 0.25 ? pickRandomFrom(lizardmenCitySuffixes, randomFn) : '';
  const separatorRoll = randomFn();
  let separator = '';
  if (separatorRoll < 0.35) {
    separator = "'";
  } else if (separatorRoll < 0.45) {
    separator = '-';
  }
  const baseName = `${prefix}${separator}${suffix}${extraSuffix}`;
  return baseName;
}

function generateLizardmenCityDetails(name, random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const population = Math.max(400, Math.floor(2600 + randomFn() * 3200));
  const classification = pickRandomFrom(lizardmenCityClassifications, randomFn) || 'Temple City';
  const hallmark =
    pickRandomFrom(lizardmenCityHallmarks, randomFn) || 'Sun-drenched step pyramids rising above the canopy.';
  const rulerTitle = pickRandomFrom(lizardmenCityRulerTitles, randomFn) || 'High Scale-Priest';
  const rulerName = pickRandomFrom(lizardmenCityRulerNames, randomFn) || 'Xilqua';
  const rulerLabel = randomFn() < 0.5 ? 'Supreme Voice' : 'Sacred Regent';
  const foundedYearsAgo = Math.max(80, Math.floor(140 + randomFn() * 460));
  const majorGuildCount = clamp(Math.floor(1 + randomFn() * 2), 1, lizardmenCityOrders.length);
  const majorGuilds = pickUniqueFrom(lizardmenCityOrders, majorGuildCount, randomFn);
  const majorExportCount = clamp(Math.floor(1 + randomFn() * 2), 1, lizardmenCityExports.length);
  const majorExports = pickUniqueFrom(lizardmenCityExports, majorExportCount, randomFn);
  const prominentGroup =
    majorGuilds.length > 0
      ? pickRandomFrom(majorGuilds, randomFn)
      : pickRandomFrom(lizardmenCityOrders, randomFn) || 'Sunblood Procession';
  const populationBreakdown = generateLizardmenCityPopulationBreakdown(population, randomFn);

  return {
    type: 'lizardmenCity',
    classification,
    name,
    population,
    populationLabel: 'Population',
    populationDescriptor: 'residents',
    isSettlement: true,
    ruler: {
      title: rulerTitle,
      name: rulerName,
      label: rulerLabel
    },
    foundedYearsAgo,
    prominentGroup,
    prominentGroupLabel: 'Sacred Order',
    hallmark,
    hallmarkLabel: 'Revered For',
    majorGuilds,
    majorGuildsLabel: 'Temple Orders',
    majorExports,
    majorExportsLabel: 'Tributes & Trade',
    populationBreakdown
  };
}

function generateOrcCampName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(orcTribeAdjectives, randomFn) || 'Ironjaw';
  const noun = pickRandomFrom(orcTribeNouns, randomFn) || 'Clan';
  const style = randomFn();
  if (style < 0.35) {
    return `${adjective} ${noun} Camp`;
  }
  if (style < 0.7) {
    return `${adjective} ${noun} Warcamp`;
  }
  return `Camp of the ${adjective} ${noun}`;
}

function generateOrcCampDetails(name, random, options = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(orcTribeAdjectives, randomFn) || 'Ironjaw';
  const noun = pickRandomFrom(orcTribeNouns, randomFn) || 'Clan';
  const tribeName = `${adjective} ${noun}`;
  const warLeader = pickRandomFrom(orcWarLeaders, randomFn) || 'Gorath the Red';
  const feature = pickRandomFrom(orcCampFeatures, randomFn) ||
    'War drums thunder at dusk from within the palisade.';
  const threatLevel = pickRandomFrom(orcThreatDescriptors, randomFn) || 'Severe';
  const raidingFocus = pickRandomFrom(
    ['plundered caravans', 'frontier villages', 'wandering merchants', 'remote farmsteads'],
    randomFn
  );
  const terrain = typeof options.terrain === 'string' && options.terrain.trim()
    ? options.terrain.trim()
    : null;
  const targetHint = typeof options.targetHint === 'string' && options.targetHint.trim()
    ? options.targetHint.trim()
    : null;
  const descriptionParts = [
    `${tribeName} raiders gather here, their sights set on ${targetHint || raidingFocus || 'nearby lands'}.`,
    terrain ? `Scouts prowl ${terrain}, seeking weaknesses in distant defenses.` : null,
    feature
  ].filter(Boolean);

  return {
    type: 'orcCamp',
    name,
    displayType: 'Orc War Camp',
    tribe: tribeName,
    warLeader,
    threatLevel,
    inhabitants: `${tribeName} warriors`,
    description: descriptionParts.join(' '),
    banner: pickRandomFrom(orcTribeAdjectives, randomFn) || 'Rageborn',
    vow: 'Blood Oaths'
  };
}

function generateGnollCampName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(gnollPackAdjectives, randomFn) || 'Dustmane';
  const noun = pickRandomFrom(gnollPackNouns, randomFn) || 'Pack';
  const style = randomFn();
  if (style < 0.33) {
    return `${adjective} ${noun} Den`;
  }
  if (style < 0.66) {
    return `${adjective} ${noun} War-Pack`;
  }
  return `Den of the ${adjective} ${noun}`;
}

function generateGnollCampDetails(name, random, options = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(gnollPackAdjectives, randomFn) || 'Dustmane';
  const noun = pickRandomFrom(gnollPackNouns, randomFn) || 'Pack';
  const packName = `${adjective} ${noun}`;
  const warLeader = pickRandomFrom(gnollWarLeaders, randomFn) || 'Szimri Bone-Eater';
  const feature = pickRandomFrom(gnollCampFeatures, randomFn) ||
    'Hyena laughter ripples through the night around bone-festooned totems.';
  const threatLevel = pickRandomFrom(gnollThreatDescriptors, randomFn) || 'Severe';
  const target = options.targetHint ||
    pickRandomFrom(
      ['desert caravans', 'scattered ranches', 'frontier watchposts', 'pilgrim trains'],
      randomFn
    ) ||
    'border caravans';
  const terrain = typeof options.terrain === 'string' && options.terrain.trim()
    ? options.terrain.trim()
    : 'the open steppe';
  const descriptionParts = [
    `${packName} raiders circle ${terrain}, drawn by ${target}.`,
    feature
  ].filter(Boolean);

  return {
    type: 'gnollCamp',
    name,
    displayType: 'Gnoll War Pack',
    classification: 'Beastman Encampment',
    tribe: `${packName} pack`,
    warLeader,
    threatLevel,
    inhabitants: `${packName} scavengers`,
    description: descriptionParts.join(' '),
    banner: pickRandomFrom(
      ['Bone Fetish', 'Hyena Mane', 'Sun-Torn Hide', 'Fetid Standard'],
      randomFn
    ) || 'Bone Fetish',
    vow: 'Pack Howls'
  };
}

function generateTrollCampName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(trollDenAdjectives, randomFn) || 'Bog';
  const noun = pickRandomFrom(trollDenNouns, randomFn) || 'Den';
  const style = randomFn();
  if (style < 0.33) {
    return `${adjective} ${noun}`;
  }
  if (style < 0.66) {
    return `${adjective} ${noun} Brood`;
  }
  return `${noun} of the ${adjective} Tides`;
}

function generateTrollCampDetails(name, random, options = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(trollDenAdjectives, randomFn) || 'Bog';
  const noun = pickRandomFrom(trollDenNouns, randomFn) || 'Den';
  const broodName = `${adjective} ${noun}`;
  const warLeader = pickRandomFrom(trollWarLeaders, randomFn) || 'Gorvul the Regrown';
  const feature = pickRandomFrom(trollCampFeatures, randomFn) ||
    'Sodden logs reinforce earthen berms slick with algae.';
  const threatLevel = pickRandomFrom(trollThreatDescriptors, randomFn) || 'Dire';
  const target = options.targetHint ||
    pickRandomFrom(
      ['river barges', 'marsh villages', 'lonely ferries', 'border forts'],
      randomFn
    ) ||
    'river barges';
  const terrain = typeof options.terrain === 'string' && options.terrain.trim()
    ? options.terrain.trim()
    : 'the dripping marshlands';
  const descriptionParts = [
    `${broodName} brutes keep watch over ${terrain}, hungry for ${target}.`,
    feature
  ].filter(Boolean);

  return {
    type: 'trollCamp',
    name,
    displayType: 'Troll Den',
    classification: 'Monstrous Encampment',
    tribe: `${broodName} brood`,
    warLeader,
    threatLevel,
    inhabitants: `${broodName} trolls`,
    description: descriptionParts.join(' '),
    banner: pickRandomFrom(
      ['Bog Totem', 'Stone Fetish', 'Riverbone Mark', 'Rotbrand'],
      randomFn
    ) || 'Bog Totem',
    vow: 'Regrowth Rites'
  };
}

function generateOgreCampName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(ogreClanAdjectives, randomFn) || 'Crushjaw';
  const noun = pickRandomFrom(ogreClanNouns, randomFn) || 'Clan';
  const style = randomFn();
  if (style < 0.33) {
    return `${adjective} ${noun} Muster`;
  }
  if (style < 0.66) {
    return `${adjective} ${noun} Camp`;
  }
  return `Stronghold of the ${adjective} ${noun}`;
}

function generateOgreCampDetails(name, random, options = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(ogreClanAdjectives, randomFn) || 'Crushjaw';
  const noun = pickRandomFrom(ogreClanNouns, randomFn) || 'Clan';
  const clanName = `${adjective} ${noun}`;
  const warLeader = pickRandomFrom(ogreWarLeaders, randomFn) || 'Grunak Boulderborn';
  const feature = pickRandomFrom(ogreCampFeatures, randomFn) ||
    'Enormous clubs lean against boulders beside shattered siege engines.';
  const threatLevel = pickRandomFrom(ogreThreatDescriptors, randomFn) || 'Dire';
  const target = options.targetHint ||
    pickRandomFrom(
      ['fortified keeps', 'hill villages', 'border caravans', 'stone bridges'],
      randomFn
    ) ||
    'fortified keeps';
  const terrain = typeof options.terrain === 'string' && options.terrain.trim()
    ? options.terrain.trim()
    : 'the broken uplands';
  const descriptionParts = [
    `${clanName} giants muster amid ${terrain}, plotting to smash ${target}.`,
    feature
  ].filter(Boolean);

  return {
    type: 'ogreCamp',
    name,
    displayType: 'Ogre War Camp',
    classification: 'Giantkin Muster',
    tribe: `${clanName} brutes`,
    warLeader,
    threatLevel,
    inhabitants: `${clanName} ogres`,
    description: descriptionParts.join(' '),
    banner: pickRandomFrom(
      ['Skull Brand', 'Hammer Sigil', 'Grudge Banner', 'Cracked Boulder'],
      randomFn
    ) || 'Skull Brand',
    vow: 'Feast Oaths'
  };
}

function generateBanditCampName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(banditCrewAdjectives, randomFn) || 'Red';
  const noun = pickRandomFrom(banditCrewNouns, randomFn) || 'Knives';
  const style = randomFn();
  if (style < 0.33) {
    return `${adjective} ${noun} Hideout`;
  }
  if (style < 0.66) {
    return `${adjective} ${noun} Camp`;
  }
  return `Hideout of the ${adjective} ${noun}`;
}

function generateBanditCampDetails(name, random, options = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(banditCrewAdjectives, randomFn) || 'Red';
  const noun = pickRandomFrom(banditCrewNouns, randomFn) || 'Knives';
  const crewName = `${adjective} ${noun}`;
  const warLeader = pickRandomFrom(banditLeaders, randomFn) || 'Captain Rysa Blackflint';
  const feature = pickRandomFrom(banditCampFeatures, randomFn) ||
    'Lookouts with hooded lanterns signal across hidden paths.';
  const threatLevel = pickRandomFrom(banditThreatDescriptors, randomFn) || 'Perilous';
  const specialty = pickRandomFrom(banditSpecialties, randomFn) ||
    'ambushing caravans that brave the frontier passes';
  const terrain = typeof options.terrain === 'string' && options.terrain.trim()
    ? options.terrain.trim()
    : 'the border wilds';
  const settlementDistance = Number.isFinite(options.settlementDistance)
    ? Math.max(1, Math.round(options.settlementDistance))
    : null;
  const descriptionParts = [
    `${crewName} outlaws keep this hideout, plotting to ${specialty}.`,
    `They melt into ${terrain} when the crown's riders draw near.`,
    feature,
    settlementDistance
      ? `Scouts report that lawful patrols pass barely ${settlementDistance} leagues away.`
      : null
  ].filter(Boolean);

  return {
    type: 'banditCamp',
    name,
    displayType: 'Bandit Encampment',
    classification: 'Outlaw Hideout',
    tribe: `${crewName} crew`,
    warLeader,
    threatLevel,
    inhabitants: `${crewName} cutthroats`,
    description: descriptionParts.join(' '),
    banner: pickRandomFrom(
      ['Tattered Standard', 'Broken Wheel', 'Smoked Lantern', 'Rust Banner'],
      randomFn
    ) || 'Tattered Standard',
    vow: 'Silent Concord'
  };
}

const warCampNameGenerators = {
  orcCamp: generateOrcCampName,
  gnollCamp: generateGnollCampName,
  trollCamp: generateTrollCampName,
  ogreCamp: generateOgreCampName,
  banditCamp: generateBanditCampName
};

const warCampDetailGenerators = {
  orcCamp: generateOrcCampDetails,
  gnollCamp: generateGnollCampDetails,
  trollCamp: generateTrollCampDetails,
  ogreCamp: generateOgreCampDetails,
  banditCamp: generateBanditCampDetails
};

function generateWarCampForType(type, random, options = {}) {
  const generator = warCampNameGenerators[type] || generateOrcCampName;
  const detailGenerator = warCampDetailGenerators[type] || generateOrcCampDetails;
  const name = generator(random);
  const details = detailGenerator(name, random, options);
  return { name, details };
}

function resolveWarCampTerrainDescriptor(candidate) {
  if (!candidate) {
    return 'the untamed frontier';
  }
  if (candidate.isMarsh) {
    return 'the reed-choked wetlands';
  }
  if (candidate.isSand) {
    return 'the wind-scoured dunes';
  }
  if (candidate.isBadlands) {
    return 'the jagged badlands';
  }
  if (candidate.isSnow) {
    return 'the frozen marches';
  }
  if (candidate.hill) {
    return 'the rough hill country';
  }
  if ((candidate.waterAdjacency || 0) >= 2) {
    return 'the river-cut lowlands';
  }
  const dryness = clamp(Number(candidate.dryness) || 0, 0, 1);
  if (dryness >= 0.68) {
    return 'the sunbaked plains';
  }
  if (dryness <= 0.32) {
    return 'the green border meadows';
  }
  return 'the untamed frontier';
}

function resolveWarCampTargetHint(candidate) {
  const distance = Number(candidate?.settlementDistance);
  if (!Number.isFinite(distance)) {
    return null;
  }
  if (distance <= 6) {
    return 'nearby settlements';
  }
  if (distance <= 12) {
    return 'lightly guarded caravans';
  }
  if (distance <= 20) {
    return 'remote patrols';
  }
  return null;
}

function selectWarCampType(randomFn, candidate, availableTypes) {
  if (!Array.isArray(availableTypes) || availableTypes.length === 0) {
    return 'orcCamp';
  }
  if (availableTypes.length === 1) {
    return availableTypes[0];
  }
  const dryness = clamp(Number(candidate?.dryness) || 0, 0, 1);
  const waterAdjacency = Math.max(0, Number(candidate?.waterAdjacency) || 0);
  const settlementDistance = Number(candidate?.settlementDistance);
  const weights = availableTypes.map((type) => {
    let weight = warCampTypeBaseWeights[type] || 1;
    switch (type) {
      case 'orcCamp':
        if (candidate?.isBadlands) {
          weight += 0.6;
        }
        if (candidate?.isSand) {
          weight += 0.4;
        }
        break;
      case 'gnollCamp':
        weight += dryness * 0.6;
        if (candidate?.isSand) {
          weight += 0.5;
        }
        break;
      case 'trollCamp':
        if (candidate?.isMarsh) {
          weight += 0.7;
        }
        weight += Math.min(waterAdjacency * 0.25, 0.75);
        if (candidate?.isSnow) {
          weight -= 0.3;
        }
        break;
      case 'ogreCamp':
        if (candidate?.hill) {
          weight += 0.8;
        }
        if (candidate?.isBadlands) {
          weight += 0.2;
        }
        break;
      case 'banditCamp':
        if (candidate?.isGrass) {
          weight += 0.25;
        }
        if (Number.isFinite(settlementDistance)) {
          const closeness = clamp(1 - Math.abs(settlementDistance - 9) / 9, 0, 1);
          weight += closeness * 0.8;
        }
        break;
      default:
        break;
    }
    return Math.max(0.01, weight);
  });
  const total = weights.reduce((sum, weight) => sum + weight, 0);
  if (total <= 0) {
    return availableTypes[0];
  }
  let roll = randomFn() * total;
  for (let i = 0; i < availableTypes.length; i += 1) {
    roll -= weights[i];
    if (roll <= 0) {
      return availableTypes[i];
    }
  }
  return availableTypes[availableTypes.length - 1];
}

function generateCentaurEncampmentName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(centaurHerdAdjectives, randomFn) || 'Swiftwind';
  const noun = pickRandomFrom(centaurHerdNouns, randomFn) || 'Herd';
  const style = randomFn();
  if (style < 0.34) {
    return `${adjective} ${noun} Encampment`;
  }
  if (style < 0.68) {
    return `${noun} of the ${adjective} Plains`;
  }
  return `${adjective} ${noun} Moot`;
}

function generateCentaurEncampmentDetails(name, random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const herdAdjective = pickRandomFrom(centaurHerdAdjectives, randomFn) || 'Swiftwind';
  const herdNoun = pickRandomFrom(centaurHerdNouns, randomFn) || 'Herd';
  const herdName = `${herdAdjective} ${herdNoun}`;
  const leaderTitle = pickRandomFrom(centaurLeaderTitles, randomFn) || 'Herdspeaker';
  const leaderName = pickRandomFrom(centaurLeaderNames, randomFn) || 'Thandros';
  const focus = pickRandomFrom(centaurEncampmentPurposes, randomFn) || 'keeps vigil over the border trails';
  const feature = pickRandomFrom(centaurEncampmentFeatures, randomFn) ||
    'Hoofbeat drums echo across a packed-earth arena.';
  const vow = pickRandomFrom(centaurSacredVows, randomFn) || 'Sky Oaths';
  const prominentClan = pickRandomFrom(centaurMajorClans, randomFn) || 'Sunmane Banner';
  const clanCount = clamp(Math.floor(1 + randomFn() * 2), 1, centaurMajorClans.length);
  const majorClans = pickUniqueFrom(centaurMajorClans, clanCount, randomFn);
  const herdSize = Math.max(80, Math.round(160 + randomFn() * 220));

  return {
    type: 'centaurEncampment',
    name,
    displayType: 'Centaur Encampment',
    classification: 'Nomadic Moot',
    population: herdSize,
    populationLabel: 'Herd Strength',
    populationDescriptor: 'hooves in the herd',
    tribe: herdName,
    ruler: {
      title: leaderTitle,
      name: leaderName,
      label: 'Herdspeaker'
    },
    vow,
    prominentClan,
    prominentClanLabel: 'Champion Banner',
    majorClans,
    majorClansLabel: 'Banners Present',
    inhabitants: `${herdName} riders`,
    description: `The ${herdName} ${focus}. ${feature}`
  };
}

function generateTravelerCampName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjectives = ['Lantern', 'Amber', 'Star', 'Frontier', 'Drift', 'Iron', 'Wayfarer', 'Cedar'];
  const landmarks = ['Crossing', 'Hollow', 'Trail', 'Fork', 'Pass', 'Fields', 'Meadow'];
  const nouns = ['Camp', 'Encampment', 'Outpost', 'Commons', 'Waystation'];
  const adjective = pickRandomFrom(adjectives, randomFn) || 'Lantern';
  const noun = pickRandomFrom(nouns, randomFn) || 'Camp';
  const landmark = pickRandomFrom(landmarks, randomFn);
  const style = randomFn();
  if (style < 0.35 && landmark) {
    return `${adjective} ${landmark} ${noun}`;
  }
  if (style < 0.7) {
    return `${adjective} ${noun}`;
  }
  return `${noun} of the ${adjective} Road`;
}

function formatSettlementLabelForDetails(settlement) {
  if (!settlement) {
    return null;
  }
  if (typeof settlement.name === 'string' && settlement.name) {
    return settlement.name;
  }
  if (typeof settlement.structureName === 'string' && settlement.structureName) {
    return settlement.structureName;
  }
  if (typeof settlement.displayType === 'string' && settlement.displayType) {
    return settlement.displayType;
  }
  if (typeof settlement.type === 'string' && settlement.type) {
    return formatStructureDetailLabel(settlement.type);
  }
  return null;
}

function generateTravelerCampDetails(name, random, options = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const host = pickRandomFrom(travelerCampHosts, randomFn) || 'the Emberlane siblings';
  const focus = pickRandomFrom(travelerCampFocuses, randomFn) || 'guiding caravans through the border wilds';
  const supplies = pickRandomFrom(travelerCampSupplies, randomFn) ||
    'fresh water skins, smoked meats, and wagon grease';
  const atmosphere = pickRandomFrom(travelerCampAtmospheres, randomFn) ||
    'Lanterns sway from tall poles, casting amber halos across the tents.';
  const service = pickRandomFrom(travelerCampServices, randomFn) || 'fresh mounts for weary outriders';
  const settlementLabel = formatSettlementLabelForDetails(options?.nearbySettlement);
  const settlementDistance = Number.isFinite(options?.settlementDistance)
    ? Math.max(1, Math.round(options.settlementDistance))
    : null;
  const settlementSentence = settlementLabel
    ? `Caravans from ${settlementLabel} often rest here${
        settlementDistance ? ` after ${settlementDistance} leagues on the road` : ''
      }.`
    : 'Wayfarers raise their tents where trade paths converge.';

  return {
    type: 'travelerCamp',
    name,
    displayType: 'Frontier Camp',
    hosts: host.charAt(0).toUpperCase() + host.slice(1),
    campFocus: focus.charAt(0).toUpperCase() + focus.slice(1),
    supplies: supplies.charAt(0).toUpperCase() + supplies.slice(1),
    services: service.charAt(0).toUpperCase() + service.slice(1),
    description: `${settlementSentence} ${atmosphere}`
  };
}

function generateRoadsideTavernName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const adjective = pickRandomFrom(tavernAdjectives, randomFn) || 'Golden';
  const noun = pickRandomFrom(tavernNouns, randomFn) || 'Hearth';
  const descriptor = pickRandomFrom(tavernDescriptors, randomFn) || 'Roadhouse';
  const style = randomFn();
  if (style < 0.45) {
    return `The ${adjective} ${noun}`;
  }
  if (style < 0.75) {
    return `${adjective} ${noun} ${descriptor}`;
  }
  return `${descriptor} of the ${adjective} ${noun}`;
}

function generateRoadsideTavernDetails(name, random, options = {}) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const innkeeper = pickRandomFrom(tavernInnkeepers, randomFn) || 'Innkeep Mara Hearthspoon';
  const specialty = pickRandomFrom(tavernSpecialties, randomFn) || 'cinder-spiced stout poured over hot stones';
  const reputation = pickRandomFrom(tavernReputations, randomFn) || 'favoured by caravan guards trading tall tales';
  const amenities = pickRandomFrom(tavernAmenities, randomFn) || 'a roaring hearth and slate-tiled baths';
  const service = pickRandomFrom(tavernServices, randomFn) || 'guides charting quick routes between duchies';
  const rate = pickRandomFrom(tavernRatePhrases, randomFn) || 'two silver a night, breakfast and stall included';
  const notableGuests = pickRandomFrom(tavernSpecialGuests, randomFn) || 'wandering magi swapping spellcraft rumours';
  const rooms = Math.max(6, Math.floor(8 + randomFn() * 6));
  const settlementLabel = formatSettlementLabelForDetails(options?.nearbySettlement);
  const settlementDistance = Number.isFinite(options?.settlementDistance)
    ? Math.max(1, Math.round(options.settlementDistance))
    : null;
  const atmosphere = pickRandomFrom(tavernAtmospheres, randomFn) ||
    'Lantern light spills across wagon ruts like melted gold.';
  const settlementSentence = settlementLabel
    ? `Caravans bound for ${settlementLabel} pause here${
        settlementDistance ? ` after ${settlementDistance} leagues on the road` : ''
      }.`
    : 'Travellers on the long road gather here to rest and trade news.';

  return {
    type: 'roadsideTavern',
    name,
    displayType: 'Roadside Tavern',
    innkeeper,
    specialty,
    reputation,
    amenities,
    services: service,
    rooms: `${rooms} rooms prepared for weary guests`,
    rates: rate,
    notableGuests,
    description: `${settlementSentence} ${atmosphere}`
  };
}

function generateDungeonName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const prefix = pickRandomFrom(dungeonNamePrefixes, randomFn) || 'Sunken';
  const suffix = pickRandomFrom(dungeonNameSuffixes, randomFn) || 'Vault';
  const style = randomFn();
  if (style < 0.4) {
    return `${prefix} ${suffix}`;
  }
  if (style < 0.75) {
    return `${suffix} of ${prefix} Echoes`;
  }
  return `${prefix} ${suffix} of Dread`;
}

function generateDungeonDetails(name, random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const peril = pickRandomFrom(dungeonPerils, randomFn) || 'echo with restless spirits';
  const depth = pickRandomFrom(dungeonDepths, randomFn) || 'five';
  const guardian = pickRandomFrom(
    [
      'bone sentries',
      'arcane sentinels',
      'chittering horrors',
      'shadow-haunting spectres',
      'oozing slimes'
    ],
    randomFn
  ) || 'ancient wardens';

  return {
    type: 'dungeon',
    name,
    displayType: 'Ancient Dungeon',
    threatLevel: 'High',
    guardians: guardian,
    depth: `${depth} levels`,
    description: `Rumoured to ${peril}, the ${name} descends ${depth} levels where ${guardian} stalk forgotten halls.`
  };
}

function generateMonasteryName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const orderName = pickRandomFrom(monasteryOrders, randomFn) || 'Order of the Dawn Lantern';
  const virtue = pickRandomFrom(monasteryVirtues, randomFn) || 'contemplation';
  const virtueName = virtue.charAt(0).toUpperCase() + virtue.slice(1);
  if (randomFn() < 0.5) {
    const trimmedOrder = orderName.toLowerCase().includes('monastery')
      ? orderName
      : `${orderName} Monastery`;
    return trimmedOrder;
  }
  return `Monastery of ${virtueName}`;
}

function generateMonasteryDetails(name, random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const orderName = pickRandomFrom(monasteryOrders, randomFn) || 'Order of the Dawn Lantern';
  const virtue = pickRandomFrom(monasteryVirtues, randomFn) || 'contemplation';
  const virtueName = virtue.charAt(0).toUpperCase() + virtue.slice(1);
  const relic = pickRandomFrom(monasteryRelics, randomFn) || 'a saintly bell that rings without wind';
  const caretakerTitle = randomFn() < 0.5 ? 'Abbot' : 'Abbess';
  const caretakerName = pickRandomFrom(
    [...(townFirstNamePools.male || []), ...(townFirstNamePools.female || []), ...(townFirstNamePools.neutral || [])],
    randomFn
  ) || 'Seren';

  return {
    type: 'monastery',
    name,
    displayType: 'Sacred Monastery',
    order: orderName,
    devotion: `Vow of ${virtueName}`,
    caretaker: `${caretakerTitle} ${caretakerName}`,
    description: `${orderName} keep solemn watch here, dedicated to ${virtue}. Their cloisters guard ${relic}.`
  };
}

function generateCastleName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const house = pickRandomFrom(castleHouseNames, randomFn) || 'House Blackthorn';
  const base = house.replace(/^House\s+/i, '') || 'Blackthorn';
  const style = randomFn();
  if (style < 0.4) {
    return `Castle ${base}`;
  }
  if (style < 0.7) {
    return `${base} Keep`;
  }
  return `${base} Holdfast`;
}

function generateCastleDetails(name, random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const house = pickRandomFrom(castleHouseNames, randomFn) || 'House Blackthorn';
  const banner = pickRandomFrom(castleBanners, randomFn) || 'a silver gryphon on midnight blue';
  const trait = pickRandomFrom(castleDefensiveTraits, randomFn) || 'Commands a triple-ring curtain wall.';
  const garrison = Math.max(60, Math.floor(120 + randomFn() * 380));

  return {
    type: 'castle',
    name,
    displayType: 'Fortified Castle',
    rulingHouse: house,
    banner,
    garrison,
    description: `${name} stands loyal to ${house}, its banner of ${banner}. ${trait}`
  };
}

function generateSaintShrineName(random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const saint = pickRandomFrom(saintlyNames, randomFn) || 'Saint Elowen';
  if (randomFn() < 0.5) {
    return `Shrine of ${saint}`;
  }
  return `${saint}'s Shrine`;
}

function generateSaintShrineDetails(name, random) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  const saint = pickRandomFrom(saintlyNames, randomFn) || 'Saint Elowen';
  const miracle = pickRandomFrom(saintMiracles, randomFn) || 'calmed a wildfire with a whispered prayer';
  const offerings = pickRandomFrom(shrineOfferings, randomFn) || 'garlands of moonpetals';
  const pilgrims = pickRandomFrom(shrinePilgrims, randomFn) || 'penitents seeking absolution';

  return {
    type: 'saintShrine',
    name,
    displayType: 'Saintly Shrine',
    patronSaint: saint,
    devotion: `Honours the miracle that ${saint.toLowerCase().includes('saint') ? '' : 'Saint '}${saint} ${miracle}.`,
    description: `${name} marks where ${saint} ${miracle}. Pilgrims leave ${offerings}, and ${pilgrims} gather in hushed prayer.`
  };
}

function generatePoliticalLandscape({ width, height, tiles, waterMask, random, settlements }) {
  const randomFn = typeof random === 'function' ? random : Math.random;
  if (!Array.isArray(tiles) || tiles.length === 0 || width <= 0 || height <= 0) {
    return { factions: [] };
  }

  const toIndex = (x, y) => y * width + x;
  const cardinalNeighborOffsets = [
    [1, 0],
    [-1, 0],
    [0, 1],
    [0, -1]
  ];
  const surroundingNeighborOffsets = [
    [1, 0],
    [-1, 0],
    [0, 1],
    [0, -1],
    [1, 1],
    [1, -1],
    [-1, 1],
    [-1, -1]
  ];
  let hasLand = false;
  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      const tile = tiles[y] ? tiles[y][x] : null;
      if (!tile) {
        continue;
      }
      if (waterMask && waterMask[idx]) {
        tile.factionId = null;
        tile.factionInfluence = 0;
        continue;
      }
      tile.factionId = null;
      tile.factionInfluence = 0;
      hasLand = true;
    }
  }

  if (!hasLand) {
    return { factions: [] };
  }

  const settlementSeeds = Array.isArray(settlements) ? settlements : [];
  const uniqueSeeds = [];
  const seenSeeds = new Set();

  settlementSeeds.forEach((seed) => {
    if (!seed || !Number.isFinite(seed.x) || !Number.isFinite(seed.y)) {
      return;
    }
    const normalizedType = typeof seed.type === 'string' ? seed.type.trim().toLowerCase() : '';
    const normalizedKind =
      typeof seed.settlementKind === 'string' ? seed.settlementKind.trim().toLowerCase() : '';
    if (normalizedType === 'abandoneddwarfhold' || normalizedKind === 'abandoneddwarfhold') {
      return;
    }
    const seedIndex = toIndex(seed.x, seed.y);
    if (seenSeeds.has(seedIndex)) {
      return;
    }
    seenSeeds.add(seedIndex);
    uniqueSeeds.push({
      x: seed.x,
      y: seed.y,
      label: typeof seed.label === 'string' ? seed.label.trim() : '',
      type: seed.type || 'settlement',
      population: Number.isFinite(seed.population) ? seed.population : null,
      settlementKind:
        typeof seed.settlementKind === 'string' && seed.settlementKind.trim().length > 0
          ? seed.settlementKind.trim()
          : null
    });
  });

  if (uniqueSeeds.length === 0) {
    return { factions: [] };
  }

  const adjustClaimRadiusByPopulation = (seed, baseRadius) => {
    if (!seed || seed.type !== 'town') {
      return baseRadius;
    }

    const population = Number(seed.population);
    if (!Number.isFinite(population) || population <= 0) {
      return baseRadius;
    }

    const minPopulation = 120;
    const fullPopulation = 2000;
    const isVillage = seed.settlementKind === 'village';
    const minMultiplierBase = isVillage ? 0.24 : 0.4;
    const minMultiplier = clamp(minMultiplierBase, 0.1, 0.99);
    const normalized = clamp((population - minPopulation) / (fullPopulation - minPopulation), 0, 1);
    const multiplier = minMultiplier + normalized * (1 - minMultiplier);
    const scaledRadius = baseRadius * multiplier;
    let adjustedRadius = Math.max(8, scaledRadius);
    if (isVillage) {
      const maxVillageRadius = Math.max(12, baseRadius * 0.7);
      adjustedRadius = Math.min(adjustedRadius, maxVillageRadius);
    }
    return adjustedRadius;
  };

  const resolveClaimRadius = (seed) => {
    if (!seed || !seed.type) {
      return 26;
    }
    let baseRadius = 26;
    switch (seed.type) {
      case 'dwarfhold':
        baseRadius = 36;
        break;
      case 'hillhold':
        baseRadius = 30;
        break;
      case 'town':
        baseRadius = 32;
        break;
      case 'monastery':
        baseRadius = 28;
        break;
      case 'tower':
        baseRadius = 24;
        break;
      case 'evilWizardTower':
        baseRadius = 24;
        break;
      case 'woodElfGrove':
        baseRadius = 28;
        break;
      case 'lizardmenCity':
        baseRadius = 30;
        break;
      default:
        baseRadius = 26;
    }
    return adjustClaimRadiusByPopulation(seed, baseRadius);
  };

  const resolveFactionName = (seed) => {
    if (!seed) {
      return generateRealmName(randomFn);
    }
    const label = typeof seed.label === 'string' ? seed.label.trim() : '';
    if (!label) {
      return generateRealmName(randomFn);
    }
    switch (seed.type) {
      case 'dwarfhold':
        return `${label} Thanedom`;
      case 'hillhold':
        return `${label} Holdfast`;
      case 'monastery':
        return `${label} Cloister`;
      case 'woodElfGrove':
        return `${label} Canopy`;
      case 'lizardmenCity':
        return `${label} Temple-Host`;
      case 'evilWizardTower':
        return `${label} Enclave`;
      case 'tower':
        return `${label} Marches`;
      case 'town':
        return `${label} Compact`;
      default:
        return `${label} Dominion`;
    }
  };

  const claimRadiusScale = 0.25; // shrink territorial growth range by 75%

  const shuffledSeeds = shuffleArray(uniqueSeeds, randomFn);
  const factions = shuffledSeeds.map((seed, index) => {
    const claimRadius = resolveClaimRadius(seed);
    const scaledClaimRadius = Math.max(1, claimRadius * claimRadiusScale);
    return {
      id: index,
      name: resolveFactionName(seed),
      color: pickFactionColor(index),
      capital: {
        x: seed.x,
        y: seed.y,
        label: seed.label || null,
        type: seed.settlementKind || seed.type || 'settlement'
      },
      territory: 0,
      claimRadius: scaledClaimRadius,
      contestScale: Math.max(4, scaledClaimRadius * 0.6)
    };
  });

  const factionById = new Map(factions.map((faction) => [faction.id, faction]));
  const connectedMarks = new Int32Array(width * height);
  connectedMarks.fill(-1);

  const enforceFactionConnectivity = () => {
    if (factions.length === 0) {
      return;
    }

    factions.forEach((faction) => {
      const capital = faction.capital || {};
      const cx = Number.isFinite(capital.x) ? capital.x : null;
      const cy = Number.isFinite(capital.y) ? capital.y : null;

      if (cx === null || cy === null || cx < 0 || cy < 0 || cx >= width || cy >= height) {
        return;
      }

      const startRow = tiles[cy];
      const startTile = startRow ? startRow[cx] : null;
      if (!startTile || startTile.factionId !== faction.id) {
        return;
      }

      const queue = [[cx, cy]];
      let index = 0;
      const startIndex = toIndex(cx, cy);
      connectedMarks[startIndex] = faction.id;

      while (index < queue.length) {
        const [tx, ty] = queue[index];
        index += 1;

        for (let i = 0; i < cardinalNeighborOffsets.length; i += 1) {
          const offset = cardinalNeighborOffsets[i];
          const nx = tx + offset[0];
          const ny = ty + offset[1];

          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }

          const neighborRow = tiles[ny];
          const neighborTile = neighborRow ? neighborRow[nx] : null;
          if (!neighborTile || neighborTile.factionId !== faction.id) {
            continue;
          }

          const neighborIndex = toIndex(nx, ny);
          if (connectedMarks[neighborIndex] !== faction.id) {
            connectedMarks[neighborIndex] = faction.id;
            queue.push([nx, ny]);
          }
        }
      }
    });

    for (let y = 0; y < height; y += 1) {
      const row = tiles[y];
      if (!row) {
        continue;
      }
      for (let x = 0; x < width; x += 1) {
        const tile = row[x];
        if (!tile || tile.factionId === null || tile.factionId === undefined) {
          continue;
        }
        const tileIndex = toIndex(x, y);
        if (connectedMarks[tileIndex] !== tile.factionId) {
          tile.factionId = null;
          tile.factionInfluence = 0;
        }
        connectedMarks[tileIndex] = -1;
      }
    }

    factions.forEach((faction) => {
      faction.territory = 0;
    });

    for (let y = 0; y < height; y += 1) {
      const row = tiles[y];
      if (!row) {
        continue;
      }
      for (let x = 0; x < width; x += 1) {
        const tile = row[x];
        if (!tile || tile.factionId === null || tile.factionId === undefined) {
          continue;
        }
        const faction = factionById.get(tile.factionId);
        if (faction) {
          faction.territory += 1;
        }
      }
    }

    connectedMarks.fill(-1);
  };

  const applyOverlordVassalRules = () => {
    if (!Array.isArray(factions) || factions.length === 0) {
      return;
    }

    const neighborMap = new Map();
    const recordNeighbor = (sourceId, targetId) => {
      if (sourceId === null || sourceId === undefined || targetId === null || targetId === undefined) {
        return;
      }
      if (sourceId === targetId) {
        return;
      }
      if (!neighborMap.has(sourceId)) {
        neighborMap.set(sourceId, new Set());
      }
      neighborMap.get(sourceId).add(targetId);
    };

    for (let y = 0; y < height; y += 1) {
      const row = tiles[y];
      if (!row) {
        continue;
      }
      for (let x = 0; x < width; x += 1) {
        const tile = row[x];
        if (!tile) {
          continue;
        }
        const factionId = tile.factionId;
        if (factionId === null || factionId === undefined) {
          continue;
        }
        for (let i = 0; i < cardinalNeighborOffsets.length; i += 1) {
          const [ox, oy] = cardinalNeighborOffsets[i];
          const nx = x + ox;
          const ny = y + oy;
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const neighborRow = tiles[ny];
          const neighborTile = neighborRow ? neighborRow[nx] : null;
          if (!neighborTile) {
            continue;
          }
          const neighborFactionId = neighborTile.factionId;
          if (neighborFactionId === null || neighborFactionId === undefined) {
            continue;
          }
          recordNeighbor(factionId, neighborFactionId);
        }
      }
    }

    if (neighborMap.size === 0) {
      return;
    }

    const assignmentCandidates = [];

    const resolveCapitalType = (faction) => {
      if (!faction || !faction.capital || typeof faction.capital.type !== 'string') {
        return '';
      }
      return faction.capital.type.trim().toLowerCase();
    };

    const resolveDistanceBetween = (a, b) => {
      const ax = Number.isFinite(a?.capital?.x) ? a.capital.x : null;
      const ay = Number.isFinite(a?.capital?.y) ? a.capital.y : null;
      const bx = Number.isFinite(b?.capital?.x) ? b.capital.x : null;
      const by = Number.isFinite(b?.capital?.y) ? b.capital.y : null;
      if (ax === null || ay === null || bx === null || by === null) {
        return Infinity;
      }
      const dx = bx - ax;
      const dy = by - ay;
      return dx * dx + dy * dy;
    };

    factions.forEach((faction) => {
      if (!faction || faction.id === null || faction.id === undefined) {
        return;
      }
      const capitalType = resolveCapitalType(faction);
      if (!capitalType) {
        return;
      }
      const neighbors = neighborMap.get(faction.id);
      if (!neighbors || neighbors.size === 0) {
        return;
      }

      const allowedVassalTypes = [];
      if (capitalType === 'greatdwarfhold') {
        allowedVassalTypes.push('dwarfhold');
      } else if (capitalType === 'castle') {
        allowedVassalTypes.push('town', 'city', 'village');
      }

      if (allowedVassalTypes.length === 0) {
        return;
      }

      neighbors.forEach((neighborId) => {
        const neighborFaction = factionById.get(neighborId);
        if (!neighborFaction) {
          return;
        }
        const neighborType = resolveCapitalType(neighborFaction);
        if (!allowedVassalTypes.includes(neighborType)) {
          return;
        }
        assignmentCandidates.push({
          vassalId: neighborFaction.id,
          overlordId: faction.id,
          distanceSquared: resolveDistanceBetween(faction, neighborFaction)
        });
      });
    });

    if (assignmentCandidates.length === 0) {
      return;
    }

    assignmentCandidates.sort((a, b) => {
      const distA = Number.isFinite(a.distanceSquared) ? a.distanceSquared : Infinity;
      const distB = Number.isFinite(b.distanceSquared) ? b.distanceSquared : Infinity;
      return distA - distB;
    });

    const vassalAssignments = new Map();

    assignmentCandidates.forEach(({ vassalId, overlordId }) => {
      if (vassalId === overlordId) {
        return;
      }
      if (vassalAssignments.has(vassalId)) {
        return;
      }
      const overlordFaction = factionById.get(overlordId);
      const vassalFaction = factionById.get(vassalId);
      if (!overlordFaction || !vassalFaction) {
        return;
      }
      const overlordType = resolveCapitalType(overlordFaction);
      const vassalType = resolveCapitalType(vassalFaction);
      if (overlordType === 'greatdwarfhold' && vassalType !== 'dwarfhold') {
        return;
      }
      if (overlordType === 'castle' && !['town', 'city', 'village'].includes(vassalType)) {
        return;
      }
      vassalAssignments.set(vassalId, overlordId);
    });

    if (vassalAssignments.size === 0) {
      return;
    }

    factions.forEach((faction) => {
      if (!faction) {
        return;
      }
      faction.vassals = [];
      faction.isVassal = false;
      faction.overlordId = null;
    });

    vassalAssignments.forEach((overlordId, vassalId) => {
      const overlordFaction = factionById.get(overlordId);
      const vassalFaction = factionById.get(vassalId);
      if (!overlordFaction || !vassalFaction) {
        return;
      }
      vassalFaction.isVassal = true;
      vassalFaction.overlordId = overlordId;
      if (!Array.isArray(overlordFaction.vassals)) {
        overlordFaction.vassals = [];
      }
      overlordFaction.vassals.push(vassalId);
    });

    for (let y = 0; y < height; y += 1) {
      const row = tiles[y];
      if (!row) {
        continue;
      }
      for (let x = 0; x < width; x += 1) {
        const tile = row[x];
        if (!tile) {
          continue;
        }
        const currentFactionId = tile.factionId;
        if (currentFactionId === null || currentFactionId === undefined) {
          continue;
        }
        const overlordId = vassalAssignments.get(currentFactionId);
        if (overlordId === undefined) {
          continue;
        }
        tile.factionId = overlordId;
        tile.factionInfluence = clamp(Number(tile.factionInfluence) || 0, 0, 1);
      }
    }

    factions.forEach((faction) => {
      if (faction) {
        faction.territory = 0;
      }
    });

    for (let y = 0; y < height; y += 1) {
      const row = tiles[y];
      if (!row) {
        continue;
      }
      for (let x = 0; x < width; x += 1) {
        const tile = row[x];
        if (!tile) {
          continue;
        }
        const tileFactionId = tile.factionId;
        if (tileFactionId === null || tileFactionId === undefined) {
          continue;
        }
        const faction = factionById.get(tileFactionId);
        if (faction) {
          faction.territory += 1;
        }
      }
    }

    factions.forEach((faction) => {
      const capitalX = Number.isFinite(faction?.capital?.x) ? faction.capital.x : null;
      const capitalY = Number.isFinite(faction?.capital?.y) ? faction.capital.y : null;
      if (capitalX === null || capitalY === null) {
        return;
      }
      const row = tiles[capitalY];
      const tile = row ? row[capitalX] : null;
      if (!tile || tile.factionId !== faction.id) {
        return;
      }
      tile.factionInfluence = Math.max(Number(tile.factionInfluence) || 0, 0.9);
    });
  };

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      const tile = tiles[y] ? tiles[y][x] : null;
      if (!tile) {
        continue;
      }
      if (waterMask && waterMask[idx]) {
        tile.factionId = null;
        tile.factionInfluence = 0;
        continue;
      }

      let bestFaction = null;
      let bestDistanceSq = Infinity;
      let bestAdjustedDistanceSq = Infinity;
      let bestSuitability = 0;
      let secondDistanceSq = Infinity;
      let secondAdjustedDistanceSq = Infinity;

      for (let i = 0; i < factions.length; i += 1) {
        const faction = factions[i];
        const suitability = evaluateFactionTileSuitability(faction, tile, x, y);
        if (suitability <= 0) {
          continue;
        }

        const dx = x - faction.capital.x;
        const dy = y - faction.capital.y;
        const distanceSq = dx * dx + dy * dy;
        const adjustedDistanceSq = distanceSq / (suitability * suitability);

        if (adjustedDistanceSq < bestAdjustedDistanceSq) {
          secondAdjustedDistanceSq = bestAdjustedDistanceSq;
          secondDistanceSq = bestDistanceSq;
          bestAdjustedDistanceSq = adjustedDistanceSq;
          bestDistanceSq = distanceSq;
          bestFaction = faction;
          bestSuitability = suitability;
        } else if (adjustedDistanceSq < secondAdjustedDistanceSq) {
          secondAdjustedDistanceSq = adjustedDistanceSq;
          secondDistanceSq = distanceSq;
        }
      }

      const bestDistance = Number.isFinite(bestDistanceSq) ? Math.sqrt(bestDistanceSq) : Infinity;
      const secondDistance = Number.isFinite(secondDistanceSq) ? Math.sqrt(secondDistanceSq) : Infinity;

      if (!bestFaction || !Number.isFinite(bestDistance)) {
        tile.factionId = null;
        tile.factionInfluence = 0;
        continue;
      }

      const suitabilityRadiusFactor = clamp(0.55 + bestSuitability * 0.45, 0.55, 1);
      const effectiveClaimRadius = bestFaction.claimRadius * suitabilityRadiusFactor;

      if (bestDistance > effectiveClaimRadius) {
        tile.factionId = null;
        tile.factionInfluence = 0;
        continue;
      }

      const proximity = clamp(1 - bestDistance / effectiveClaimRadius, 0, 1);
      let contestFactor = 1;
      if (Number.isFinite(secondDistance) && secondDistance < Infinity) {
        const gap = Math.max(0, secondDistance - bestDistance);
        const contestScale = bestFaction.contestScale * (1 / Math.max(bestSuitability, 0.35));
        contestFactor = clamp(gap / contestScale, 0, 1);
      }
      const influence = clamp(proximity * (0.7 + contestFactor * 0.3) * bestSuitability, 0, 1);

      tile.factionId = bestFaction.id;
      tile.factionInfluence = influence;
      bestFaction.territory += 1;
    }
  }

  const fillUnclaimedEnclaves = () => {
    const visited = new Set();

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const row = tiles[y];
        const tile = row ? row[x] : null;
        if (!tile) {
          continue;
        }
        if (waterMask && waterMask[idx]) {
          continue;
        }
        if (tile.factionId !== null && tile.factionId !== undefined) {
          continue;
        }

        const tileIndex = toIndex(x, y);
        if (visited.has(tileIndex)) {
          continue;
        }

        const component = [];
        const queue = [[x, y]];
        let queueIndex = 0;
        let touchesEdge = false;
        const borderingFactions = new Set();
        visited.add(tileIndex);

        while (queueIndex < queue.length) {
          const [cx, cy] = queue[queueIndex];
          queueIndex += 1;
          component.push([cx, cy]);

          for (let i = 0; i < cardinalNeighborOffsets.length; i += 1) {
            const [ox, oy] = cardinalNeighborOffsets[i];
            const nx = cx + ox;
            const ny = cy + oy;

            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              touchesEdge = true;
              continue;
            }

            const nIdx = ny * width + nx;
            const neighborRow = tiles[ny];
            const neighborTile = neighborRow ? neighborRow[nx] : null;
            if (!neighborTile) {
              touchesEdge = true;
              continue;
            }
            if (waterMask && waterMask[nIdx]) {
              touchesEdge = true;
              continue;
            }

            if (neighborTile.factionId === null || neighborTile.factionId === undefined) {
              const neighborIndex = toIndex(nx, ny);
              if (!visited.has(neighborIndex)) {
                visited.add(neighborIndex);
                queue.push([nx, ny]);
              }
              continue;
            }

            borderingFactions.add(neighborTile.factionId);
          }

          if (touchesEdge) {
            continue;
          }

          for (let i = 0; i < surroundingNeighborOffsets.length; i += 1) {
            const [ox, oy] = surroundingNeighborOffsets[i];
            const nx = cx + ox;
            const ny = cy + oy;

            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              touchesEdge = true;
              continue;
            }

            const neighborRow = tiles[ny];
            const neighborTile = neighborRow ? neighborRow[nx] : null;
            if (!neighborTile) {
              touchesEdge = true;
              continue;
            }
            if (neighborTile.factionId !== null && neighborTile.factionId !== undefined) {
              borderingFactions.add(neighborTile.factionId);
            }
          }
        }

        if (touchesEdge || borderingFactions.size !== 1) {
          continue;
        }

        const [factionId] = borderingFactions;
        if (!factionById.has(factionId)) {
          continue;
        }

        for (let i = 0; i < component.length; i += 1) {
          const [cx, cy] = component[i];
          const componentTile = tiles[cy][cx];
          componentTile.factionId = factionId;
          componentTile.factionInfluence = Math.max(componentTile.factionInfluence || 0, 0.2);
        }
      }
    }
  };

  fillUnclaimedEnclaves();
  enforceFactionConnectivity();
  applyOverlordVassalRules();

  return { factions };
}

function describeInfluenceStrength(value) {
  const strength = clamp(Number(value) || 0, 0, 1);
  if (strength >= 0.85) {
    return 'Seat of Power';
  }
  if (strength >= 0.65) {
    return 'Heartland';
  }
  if (strength >= 0.45) {
    return 'Core Territory';
  }
  if (strength >= 0.25) {
    return 'Border March';
  }
  if (strength >= 0.12) {
    return 'Outer Reach';
  }
  return 'Faint Influence';
}

const defaultCultureColorByKey = {
  dwarves: '#f4c069',
  humans: '#9bb6d8',
  elves: '#6ecf85',
  halflings: '#f7a072',
  gnomes: '#c9a3e6',
  goblins: '#7f8c4d',
  kobolds: '#b1c8ff',
  dragonborn: '#c16a6a',
  tieflings: '#b064b0',
  orcs: '#556b2f',
  gnolls: '#c58f2d',
  beastmen: '#8f6a3a',
  ogres: '#b7745c',
  trolls: '#5c8563',
  harpies: '#b89cc6',
  satyrs: '#c18c5d',
  nymphs: '#9bd4a9',
  ents: '#8bbbcf',
  beastmasters: '#b0f0d0',
  wizards: '#9c5cff',
  undead: '#b1b1b1',
  elementals: '#48cae4',
  mindflayers: '#845ec2',
  merfolks: '#49b6d4',
  fae: '#d8a8ff',
  centaurs: '#d8c070',
  giants: '#cfa372',
  fimir: '#6b8f59',
  demons: '#b14646',
  snakemen: '#7b8f6d',
  dragons: '#d97706',
  elwetritsch: '#d9b26f',
  karkinos: '#4a6f8c',
  blemaayae: '#a35fa9',
  pygmy: '#c28b5b',
  half_orcs: '#647a57',
  half_elves: '#7ba696',
  dryad: '#58b072',
  leshy: '#3f7a4d',
  tuskar: '#7e91a8',
  others: '#9e9e9e'
};

function createAmbientStructureOptions(entries) {
  if (!Array.isArray(entries)) {
    return [];
  }
  return entries
    .map((entry) => {
      if (typeof entry === 'string') {
        const trimmed = entry.trim();
        if (!trimmed) {
          return null;
        }
        const key = trimmed
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '');
        if (!key) {
          return null;
        }
        return { key, label: trimmed };
      }

      if (!entry || typeof entry !== 'object') {
        return null;
      }

      const rawLabel = typeof entry.label === 'string' ? entry.label.trim() : '';
      const rawKey =
        typeof entry.key === 'string' && entry.key.trim()
          ? entry.key.trim()
          : rawLabel;
      if (!rawKey) {
        return null;
      }

      const key = rawKey
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '');
      if (!key) {
        return null;
      }

      const fallbackLabel = rawKey
        .replace(/_/g, ' ')
        .replace(/\b\w/g, (match) => match.toUpperCase());
      const label = rawLabel || fallbackLabel;

      const option = { key, label };
      Object.entries(entry).forEach(([propKey, propValue]) => {
        if (propKey === 'label' || propKey === 'key') {
          return;
        }
        option[propKey] = propValue;
      });

      return option;
    })
    .filter(Boolean);
}

const ambientStructureOptionsByCulture = {
  humans: createAmbientStructureOptions([
    'Wayside Shrine',
    'Market Cross',
    'Village Green',
    { label: 'Homestead', disallowForestOverlay: true },
    'Riverside Ferry Landing',
    { label: 'Lumber Mill', requiresTreeNeighbor: true }
  ]),
  dwarves: createAmbientStructureOptions([
    'Ancestral Cairn',
    'Brewmaster Alcove',
    'Runestone Marker',
    'Tunnel Watch Post'
  ]),
  elves: createAmbientStructureOptions([
    { label: 'Great Tree', requiresTreeOverlay: true },
    { label: 'Moonwell', requiresTreeOverlay: true },
    'Leafweaver Pavilion',
    'Starbloom Archway',
    'Silversong Clearing'
  ]),
  halflings: createAmbientStructureOptions([
    'Storyteller Hearth',
    'Picnic Nook',
    'Pipeweed Arbor',
    'Cozy Lantern Row',
    'Hobbit Holds'
  ]),
  gnomes: createAmbientStructureOptions([
    'Whirligig Garden',
    "Tinkerer's Yard",
    'Clockwork Gazebo',
    'Hidden Workshop Hatch'
  ]),
  goblins: createAmbientStructureOptions([
    'Drumfire Pit',
    'Sneak Ambush Hollow',
    'Totem Mound',
    'Rattletrap Camp'
  ]),
  kobolds: createAmbientStructureOptions([
    'Torch Warren Mouth',
    'Snarewood Clearing',
    'Sparkstone Cache',
    'Trapline Posts'
  ]),
  dragonborn: createAmbientStructureOptions([
    'Oathfire Dais',
    'Bannered Parade Ground',
    'Scaleguard Post',
    'Dragonkin Muster Field'
  ]),
  tieflings: createAmbientStructureOptions([
    'Emberglass Obelisk',
    'Ashen Prayer Steps',
    'Infernal Lantern Row',
    'Shadowbound Court'
  ]),
  orcs: createAmbientStructureOptions([
    'War Chant Ring',
    'Bonefire Circle',
    'Raiders Mustering Yard',
    'Warg Howl Post'
  ]),
  beastmen: createAmbientStructureOptions([
    'Horn Cairn',
    'Hide-Rack Encampment',
    'Totem Thicket',
    'Stampede Clearing'
  ]),
  ogres: createAmbientStructureOptions([
    'Boulder Toss Field',
    'Feast Pit',
    'Stonegrub Larder',
    'Mossy Rest Stones'
  ]),
  trolls: createAmbientStructureOptions([
    'Regeneration Pool',
    'Moss-Lair Hollow',
    'Stone Slumber Niche',
    'Ice Pillar Den'
  ]),
  harpies: createAmbientStructureOptions([
    'Wind-Shear Roost',
    'Feathered Beacon',
    'Shriekspire',
    'Sky-Rake Perch'
  ]),
  satyrs: createAmbientStructureOptions([
    'Revel Fire Ring',
    'Wine-Cask Cache',
    'Panflute Stage',
    'Grove Dance Green'
  ]),
  nymphs: createAmbientStructureOptions([
    'Moonlit Spring',
    'Petal Drift Pool',
    'Mistveil Hollow',
    'Lilyglade Retreat'
  ]),
  ents: createAmbientStructureOptions([
    'Root Sentinel Stand',
    'Sapling Nursery',
    'Barkwatch Clearing',
    'Seedstone Grove'
  ]),
  beastmasters: createAmbientStructureOptions([
    'Menagerie Pens',
    'Falconry Spire',
    'Tamed Behemoth Pen',
    'Horncall Field'
  ]),
  wizards: createAmbientStructureOptions([
    'Arcane Scrying Obelisk',
    'Leyline Beacon',
    'Spellscar Circle',
    'Runic Observatory'
  ]),
  undead: createAmbientStructureOptions([
    'Bone Cairn Field',
    'Ghoul Rest Hollow',
    'Withered Graveyard',
    'Cryptlight Vigil'
  ]),
  elementals: createAmbientStructureOptions([
    'Flame Vent',
    'Storm Crystal Node',
    'Whispering Whirlpool',
    'Shifting Dust Vortex'
  ]),
  mindflayers: createAmbientStructureOptions([
    'Psionic Monolith',
    'Nautiloid Beacon',
    'Brain Lichen Gallery',
    'Thoughtspike Plaza'
  ]),
  merfolks: createAmbientStructureOptions([
    'Coral Waymarker',
    'Tidepool Choir',
    'Shellstone Plaza',
    'Pearl Lantern Shoal'
  ]),
  fae: createAmbientStructureOptions([
    'Gossamer Pavilion',
    'Starlit Lantern Tree',
    'Glittering Mushroom Ring',
    'Whimsy Knoll'
  ]),
  centaurs: createAmbientStructureOptions([
    'Trackway Cairn',
    'Archery Stakes',
    'Waystone Camp',
    'Galloping Moot'
  ]),
  giants: createAmbientStructureOptions([
    'Thunderstone Seat',
    'Boulder Game Court',
    'Watchfire Cairn',
    'Skystride Outlook'
  ]),
  fimir: createAmbientStructureOptions([
    'Bog Idol',
    'Mist Totem',
    'Cyclopean Hut Circle',
    'Fenwatch Stilt'
  ]),
  demons: createAmbientStructureOptions([
    'Scorched Summoning Sigil',
    'Obsidian Spike',
    'Ashen Rift',
    'Hellbrand Camp'
  ]),
  snakemen: createAmbientStructureOptions([
    'Sunstone Terrace',
    'Venom Grove',
    'Cenote Shrine',
    'Serpent Muster Court'
  ]),
  dragons: createAmbientStructureOptions([
    'Molten Perch',
    'Treasure Scatter',
    'Windworn Ledge',
    'Skycoil Outlook',
    { label: 'Sleeping Dragon', requiresMountainOverlay: true }
  ]),
  elwetritsch: createAmbientStructureOptions([
    'Briar Nest',
    'Feathered Folly',
    'Copper Vine Coop',
    'Thicket Playcourt'
  ]),
  karkinos: createAmbientStructureOptions([
    'Shell Midden Barrow',
    'Tide Harpoon Post',
    'Brine Altar',
    'Surfclaw Watch'
  ]),
  blemaayae: createAmbientStructureOptions([
    'Dune Hive',
    'Obsidian Watch Spire',
    'Ridge Stone Tents',
    'Sandglass Encampment'
  ]),
  pygmy: createAmbientStructureOptions([
    'Stilted Palm Huts',
    'Painted Drum Plaza',
    'Leaf Hammock Camp',
    'Storyfire Circle'
  ]),
  half_orcs: createAmbientStructureOptions([
    'Frontier Trading Circle',
    'Border Watchfire',
    'Ironbond War Lodge',
    'River Bargaining Jetty'
  ]),
  half_elves: createAmbientStructureOptions([
    'Moonlit Moot Ring',
    'Forest Accord Glade',
    'Woven-Lantern Pier',
    'River Bargaining Jetty'
  ]),
  dryad: createAmbientStructureOptions([
    'Heart-Tree Grove',
    'Blooming Shrine',
    'Vined Stone Arch',
    'Petalshade Nook'
  ]),
  leshy: createAmbientStructureOptions([
    'Root Snare Clearing',
    'Totem Thicket',
    'Carved Bark Gate',
    'Frostbough Hide'
  ]),
  tuskar: createAmbientStructureOptions([
    'Carved Tusk Stele',
    'Icewind Moot Ring',
    'Frosttusk Longhouse',
    'Snowdrift Watch'
  ]),
  others: createAmbientStructureOptions([
    "Wanderer's Obelisk",
    'Sky-Reader Cairn',
    'Caravan Fire Ring',
    'Lonely Waystone'
  ])
};

function normaliseCultureKey(key, fallbackLabel) {
  if (typeof key === 'string' && key.trim()) {
    return key.trim().toLowerCase();
  }
  if (typeof fallbackLabel === 'string' && fallbackLabel.trim()) {
    return fallbackLabel
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '_')
      .replace(/^_+|_+$/g, '');
  }
  return null;
}

function formatCultureLabel(key) {
  if (typeof key !== 'string' || key.trim().length === 0) {
    return 'Unknown';
  }
  return key
    .trim()
    .replace(/[_-]+/g, ' ')
    .split(' ')
    .filter((part) => part.length > 0)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}

function resolveCultureColor(color, key) {
  if (typeof color === 'string' && color.trim()) {
    return color;
  }
  if (typeof key === 'string' && key) {
    const normalised = key.trim().toLowerCase();
    if (defaultCultureColorByKey[normalised]) {
      return defaultCultureColorByKey[normalised];
    }
  }
  return '#9e9e9e';
}

function getDefaultCulturalBreakdownForSettlement(settlement) {
  const type = typeof settlement?.type === 'string' ? settlement.type.trim() : '';
  if (type === 'centaurEncampment') {
    return [
      {
        key: 'centaurs',
        label: 'Centaurs',
        percentage: 100,
        color: defaultCultureColorByKey.centaurs
      }
    ];
  }
  if (type === 'orcCamp') {
    return [
      {
        key: 'orcs',
        label: 'Orcs',
        percentage: 100,
        color: defaultCultureColorByKey.orcs
      }
    ];
  }
  if (type === 'gnollCamp') {
    return [
      {
        key: 'gnolls',
        label: 'Gnolls',
        percentage: 100,
        color: defaultCultureColorByKey.gnolls
      }
    ];
  }
  if (type === 'trollCamp') {
    return [
      {
        key: 'trolls',
        label: 'Trolls',
        percentage: 100,
        color: defaultCultureColorByKey.trolls
      }
    ];
  }
  if (type === 'ogreCamp') {
    return [
      {
        key: 'ogres',
        label: 'Ogres',
        percentage: 100,
        color: defaultCultureColorByKey.ogres
      }
    ];
  }
  if (type === 'banditCamp') {
    return [
      {
        key: 'humans',
        label: 'Humans',
        percentage: 100,
        color: defaultCultureColorByKey.humans
      }
    ];
  }
  if (type === 'castle') {
    return [
      {
        key: 'humans',
        label: 'Humans',
        percentage: 85,
        color: defaultCultureColorByKey.humans
      },
      {
        key: 'dwarves',
        label: 'Dwarves',
        percentage: 15,
        color: defaultCultureColorByKey.dwarves
      }
    ];
  }
  if (type === 'monastery') {
    return [
      {
        key: 'humans',
        label: 'Humans',
        percentage: 100,
        color: defaultCultureColorByKey.humans
      }
    ];
  }
  if (type === 'saintShrine') {
    return [
      {
        key: 'humans',
        label: 'Humans',
        percentage: 100,
        color: defaultCultureColorByKey.humans
      }
    ];
  }
  if (type === 'roadsideTavern') {
    return [
      {
        key: 'humans',
        label: 'Humans',
        percentage: 65,
        color: defaultCultureColorByKey.humans
      },
      {
        key: 'dwarves',
        label: 'Dwarves',
        percentage: 20,
        color: defaultCultureColorByKey.dwarves
      },
      {
        key: 'halflings',
        label: 'Halflings',
        percentage: 15,
        color: defaultCultureColorByKey.halflings
      }
    ];
  }
  if (type === 'cave') {
    return [
      {
        key: 'goblins',
        label: 'Goblins',
        percentage: 100,
        color: defaultCultureColorByKey.goblins
      }
    ];
  }
  return null;
}

function resolveFallbackClaimRadius(type) {
  switch (type) {
    case 'dwarfhold':
      return 34;
    case 'hillhold':
      return 30;
    case 'town':
      return 32;
    case 'tower':
    case 'evilWizardTower':
      return 28;
    case 'lizardmenCity':
      return 36;
    case 'woodElfGrove':
      return 30;
    case 'mine':
      return 26;
    case 'orcCamp':
    case 'gnollCamp':
    case 'trollCamp':
    case 'ogreCamp':
    case 'banditCamp':
      return 28;
    case 'centaurEncampment':
      return 27;
    case 'monastery':
      return 27;
    case 'roadsideTavern':
      return 18;
    case 'cave':
      return 20;
    default:
      return 24;
  }
}

function resolveCulturalRadiusMultiplier(type) {
  switch (type) {
    case 'dwarfhold':
      return 2;
    case 'hillhold':
      return 1.9;
    case 'town':
      return 1.85;
    case 'tower':
      return 1.6;
    case 'evilWizardTower':
      return 1.7;
    case 'lizardmenCity':
      return 2.1;
    case 'woodElfGrove':
      return 1.8;
    case 'mine':
      return 1.55;
    case 'orcCamp':
    case 'gnollCamp':
    case 'trollCamp':
    case 'ogreCamp':
    case 'banditCamp':
      return 1.75;
    case 'centaurEncampment':
      return 1.7;
    case 'monastery':
      return 1.65;
    case 'roadsideTavern':
      return 1.25;
    case 'cave':
      return 1.45;
    default:
      return 1.6;
  }
}

function resolveCulturalFalloffPower(type) {
  switch (type) {
    case 'dwarfhold':
    case 'lizardmenCity':
      return 1.25;
    case 'hillhold':
    case 'town':
      return 1.28;
    case 'woodElfGrove':
      return 1.3;
    case 'tower':
    case 'evilWizardTower':
      return 1.36;
    case 'mine':
      return 1.42;
    case 'orcCamp':
    case 'gnollCamp':
    case 'trollCamp':
    case 'ogreCamp':
    case 'banditCamp':
      return 1.3;
    case 'centaurEncampment':
      return 1.32;
    case 'monastery':
      return 1.34;
    case 'roadsideTavern':
      return 1.4;
    case 'cave':
      return 1.44;
    default:
      return 1.35;
  }
}

function resolveHumanPresenceIntensity(tile) {
  if (!tile || !tile.culturalInfluence) {
    return 0;
  }
  const { key, strength, breakdown } = tile.culturalInfluence;
  let best = 0;
  if (key === 'humans') {
    const dominantStrength = Number(strength);
    if (Number.isFinite(dominantStrength)) {
      best = Math.max(best, clamp(dominantStrength, 0, 1));
    }
  }
  if (Array.isArray(breakdown)) {
    for (let i = 0; i < breakdown.length; i += 1) {
      const entry = breakdown[i];
      if (!entry || entry.key !== 'humans') {
        continue;
      }
      const share = Number(entry.share);
      if (Number.isFinite(share)) {
        best = Math.max(best, clamp(share, 0, 1));
      }
      const entryStrength = Number(entry.strength);
      if (Number.isFinite(entryStrength)) {
        best = Math.max(best, clamp(entryStrength, 0, 1));
      }
    }
  }
  return clamp(best, 0, 1);
}

const noopWoodElfTerritoryCheck = () => false;

function createWoodElfTerritoryInfo({ tiles, width, height, factions, radius = 3 }) {
  if (!Array.isArray(tiles) || tiles.length === 0) {
    return { mask: null, isNear: noopWoodElfTerritoryCheck };
  }

  const mapHeight = Number.isFinite(height) ? Math.max(0, Math.floor(height)) : tiles.length;
  const mapWidth = Number.isFinite(width) ? Math.max(0, Math.floor(width)) : tiles[0]?.length || 0;
  if (mapWidth <= 0 || mapHeight <= 0) {
    return { mask: null, isNear: noopWoodElfTerritoryCheck };
  }

  const woodElfFactionIds = new Set();
  if (Array.isArray(factions)) {
    factions.forEach((faction) => {
      if (!faction || faction.id === null || faction.id === undefined) {
        return;
      }
      const capitalType =
        typeof faction?.capital?.type === 'string' ? faction.capital.type.trim().toLowerCase() : '';
      if (capitalType === 'woodelfgrove') {
        woodElfFactionIds.add(faction.id);
      }
    });
  }

  if (woodElfFactionIds.size === 0) {
    return { mask: null, isNear: noopWoodElfTerritoryCheck };
  }

  const resolvedRadius = Math.max(0, Math.floor(radius));
  const radiusSq = resolvedRadius * resolvedRadius;
  const mask = new Uint8Array(mapWidth * mapHeight);

  const markVicinity = (centerX, centerY) => {
    for (let dy = -resolvedRadius; dy <= resolvedRadius; dy += 1) {
      const ny = centerY + dy;
      if (ny < 0 || ny >= mapHeight) {
        continue;
      }
      for (let dx = -resolvedRadius; dx <= resolvedRadius; dx += 1) {
        const nx = centerX + dx;
        if (nx < 0 || nx >= mapWidth) {
          continue;
        }
        if (dx * dx + dy * dy > radiusSq) {
          continue;
        }
        const idx = ny * mapWidth + nx;
        mask[idx] = 1;
      }
    }
  };

  for (let y = 0; y < mapHeight; y += 1) {
    const row = tiles[y];
    if (!Array.isArray(row)) {
      continue;
    }
    for (let x = 0; x < mapWidth; x += 1) {
      const tile = row[x];
      if (!tile) {
        continue;
      }
      const factionId = tile.factionId;
      if (factionId === null || factionId === undefined) {
        continue;
      }
      if (woodElfFactionIds.has(factionId)) {
        markVicinity(x, y);
      }
    }
  }

  const isNear = (x, y) => {
    if (x < 0 || y < 0 || x >= mapWidth || y >= mapHeight) {
      return false;
    }
    const idx = y * mapWidth + x;
    return mask[idx] === 1;
  };

  return { mask, isNear };
}

function spawnAmbientStructures({
  tiles,
  width,
  height,
  grassTileKey,
  seedNumber,
  woodElfTerritoryInfo
}) {
  const placements = [];
  if (!Array.isArray(tiles) || tiles.length === 0) {
    return placements;
  }

  const mapHeight = Number.isFinite(height) ? Math.max(0, Math.floor(height)) : tiles.length;
  const mapWidth = Number.isFinite(width) ? Math.max(0, Math.floor(width)) : tiles[0]?.length || 0;
  if (mapWidth <= 0 || mapHeight <= 0) {
    return placements;
  }

  const isNearWoodElfTerritory =
    woodElfTerritoryInfo && typeof woodElfTerritoryInfo.isNear === 'function'
      ? woodElfTerritoryInfo.isNear
      : noopWoodElfTerritoryCheck;

  const numericSeed = Number.isFinite(seedNumber) ? seedNumber >>> 0 : 0;
  const farmSeed = (numericSeed + 0x51d7348f) >>> 0;
  const farmVariantSeed = (numericSeed + 0x27d4eb2d) >>> 0;
  const farmCropSeed = (numericSeed + 0x85ebca6b) >>> 0;
  const farmRelocationSeed = (numericSeed + 0x6c8e9cf5) >>> 0;
  const farmRelocationTargetSeed = (numericSeed + 0x0b6d0f1d) >>> 0;
  const farmRelocationAltSeed = (numericSeed + 0x8f2a5c4b) >>> 0;
  const farmCropSwapSeed = (numericSeed + 0x2bd7a4dd) >>> 0;
  const farmCropDeclusterSeed = (numericSeed + 0x4e8f9ab7) >>> 0;
  const huntingSeed = (numericSeed + 0x41c6ce57) >>> 0;

  const farmStructureKeys = [];
  if (tileLookup.has('AMBIENT_FARM')) {
    farmStructureKeys.push('AMBIENT_FARM');
  }
  if (tileLookup.has('AMBIENT_FARM_VARIANT')) {
    farmStructureKeys.push('AMBIENT_FARM_VARIANT');
  }
  const farmStructureKeySet = new Set(farmStructureKeys);
  const farmStructureDefaultKey = tileLookup.has('AMBIENT_FARM') ? 'AMBIENT_FARM' : null;
  const farmStructureVariantKey = tileLookup.has('AMBIENT_FARM_VARIANT') ? 'AMBIENT_FARM_VARIANT' : null;
  const homesteadKey = tileLookup.has('AMBIENT_HOMESTEAD') ? 'AMBIENT_HOMESTEAD' : null;
  const tavernKey = tileLookup.has('ROADSIDE_TAVERN') ? 'ROADSIDE_TAVERN' : null;
  const monasteryStructureKey = tileLookup.has('MONASTERY') ? 'MONASTERY' : null;
  const saintShrineStructureKey = tileLookup.has('SAINT_SHRINE') ? 'SAINT_SHRINE' : null;

  const makeCoordKey = (x, y) => `${x},${y}`;
  const cropTilesPlacedByGenerator = new Set();

  if (farmCropOverlayKey) {
    for (let y = 0; y < mapHeight; y += 1) {
      const row = tiles[y];
      if (!Array.isArray(row)) {
        continue;
      }
      for (let x = 0; x < mapWidth; x += 1) {
        const tile = row[x];
        if (!tile || tile.overlay !== farmCropOverlayKey) {
          continue;
        }
        cropTilesPlacedByGenerator.add(makeCoordKey(x, y));
      }
    }
  }

  const isTileEligibleForCropSwapDestination = (tile) =>
    Boolean(tile) && isTileEligibleForFarmBase(tile, { allowMissingGrassKey: !grassTileKey }) && !tile.overlay;

  const registerCropPlacement = (x, y) => {
    if (!farmCropOverlayKey) {
      return;
    }
    const row = tiles[y];
    if (!Array.isArray(row)) {
      return;
    }
    const tile = row[x];
    if (!tile || tile.overlay !== farmCropOverlayKey) {
      return;
    }
    cropTilesPlacedByGenerator.add(makeCoordKey(x, y));
  };

  const pickCropSwapDestination = (sourceX, sourceY, offsetSeed = 0) => {
    if (!farmCropOverlayKey) {
      return null;
    }
    const totalTiles = mapWidth * mapHeight;
    if (totalTiles <= 1) {
      return null;
    }
    const maxAttempts = Math.min(totalTiles, 600);
    for (let attempt = 0; attempt < maxAttempts; attempt += 1) {
      const seed =
        (farmCropSwapSeed +
          Math.imul(sourceX + offsetSeed + attempt, 0x27d4eb2d) +
          Math.imul(sourceY + offsetSeed + attempt, 0x165667b1)) >>>
        0;
      const xRoll = hashCoords(sourceX, attempt + offsetSeed, seed);
      const yRoll = hashCoords(attempt + offsetSeed, sourceY, seed ^ 0x9e3779b9);
      const nx = Math.max(0, Math.min(mapWidth - 1, Math.floor(xRoll * mapWidth)));
      const ny = Math.max(0, Math.min(mapHeight - 1, Math.floor(yRoll * mapHeight)));
      if (nx === sourceX && ny === sourceY) {
        continue;
      }
      const candidateTile = tiles[ny]?.[nx];
      if (!isTileEligibleForCropSwapDestination(candidateTile)) {
        continue;
      }
      return { x: nx, y: ny };
    }
    for (let yy = 0; yy < mapHeight; yy += 1) {
      const row = tiles[yy];
      if (!Array.isArray(row)) {
        continue;
      }
      for (let xx = 0; xx < mapWidth; xx += 1) {
        if (xx === sourceX && yy === sourceY) {
          continue;
        }
        if (isTileEligibleForCropSwapDestination(row[xx])) {
          return { x: xx, y: yy };
        }
      }
    }
    return null;
  };

  const relocateCropOverlayFromTile = (sourceX, sourceY, offsetSeed = 0) => {
    if (!farmCropOverlayKey) {
      return;
    }
    const row = tiles[sourceY];
    if (!Array.isArray(row)) {
      cropTilesPlacedByGenerator.delete(makeCoordKey(sourceX, sourceY));
      return;
    }
    const tile = row[sourceX];
    if (!tile || tile.overlay !== farmCropOverlayKey) {
      cropTilesPlacedByGenerator.delete(makeCoordKey(sourceX, sourceY));
      return;
    }
    tile.overlay = null;
    cropTilesPlacedByGenerator.delete(makeCoordKey(sourceX, sourceY));
    const destination = pickCropSwapDestination(sourceX, sourceY, offsetSeed);
    if (!destination) {
      tile.overlay = farmCropOverlayKey;
      registerCropPlacement(sourceX, sourceY);
      return;
    }
    const destRow = tiles[destination.y];
    if (!Array.isArray(destRow)) {
      return;
    }
    const destTile = destRow[destination.x];
    if (!destTile || destTile.overlay || destTile.structure || destTile.river) {
      tile.overlay = farmCropOverlayKey;
      registerCropPlacement(sourceX, sourceY);
      return;
    }
    if (!isTileEligibleForCropSwapDestination(destTile)) {
      tile.overlay = farmCropOverlayKey;
      registerCropPlacement(sourceX, sourceY);
      return;
    }
    destTile.overlay = farmCropOverlayKey;
    registerCropPlacement(destination.x, destination.y);
  };

  const countTrackedCropsWithinRadius = (centerX, centerY, radius = 1) => {
    if (radius <= 0 || cropTilesPlacedByGenerator.size === 0) {
      return cropTilesPlacedByGenerator.has(makeCoordKey(centerX, centerY)) ? 1 : 0;
    }
    let count = 0;
    for (let dy = -radius; dy <= radius; dy += 1) {
      const ny = centerY + dy;
      if (ny < 0 || ny >= mapHeight) {
        continue;
      }
      const row = tiles[ny];
      if (!Array.isArray(row)) {
        continue;
      }
      for (let dx = -radius; dx <= radius; dx += 1) {
        const nx = centerX + dx;
        if (nx < 0 || nx >= mapWidth) {
          continue;
        }
        if (cropTilesPlacedByGenerator.has(makeCoordKey(nx, ny)) && row[nx]?.overlay === farmCropOverlayKey) {
          count += 1;
        }
      }
    }
    return count;
  };

  let cropRelocationCounter = 0;
  const relocateCropsNear = (centerX, centerY) => {
    if (!farmCropOverlayKey || cropTilesPlacedByGenerator.size === 0) {
      return;
    }
    const radius = 3;
    let movedHere = 0;
    for (let dy = -radius; dy <= radius; dy += 1) {
      const ny = centerY + dy;
      if (ny < 0 || ny >= mapHeight) {
        continue;
      }
      const row = tiles[ny];
      if (!Array.isArray(row)) {
        continue;
      }
      for (let dx = -radius; dx <= radius; dx += 1) {
        const nx = centerX + dx;
        if (nx < 0 || nx >= mapWidth || (dx === 0 && dy === 0)) {
          continue;
        }
        const tile = row[nx];
        if (!tile || tile.overlay !== farmCropOverlayKey) {
          continue;
        }
        const key = makeCoordKey(nx, ny);
        if (!cropTilesPlacedByGenerator.has(key)) {
          continue;
        }
        relocateCropOverlayFromTile(nx, ny, cropRelocationCounter + movedHere);
        movedHere += 1;
      }
    }
    cropRelocationCounter += movedHere;
  };

  const runCropDeclusteringPass = () => {
    if (!farmCropOverlayKey || cropTilesPlacedByGenerator.size === 0) {
      return;
    }

    const relocationBudget = Math.max(0, Math.floor(cropTilesPlacedByGenerator.size * 0.2));
    if (relocationBudget === 0) {
      return;
    }

    const processed = new Set();
    let relocationsPerformed = 0;

    const scheduleRelocationIfCrowded = (centerX, centerY) => {
      if (relocationsPerformed >= relocationBudget) {
        return;
      }
      const candidates = [];
      for (let dy = -1; dy <= 1; dy += 1) {
        const ny = centerY + dy;
        if (ny < 0 || ny >= mapHeight) {
          continue;
        }
        const row = tiles[ny];
        if (!Array.isArray(row)) {
          continue;
        }
        for (let dx = -1; dx <= 1; dx += 1) {
          const nx = centerX + dx;
          if (nx < 0 || nx >= mapWidth || (dx === 0 && dy === 0)) {
            continue;
          }
          const tile = row[nx];
          if (!tile || tile.overlay !== farmCropOverlayKey) {
            continue;
          }
          const key = makeCoordKey(nx, ny);
          if (!cropTilesPlacedByGenerator.has(key) || processed.has(key)) {
            continue;
          }
          const density = countTrackedCropsWithinRadius(nx, ny, 1);
          candidates.push({ x: nx, y: ny, key, density });
        }
      }

      const maxImmediateNeighbors = 4;
      if (candidates.length <= maxImmediateNeighbors) {
        return;
      }

      candidates.sort((a, b) => {
        if (b.density !== a.density) {
          return b.density - a.density;
        }
        const aRoll = hashCoords(a.x, a.y, farmCropDeclusterSeed);
        const bRoll = hashCoords(b.x, b.y, farmCropDeclusterSeed);
        if (aRoll === bRoll) {
          return 0;
        }
        return aRoll < bRoll ? -1 : 1;
      });

      const relocationsNeeded = Math.min(candidates.length - maxImmediateNeighbors, relocationBudget - relocationsPerformed);
      for (let i = 0; i < relocationsNeeded; i += 1) {
        const candidate = candidates[i];
        processed.add(candidate.key);
        relocateCropOverlayFromTile(candidate.x, candidate.y, cropRelocationCounter);
        cropRelocationCounter += 1;
        relocationsPerformed += 1;
        if (relocationsPerformed >= relocationBudget) {
          break;
        }
      }
    };

    for (let y = 0; y < mapHeight; y += 1) {
      if (relocationsPerformed >= relocationBudget) {
        break;
      }
      const row = tiles[y];
      if (!Array.isArray(row)) {
        continue;
      }
      for (let x = 0; x < mapWidth; x += 1) {
        if (relocationsPerformed >= relocationBudget) {
          break;
        }
        const tile = row[x];
        if (!tile || !farmStructureKeySet.has(tile.structure)) {
          continue;
        }
        scheduleRelocationIfCrowded(x, y);
      }
    }
  };

  const createRelocationRng = (x, y, seed) => {
    const hashedSeed = (seed + Math.imul(x + 0x9e3779b9, 0x27d4eb2d) + Math.imul(y + 0x85ebca6b, 0x165667b1)) >>> 0;
    return mulberry32(hashedSeed || 1);
  };

  const pickByHash = (items, seed) => {
    if (!Array.isArray(items) || items.length === 0) {
      return -1;
    }
    let bestIndex = 0;
    let bestScore = Infinity;
    for (let i = 0; i < items.length; i += 1) {
      const item = items[i];
      const score = hashCoords(item.x, item.y, seed);
      if (score < bestScore) {
        bestScore = score;
        bestIndex = i;
      }
    }
    return bestIndex;
  };

  const isTileEligibleForFarmBase = (tile, { allowMissingGrassKey = false } = {}) => {
    if (!tile || tile.structure || tile.river) {
      return false;
    }
    if (tile.hillOverlay) {
      return false;
    }
    if (grassTileKey) {
      return tile.base === grassTileKey;
    }
    return allowMissingGrassKey;
  };

  const isTileEligibleForFarmStructure = (tile) =>
    isTileEligibleForFarmBase(tile, { allowMissingGrassKey: false }) && !tile.overlay;

  const isTileEligibleForFarmRelocation = (tile) =>
    isTileEligibleForFarmBase(tile, { allowMissingGrassKey: !grassTileKey }) && !tile.overlay;

  const isTileEligibleForFarmCrops = (tile) =>
    isTileEligibleForFarmBase(tile, { allowMissingGrassKey: false }) &&
    (!tile.overlay || tile.overlay === farmCropOverlayKey);

  const generateCropsNearFarm = (centerX, centerY) => {
    if (!farmCropOverlayKey) {
      return;
    }
    const radius = 3;
    const centerSeed =
      (farmCropSeed + Math.imul(centerX, 0x27d4eb2d) + Math.imul(centerY, 0x9e3779b9)) >>> 0;
    for (let dy = -radius; dy <= radius; dy += 1) {
      const ny = centerY + dy;
      if (ny < 0 || ny >= mapHeight) {
        continue;
      }
      for (let dx = -radius; dx <= radius; dx += 1) {
        const nx = centerX + dx;
        if (nx < 0 || nx >= mapWidth || (dx === 0 && dy === 0)) {
          continue;
        }
        const neighborTile = tiles[ny][nx];
        if (!isTileEligibleForFarmCrops(neighborTile)) {
          continue;
        }

        const distance = Math.max(Math.abs(dx), Math.abs(dy));
        if (distance > radius) {
          continue;
        }

        let chance = 0;
        if (distance <= 1) {
          chance = 0.15;
        } else if (distance === 2) {
          chance = 0.1;
        } else if (distance === 3) {
          chance = 0.05;
        }
        if (chance <= 0) {
          continue;
        }

        const roll = hashCoords(nx, ny, centerSeed);
        if (roll < chance) {
          neighborTile.overlay = farmCropOverlayKey;
          registerCropPlacement(nx, ny);
        }
      }
    }
  };

  for (let y = 0; y < mapHeight; y += 1) {
    const row = tiles[y];
    if (!Array.isArray(row)) {
      continue;
    }
    for (let x = 0; x < mapWidth; x += 1) {
      const tile = row[x];
      if (!tile || tile.structure || tile.river) {
        // Preserve existing structures (including ambient lumber mills) and river tiles.
        continue;
      }
      const humanIntensity = resolveHumanPresenceIntensity(tile);
      if (humanIntensity <= 0.05) {
        continue;
      }

      const intensityFactor = Math.pow(humanIntensity, 1.35);
      if (isTileEligibleForFarmStructure(tile)) {
        const farmChance = intensityFactor * 0.012;
        if (farmChance > 0 && hashCoords(x, y, farmSeed) < farmChance) {
          let farmStructureKey = 'AMBIENT_FARM';
          if (tileLookup.has('AMBIENT_FARM_VARIANT')) {
            const variantRoll = hashCoords(x, y, farmVariantSeed);
            if (variantRoll >= 0.5) {
              farmStructureKey = 'AMBIENT_FARM_VARIANT';
            }
          }
          tile.structure = farmStructureKey;
          tile.structureName = 'Farm';
          tile.structureDetails = null;
          placements.push({ x, y, type: 'farm' });
          generateCropsNearFarm(x, y);
          continue;
        }
      }

      if (!tile.structure && tileHasTreeOverlay(tile)) {
        if (isNearWoodElfTerritory(x, y)) {
          continue;
        }
        const huntingChance = intensityFactor * 0.0075;
        if (huntingChance > 0 && hashCoords(x, y, huntingSeed) < huntingChance) {
          tile.structure = 'AMBIENT_HUNTING_LODGE';
          tile.structureName = 'Hunting Lodge';
          tile.structureDetails = null;
          placements.push({ x, y, type: 'huntingLodge' });
        }
      }
    }
  }

  const relocationCandidates = [];
  for (let y = 0; y < mapHeight; y += 1) {
    const row = tiles[y];
    if (!Array.isArray(row)) {
      continue;
    }
    for (let x = 0; x < mapWidth; x += 1) {
      const tile = row[x];
      if (!isTileEligibleForFarmRelocation(tile)) {
        continue;
      }
      relocationCandidates.push({ x, y });
    }
  }

  if (farmStructureKeys.length > 0 && relocationCandidates.length > 0) {
    const visited = new Array(mapWidth * mapHeight).fill(false);
    const neighborOffsets = [
      [1, 0],
      [-1, 0],
      [0, 1],
      [0, -1]
    ];
    let relocationCounter = 0;
    let outOfRelocationSpots = false;

    for (let y = 0; y < mapHeight; y += 1) {
      if (outOfRelocationSpots) {
        break;
      }
      for (let x = 0; x < mapWidth; x += 1) {
        const idx = y * mapWidth + x;
        if (visited[idx]) {
          continue;
        }
        const tile = tiles[y]?.[x];
        if (!tile || !farmStructureKeySet.has(tile.structure)) {
          continue;
        }

        const cluster = [];
        const queue = [[x, y]];
        while (queue.length > 0) {
          const [cx, cy] = queue.pop();
          if (cx < 0 || cy < 0 || cx >= mapWidth || cy >= mapHeight) {
            continue;
          }
          const cIdx = cy * mapWidth + cx;
          if (visited[cIdx]) {
            continue;
          }
          const currentTile = tiles[cy]?.[cx];
          if (!currentTile || !farmStructureKeySet.has(currentTile.structure)) {
            continue;
          }
          visited[cIdx] = true;
          cluster.push({ x: cx, y: cy });
          for (let i = 0; i < neighborOffsets.length; i += 1) {
            const nx = cx + neighborOffsets[i][0];
            const ny = cy + neighborOffsets[i][1];
            if (nx < 0 || ny < 0 || nx >= mapWidth || ny >= mapHeight) {
              continue;
            }
            const nIdx = ny * mapWidth + nx;
            if (visited[nIdx]) {
              continue;
            }
            queue.push([nx, ny]);
          }
        }

        if (cluster.length <= 1) {
          continue;
        }
        const majorityCount = Math.floor(cluster.length / 2) + 1;
        const relocationsPlanned = Math.min(majorityCount, relocationCandidates.length);
        if (relocationsPlanned === 0) {
          outOfRelocationSpots = true;
          break;
        }

        const availableFarms = cluster.slice();
        let relocatedCount = 0;

        while (relocatedCount < relocationsPlanned && availableFarms.length > 0) {
          if (relocationCandidates.length === 0) {
            outOfRelocationSpots = true;
            break;
          }

          const relocationSeedOffset = (farmRelocationSeed + Math.imul(relocationCounter, 0x9e3779b9)) >>> 0;
          const farmIndex = pickByHash(availableFarms, relocationSeedOffset);
          if (farmIndex < 0 || farmIndex >= availableFarms.length) {
            relocationCounter += 1;
            continue;
          }

          const farmCoord = availableFarms[farmIndex];
          const farmTile = tiles[farmCoord.y]?.[farmCoord.x];
          if (!farmTile) {
            availableFarms.splice(farmIndex, 1);
            relocationCounter += 1;
            continue;
          }

          const targetSeedOffset = (farmRelocationTargetSeed + Math.imul(relocationCounter, 0x27d4eb2d)) >>> 0;
          const candidateIndex = pickByHash(relocationCandidates, targetSeedOffset);
          if (candidateIndex < 0 || candidateIndex >= relocationCandidates.length) {
            relocationCounter += 1;
            continue;
          }

          const destination = relocationCandidates.splice(candidateIndex, 1)[0];
          if (!destination) {
            relocationCounter += 1;
            continue;
          }
          const destinationTile = tiles[destination.y]?.[destination.x];
          if (!destinationTile || destinationTile.structure || destinationTile.river) {
            relocationCounter += 1;
            continue;
          }

          farmTile.structure = null;
          farmTile.structureName = null;
          farmTile.structureDetails = null;

          relocateCropsNear(farmCoord.x, farmCoord.y);

          const placementIndex = placements.findIndex(
            (entry) => entry && entry.type === 'farm' && entry.x === farmCoord.x && entry.y === farmCoord.y
          );
          if (placementIndex !== -1) {
            placements.splice(placementIndex, 1);
          }

          const altSeedOffset = (farmRelocationAltSeed + Math.imul(relocationCounter, 0x85ebca6b)) >>> 0;
          const convertRoll = hashCoords(destination.x, destination.y, altSeedOffset);
          const altStructures = [];
          if (homesteadKey) {
            altStructures.push({ key: homesteadKey, type: 'homestead' });
          }
          if (saintShrineStructureKey) {
            altStructures.push({ key: saintShrineStructureKey, type: 'saintShrine' });
          }
          if (monasteryStructureKey) {
            altStructures.push({ key: monasteryStructureKey, type: 'monastery' });
          }
          if (tavernKey) {
            altStructures.push({ key: tavernKey, type: 'roadsideTavern' });
          }

          const assignFarmStructure = () => {
            if (!farmStructureDefaultKey && !farmStructureVariantKey) {
              return false;
            }
            let structureKey = farmStructureDefaultKey || farmStructureVariantKey;
            if (farmStructureDefaultKey && farmStructureVariantKey) {
              const variantRoll = hashCoords(destination.x, destination.y, farmVariantSeed);
              if (variantRoll >= 0.5) {
                structureKey = farmStructureVariantKey;
              }
            }
            destinationTile.structure = structureKey;
            destinationTile.structureName = 'Farm';
            destinationTile.structureDetails = null;
            placements.push({ x: destination.x, y: destination.y, type: 'farm' });
            generateCropsNearFarm(destination.x, destination.y);
            return true;
          };

          const assignAlternativeStructure = () => {
            if (altStructures.length === 0 || convertRoll >= 0.55) {
              return false;
            }
            const selectionSeed = (altSeedOffset + 0x27d4eb2d) >>> 0;
            const selectionRoll = hashCoords(destination.x, destination.y, selectionSeed);
            const optionIndex = Math.max(
              0,
              Math.min(altStructures.length - 1, Math.floor(selectionRoll * altStructures.length))
            );
            const option = altStructures[optionIndex] || altStructures[0];
            if (!option) {
              return false;
            }
            const rng = createRelocationRng(destination.x, destination.y, altSeedOffset);
            if (option.type === 'homestead') {
              destinationTile.structure = option.key;
              destinationTile.structureName = 'Homestead';
              destinationTile.structureDetails = {
                type: 'homestead',
                displayType: 'Homestead',
                description: 'A modest rural homestead tended by local farmers.'
              };
            } else if (option.type === 'saintShrine') {
              const name = generateSaintShrineName(rng);
              const details = generateSaintShrineDetails(name, rng);
              destinationTile.structure = option.key;
              destinationTile.structureName = name;
              destinationTile.structureDetails = details;
            } else if (option.type === 'monastery') {
              const name = generateMonasteryName(rng);
              const details = generateMonasteryDetails(name, rng);
              destinationTile.structure = option.key;
              destinationTile.structureName = name;
              destinationTile.structureDetails = details;
            } else if (option.type === 'roadsideTavern') {
              const name = generateRoadsideTavernName(rng);
              const details = generateRoadsideTavernDetails(name, rng);
              destinationTile.structure = option.key;
              destinationTile.structureName = name;
              destinationTile.structureDetails = details;
            } else {
              return false;
            }
            placements.push({ x: destination.x, y: destination.y, type: option.type });
            return true;
          };

          if (!assignAlternativeStructure()) {
            assignFarmStructure();
          }

          availableFarms.splice(farmIndex, 1);
          relocatedCount += 1;
          relocationCounter += 1;
        }

        if (relocatedCount < relocationsPlanned && relocationCandidates.length === 0) {
          outOfRelocationSpots = true;
          break;
        }
      }
    }
  }

  runCropDeclusteringPass();

  return placements;
}

function applyCulturalInfluence({
  width,
  height,
  tiles,
  settlements,
  factions,
  isLandBaseTile,
  seedNumber,
  woodElfTerritoryInfo
}) {
  if (!Array.isArray(tiles) || tiles.length === 0) {
    return;
  }

  const mapHeight = Number.isFinite(height) ? Math.max(0, Math.floor(height)) : tiles.length;
  const mapWidth = Number.isFinite(width) ? Math.max(0, Math.floor(width)) : tiles[0]?.length || 0;
  if (mapWidth <= 0 || mapHeight <= 0) {
    return;
  }

  const isNearWoodElfTerritory =
    woodElfTerritoryInfo && typeof woodElfTerritoryInfo.isNear === 'function'
      ? woodElfTerritoryInfo.isNear
      : noopWoodElfTerritoryCheck;

  const isTileAdjacentToTree = (x, y) => {
    for (let dy = -1; dy <= 1; dy += 1) {
      const ny = y + dy;
      if (ny < 0 || ny >= mapHeight) {
        continue;
      }
      for (let dx = -1; dx <= 1; dx += 1) {
        const nx = x + dx;
        if (nx < 0 || nx >= mapWidth || (dx === 0 && dy === 0)) {
          continue;
        }
        const neighborTile = tiles[ny][nx];
        if (tileHasTreeOverlay(neighborTile)) {
          return true;
        }
      }
    }
    return false;
  };

  const replaceTreesNearLumberMill = (centerX, centerY) => {
    if (!cutTreeOverlayKey) {
      return;
    }
    const radius = 1;
    for (let dy = -radius; dy <= radius; dy += 1) {
      const ny = centerY + dy;
      if (ny < 0 || ny >= mapHeight) {
        continue;
      }
      for (let dx = -radius; dx <= radius; dx += 1) {
        const nx = centerX + dx;
        if (nx < 0 || nx >= mapWidth || (dx === 0 && dy === 0)) {
          continue;
        }
        const neighborTile = tiles[ny][nx];
        if (!neighborTile || neighborTile.structure || neighborTile.river) {
          continue;
        }
        if (!tileHasTreeOverlay(neighborTile)) {
          continue;
        }
        if (isTreeOverlayKey(neighborTile.hillOverlay)) {
          neighborTile.hillOverlay = null;
        }
        if (neighborTile.overlay !== cutTreeOverlayKey) {
          neighborTile.overlay = cutTreeOverlayKey;
        }
      }
    }
  };

  for (let y = 0; y < mapHeight; y += 1) {
    const row = tiles[y];
    if (!row) {
      continue;
    }
    for (let x = 0; x < mapWidth; x += 1) {
      const tile = row[x];
      if (!tile) {
        continue;
      }
      tile.culturalInfluence = null;
      tile.ambientStructure = null;
      if (tile.culturalInfluenceScores) {
        delete tile.culturalInfluenceScores;
      }
    }
  }

  const radiusByLocation = new Map();
  if (Array.isArray(factions)) {
    factions.forEach((faction) => {
      const capitalX = Number.isFinite(faction?.capital?.x) ? Math.floor(faction.capital.x) : null;
      const capitalY = Number.isFinite(faction?.capital?.y) ? Math.floor(faction.capital.y) : null;
      if (capitalX === null || capitalY === null) {
        return;
      }
      const claimRadius = Number.isFinite(faction?.claimRadius) ? faction.claimRadius : null;
      if (claimRadius === null) {
        return;
      }
      const key = `${capitalX},${capitalY}`;
      radiusByLocation.set(key, claimRadius);
    });
  }

  const raceMetadata = new Map();
  const culturalSources = [];
  const isLandFn = typeof isLandBaseTile === 'function' ? isLandBaseTile : null;

  const ensureRaceMetadata = (key, label, color) => {
    if (!key) {
      return;
    }
    if (!raceMetadata.has(key)) {
      raceMetadata.set(key, { label, color });
    }
  };

  const addCulturalSource = ({ x, y, radius, entries, falloff, tileFilter }) => {
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      return;
    }
    if (!Array.isArray(entries) || entries.length === 0) {
      return;
    }
    const normalizedEntries = entries
      .map((entry) => {
        if (!entry || !entry.key) {
          return null;
        }
        const share = clamp(Number(entry.share), 0, 1);
        if (share <= 0) {
          return null;
        }
        const label = typeof entry.label === 'string' && entry.label.trim() ? entry.label.trim() : formatCultureLabel(entry.key);
        const color = resolveCultureColor(entry.color, entry.key);
        ensureRaceMetadata(entry.key, label, color);
        return { key: entry.key, share, label, color };
      })
      .filter(Boolean);

    if (normalizedEntries.length === 0) {
      return;
    }

    const effectiveFalloff = falloff > 0 ? falloff : 1.35;
    const effectiveRadius = Number.isFinite(radius) ? Math.max(6, radius) : 8;

    culturalSources.push({
      x,
      y,
      radius: effectiveRadius,
      entries: normalizedEntries,
      falloff: effectiveFalloff,
      tileFilter: typeof tileFilter === 'function' ? tileFilter : null
    });
  };

  const isTileWater = (tile) => {
    if (!tile) {
      return false;
    }
    if (isLandFn) {
      return !isLandFn(tile.base);
    }
    if (typeof tile.base === 'string') {
      const baseKey = tile.base.toUpperCase();
      if (baseKey.includes('WATER') || baseKey.includes('OCEAN') || baseKey.includes('SEA')) {
        return true;
      }
    }
    return false;
  };

  const isTileLand = (tile) => {
    if (!tile) {
      return false;
    }
    if (isLandFn) {
      return Boolean(isLandFn(tile.base));
    }
    if (typeof tile.base === 'string') {
      return !isTileWater(tile);
    }
    return true;
  };

  const tileTouchesWater = (tx, ty) => {
    if (tx < 0 || ty < 0 || tx >= mapWidth || ty >= mapHeight) {
      return false;
    }
    for (let dy = -1; dy <= 1; dy += 1) {
      const ny = ty + dy;
      if (ny < 0 || ny >= mapHeight) {
        continue;
      }
      const row = tiles[ny];
      if (!row) {
        continue;
      }
      for (let dx = -1; dx <= 1; dx += 1) {
        const nx = tx + dx;
        if (nx < 0 || nx >= mapWidth) {
          continue;
        }
        const neighbor = row[nx];
        if (isTileWater(neighbor)) {
          return true;
        }
      }
    }
    return false;
  };

  if (Array.isArray(settlements)) {
    settlements.forEach((settlement) => {
      const rawX = Number.isFinite(settlement?.x) ? Math.floor(settlement.x) : null;
      const rawY = Number.isFinite(settlement?.y) ? Math.floor(settlement.y) : null;
      if (rawX === null || rawY === null) {
        return;
      }
      if (rawX < 0 || rawY < 0 || rawX >= mapWidth || rawY >= mapHeight) {
        return;
      }

      const breakdownSource = Array.isArray(settlement?.populationBreakdown)
        ? settlement.populationBreakdown
        : getDefaultCulturalBreakdownForSettlement(settlement);
      if (!Array.isArray(breakdownSource) || breakdownSource.length === 0) {
        return;
      }

      const entries = breakdownSource
        .map((entry) => {
          const key = normaliseCultureKey(entry?.key, entry?.label);
          const share = clamp(Number(entry?.percentage) / 100, 0, 1);
          if (!key || share <= 0) {
            return null;
          }
          const label =
            typeof entry?.label === 'string' && entry.label.trim()
              ? entry.label.trim()
              : formatCultureLabel(key);
          const color = resolveCultureColor(entry?.color, key);
          return { key, share, label, color };
        })
        .filter(Boolean);

      if (entries.length === 0) {
        return;
      }

      const type = typeof settlement?.type === 'string' ? settlement.type : null;
      const locationKey = `${rawX},${rawY}`;
      const baseClaimRadius = radiusByLocation.get(locationKey) || resolveFallbackClaimRadius(type);
      const multiplier = resolveCulturalRadiusMultiplier(type);
      const radius = Math.max(8, baseClaimRadius * multiplier);
      const falloff = resolveCulturalFalloffPower(type);

      addCulturalSource({
        x: rawX,
        y: rawY,
        radius,
        entries,
        falloff
      });
    });
  }

  const ambientSeedBase = Number.isFinite(seedNumber) ? seedNumber >>> 0 : 0;
  const forestAmbientSeed = (ambientSeedBase + 0x6d2b79f5) >>> 0;
  const forestRadiusSeed = (ambientSeedBase + 0x1b873593) >>> 0;
  const forestCultureSeed = (ambientSeedBase + 0xe6546b64) >>> 0;
  const mountainAmbientSeed = (ambientSeedBase + 0x85ebca6b) >>> 0;
  const mountainRadiusSeed = (ambientSeedBase + 0xc2b2ae35) >>> 0;
  const mountainCultureSeed = (ambientSeedBase + 0x27d4eb2f) >>> 0;
  const mountainDragonSeed = (ambientSeedBase + 0x3c8bfbbd) >>> 0;
  const mountainDragonRadiusSeed = (ambientSeedBase + 0x1ed558b3) >>> 0;
  const marshAmbientSeed = (ambientSeedBase + 0x4cf5ad43) >>> 0;
  const marshRadiusSeed = (ambientSeedBase + 0x94d049bb) >>> 0;
  const marshCultureSeed = (ambientSeedBase + 0xcbf29ce4) >>> 0;
  const grasslandAmbientSeed = (ambientSeedBase + 0x243f6a88) >>> 0;
  const grasslandRadiusSeed = (ambientSeedBase + 0x13198a2e) >>> 0;
  const grasslandCultureSeed = (ambientSeedBase + 0x98badcfe) >>> 0;
  const badlandsAmbientSeed = (ambientSeedBase + 0xd56f0b27) >>> 0;
  const badlandsRadiusSeed = (ambientSeedBase + 0x68b57a19) >>> 0;
  const badlandsCultureSeed = (ambientSeedBase + 0x243f6a9b) >>> 0;
  const jungleAmbientSeed = (ambientSeedBase + 0x9e3779b9) >>> 0;
  const jungleRadiusSeed = (ambientSeedBase + 0x7f4a7c15) >>> 0;
  const desertAmbientSeed = (ambientSeedBase + 0x6a09e667) >>> 0;
  const desertRadiusSeed = (ambientSeedBase + 0xbb67ae85) >>> 0;
  const tundraAmbientSeed = (ambientSeedBase + 0x4ed8aa4a) >>> 0;
  const tundraRadiusSeed = (ambientSeedBase + 0xa953fd4e) >>> 0;
  const halflingHillAmbientSeed = (ambientSeedBase + 0x1cf11a13) >>> 0;
  const halflingHillRadiusSeed = (ambientSeedBase + 0xf5a5a6b9) >>> 0;
  const humanAmbientSeed = (ambientSeedBase + 0x7f4a7c15) >>> 0;
  const humanRadiusSeed = (ambientSeedBase + 0x3ad29c47) >>> 0;
  const ambientStructurePlacementSeedBase = (ambientSeedBase + 0x8155c0de) >>> 0;
  const ambientStructureSelectionSeedBase = (ambientSeedBase + 0x51a26c1f) >>> 0;

  const humanInfluenceThresholdByBiome = {
    forest: 0.0011,
    jungle: 0.0013,
    grassland: 0.0014,
    desert: 0.00075,
    badlands: 0.0009,
    marsh: 0.001,
    lake: 0,
    ocean: 0
  };

  const minorFolkCatalog = [
    { key: 'elwetritsch', label: 'Elwetritsch', biomes: ['forest', 'grassland', 'mountain'] },
    { key: 'karkinos', label: 'Karkinos', biomes: ['ocean', 'lake', 'marsh'] },
    { key: 'blemaayae', label: 'Blemaayae', biomes: ['desert', 'badlands', 'jungle', 'mountain'] },
    { key: 'pygmy', label: 'Pygmy', biomes: ['jungle'] },
    { key: 'half_orcs', label: 'Half-Orcs', biomes: ['grassland', 'badlands', 'desert'] },
    { key: 'half_elves', label: 'Half-Elves', biomes: ['forest', 'grassland'] },
    { key: 'dryad', label: 'Dryad', biomes: ['forest', 'marsh', 'lake'] },
    { key: 'leshy', label: 'Leshy', biomes: ['forest', 'marsh'] },
    { key: 'satyr', label: 'Satyr', biomes: ['forest', 'grassland'] },
    { key: 'hobgoblin', label: 'Hobgoblin', biomes: ['badlands', 'mountain', 'grassland'] },
    { key: 'locathah', label: 'Locathah', biomes: ['ocean', 'lake', 'marsh'] },
    { key: 'firbolg', label: 'Firbolg', biomes: ['forest', 'grassland'] },
    { key: 'aarakocra', label: 'Aarakocra', biomes: ['mountain', 'grassland'] },
    { key: 'braxat', label: 'Braxat', biomes: ['desert', 'badlands', 'jungle'] },
    { key: 'hadozee', label: 'Hadozee', biomes: ['ocean', 'jungle'] },
    { key: 'quillboar', label: 'Quillboar', biomes: ['badlands', 'desert', 'grassland'] }
  ];

  const defaultMinorFolkThreshold = 0.0011;
  const minorFolkThresholdByBiome = {
    forest: 0.0015,
    jungle: 0.0014,
    mountain: 0.0012,
    desert: 0.001,
    badlands: 0.0011,
    tundra: 0.0009,
    grassland: 0.0013,
    marsh: 0.0012,
    ocean: 0.00085,
    lake: 0.00095
  };

  const minorFolkAmbientSeed = (ambientSeedBase + 0x42f6a2d1) >>> 0;
  const minorFolkRadiusSeed = (ambientSeedBase + 0x27d4eb2f) >>> 0;
  const minorFolkSelectionSeed = (ambientSeedBase + 0x9932e1b5) >>> 0;

  const getMinorFolkOptionsForBiome = (biomeType) => {
    if (typeof biomeType !== 'string') {
      return minorFolkCatalog;
    }
    const trimmed = biomeType.trim();
    if (!trimmed) {
      return minorFolkCatalog;
    }
    const matches = minorFolkCatalog.filter((entry) => {
      if (!Array.isArray(entry.biomes) || entry.biomes.length === 0) {
        return true;
      }
      return entry.biomes.includes(trimmed);
    });
    return matches.length > 0 ? matches : minorFolkCatalog;
  };

  const tryAddMinorFolkInfluence = (x, y, biomeType) => {
    if (typeof biomeType !== 'string') {
      return;
    }
    const trimmed = biomeType.trim();
    if (!trimmed) {
      return;
    }
    const options = getMinorFolkOptionsForBiome(trimmed);
    if (!options || options.length === 0) {
      return;
    }
    const thresholdValue = minorFolkThresholdByBiome[trimmed];
    const threshold =
      typeof thresholdValue === 'number' && thresholdValue > 0 ? thresholdValue : defaultMinorFolkThreshold;
    const biomeHash = hashString32(trimmed);
    const roll = hashCoords(x, y, minorFolkAmbientSeed ^ biomeHash);
    if (roll >= threshold) {
      return;
    }
    const radiusRoll = hashCoords(x, y, minorFolkRadiusSeed ^ biomeHash);
    const radius = lerp(8, 18, radiusRoll);
    const selectionRoll = hashCoords(x, y, minorFolkSelectionSeed ^ biomeHash);
    const index = Math.floor(selectionRoll * options.length) % options.length;
    const selected = options[index] || options[0];
    if (!selected) {
      return;
    }
    addCulturalSource({
      x,
      y,
      radius,
      falloff: 1.31,
      entries: [
        {
          key: selected.key,
          share: 1,
          label: selected.label
        }
      ]
    });
  };

  const tryAddAmbientHumanInfluence = (x, y, biomeType, tile) => {
    if (!biomeType || biomeType === 'mountain' || biomeType === 'tundra') {
      return;
    }
    let threshold = humanInfluenceThresholdByBiome[biomeType];
    if (!Number.isFinite(threshold) || threshold <= 0) {
      threshold = 0.0012;
    }
    const coastalBonus = clamp(Number(tile?.coastProximity) || 0, 0, 1);
    if (coastalBonus > 0) {
      threshold += coastalBonus * 0.0006;
    }
    const roll = hashCoords(x, y, humanAmbientSeed);
    if (roll >= threshold) {
      return;
    }
    const radiusRoll = hashCoords(x, y, humanRadiusSeed);
    const radius = lerp(10, 22, radiusRoll);
    addCulturalSource({
      x,
      y,
      radius,
      falloff: 1.32,
      entries: [
        {
          key: 'humans',
          share: 1,
          label: 'Humans'
        }
      ]
    });
  };
  const beastmanAmbientBaseSeed = (ambientSeedBase + 0xb5297a4d) >>> 0;
  const beastmanRadiusBaseSeed = (ambientSeedBase + 0x9e3779b1) >>> 0;

  const defaultBeastmanAmbientConfig = {
    threshold: 0.0019,
    radiusRange: [11, 22],
    falloff: 1.33
  };

  const beastmanAmbientConfigByBiome = {
    jungle: { threshold: 0.0026, radiusRange: [12, 24], falloff: 1.34 },
    desert: { threshold: 0.0021, radiusRange: [11, 22], falloff: 1.32 },
    badlands: { threshold: 0.002, radiusRange: [11, 21], falloff: 1.32 },
    marsh: { threshold: 0.0024, radiusRange: [11, 22], falloff: 1.33 },
    grassland: { threshold: 0.002, radiusRange: [11, 23], falloff: 1.32 },
    ocean: { threshold: 0.0012, radiusRange: [10, 20], falloff: 1.35 },
    lake: { threshold: 0.0014, radiusRange: [9, 18], falloff: 1.34 }
  };

  const beastmanSeedCache = new Map();
  const getBeastmanSeedsForBiome = (type) => {
    if (!type) {
      return {
        ambient: beastmanAmbientBaseSeed,
        radius: beastmanRadiusBaseSeed
      };
    }
    if (!beastmanSeedCache.has(type)) {
      const typeHash = hashString32(type);
      const radiusHash = hashString32(`${type}:radius`);
      beastmanSeedCache.set(type, {
        ambient: beastmanAmbientBaseSeed ^ typeHash,
        radius: beastmanRadiusBaseSeed ^ radiusHash
      });
    }
    return beastmanSeedCache.get(type);
  };
  const ambientStructureSeedCache = new Map();
  const getAmbientStructureSeedsForCulture = (cultureKey) => {
    const key = typeof cultureKey === 'string' && cultureKey.trim() ? cultureKey.trim().toLowerCase() : 'others';
    if (!ambientStructureSeedCache.has(key)) {
      const placementHash = hashString32(key);
      const selectionHash = hashString32(`${key}:selection`);
      ambientStructureSeedCache.set(key, {
        placement: ambientStructurePlacementSeedBase ^ placementHash,
        selection: ambientStructureSelectionSeedBase ^ selectionHash
      });
    }
    return ambientStructureSeedCache.get(key);
  };
  const waterAmbientSeed = (ambientSeedBase + 0x3c6ef35f) >>> 0;
  const waterRadiusSeed = (ambientSeedBase + 0xa54ff53a) >>> 0;
  const demonAmbientSeed = (ambientSeedBase + 0x1f83d9ab) >>> 0;
  const demonRadiusSeed = (ambientSeedBase + 0x5be0cd19) >>> 0;
  const caveDragonAmbientSeed = (ambientSeedBase + 0x2c1b2138) >>> 0;
  const caveDragonRadiusSeed = (ambientSeedBase + 0x297a2d39) >>> 0;

  for (let y = 0; y < mapHeight; y += 1) {
    const row = tiles[y];
    if (!row) {
      continue;
    }
    for (let x = 0; x < mapWidth; x += 1) {
      const tile = row[x];
      if (!tile) {
        continue;
      }

      const structureType =
        typeof tile?.structureDetails?.type === 'string' ? tile.structureDetails.type : null;
      if (structureType === 'dungeon' || structureType === 'evilWizardTower') {
        const roll = hashCoords(x, y, demonAmbientSeed);
        if (roll < 0.62) {
          const radiusRoll = hashCoords(x, y, demonRadiusSeed);
          const radius = lerp(11, 23, radiusRoll);
          addCulturalSource({
            x,
            y,
            radius,
            falloff: 1.38,
            entries: [
              {
                key: 'demons',
                share: 1,
                label: 'Demons'
              }
            ]
          });
        }
      } else if (structureType === 'cave') {
        const roll = hashCoords(x, y, caveDragonAmbientSeed);
        if (roll < 0.0018) {
          const radiusRoll = hashCoords(x, y, caveDragonRadiusSeed);
          const radius = lerp(10, 20, radiusRoll);
          addCulturalSource({
            x,
            y,
            radius,
            falloff: 1.37,
            entries: [
              {
                key: 'dragons',
                share: 1,
                label: 'Dragons'
              }
            ]
          });
        }
      }

      const biomeType = tile.biomeType;
      if (biomeType) {
        tryAddMinorFolkInfluence(x, y, biomeType);
      }

      const landTile = isTileLand(tile);
      if (!landTile) {
        const waterRoll = hashCoords(x, y, waterAmbientSeed);
        if (waterRoll < 0.0045) {
          const radiusRoll = hashCoords(x, y, waterRadiusSeed);
          const radius = lerp(8, 16, radiusRoll);
          const merfolkFilter = (candidate, tx, ty) => {
            if (!candidate) {
              return false;
            }
            if (isTileWater(candidate)) {
              return true;
            }
            return tileTouchesWater(tx, ty);
          };
          addCulturalSource({
            x,
            y,
            radius,
            falloff: 1.32,
            entries: [
              {
                key: 'merfolks',
                share: 1,
                label: 'Merfolks'
              }
            ],
            tileFilter: merfolkFilter
          });
        }
        continue;
      }

      if (!biomeType) {
        continue;
      }

      tryAddAmbientHumanInfluence(x, y, biomeType, tile);

      if (biomeType === 'forest') {
        const canopy = clamp(Number(tile.forestCanopyDensity) || 0, 0, 1);
        const threshold = 0.0015 + canopy * 0.0035;
        const roll = hashCoords(x, y, forestAmbientSeed);
        if (roll < threshold) {
          const radiusRoll = hashCoords(x, y, forestRadiusSeed);
          const radius = lerp(12, 24, radiusRoll);
          const cultureRoll = hashCoords(x, y, forestCultureSeed);
          const isFae = cultureRoll < 0.4;
          addCulturalSource({
            x,
            y,
            radius,
            falloff: 1.34,
            entries: [
              {
                key: isFae ? 'fae' : 'beastmen',
                share: 1,
                label: isFae ? 'Fae' : 'Beastmen'
              }
            ]
          });
        }
        continue;
      }

      if (biomeType === 'jungle') {
        const roll = hashCoords(x, y, jungleAmbientSeed);
        if (roll < 0.0034) {
          const radiusRoll = hashCoords(x, y, jungleRadiusSeed);
          const radius = lerp(12, 24, radiusRoll);
          addCulturalSource({
            x,
            y,
            radius,
            falloff: 1.34,
            entries: [
              {
                key: 'snakemen',
                share: 1,
                label: 'Snakemen'
              }
            ]
          });
        }
        continue;
      }

      if (biomeType === 'mountain') {
        const dragonRoll = hashCoords(x, y, mountainDragonSeed);
        if (dragonRoll < 0.00085) {
          const radiusRoll = hashCoords(x, y, mountainDragonRadiusSeed);
          const radius = lerp(14, 26, radiusRoll);
          addCulturalSource({
            x,
            y,
            radius,
            falloff: 1.4,
            entries: [
              {
                key: 'dragons',
                share: 1,
                label: 'Dragons'
              }
            ]
          });
        }
        const roll = hashCoords(x, y, mountainAmbientSeed);
        if (roll < 0.0035) {
          const radiusRoll = hashCoords(x, y, mountainRadiusSeed);
          const radius = lerp(10, 20, radiusRoll);
          const cultureRoll = hashCoords(x, y, mountainCultureSeed);
          let key = 'gnomes';
          let label = 'Gnomes';
          if (cultureRoll < 0.22) {
            key = 'gnomes';
            label = 'Gnomes';
          } else if (cultureRoll < 0.47) {
            key = 'ogres';
            label = 'Ogres';
          } else if (cultureRoll < 0.72) {
            key = 'trolls';
            label = 'Trolls';
          } else if (cultureRoll < 0.88) {
            key = 'harpies';
            label = 'Harpies';
          } else {
            key = 'giants';
            label = 'Giants';
          }

          addCulturalSource({
            x,
            y,
            radius,
            falloff: 1.36,
            entries: [
              {
                key,
                share: 1,
                label
              }
            ]
          });
        }
        continue;
      }

      if (biomeType === 'grassland') {
        const roll = hashCoords(x, y, grasslandAmbientSeed);
        if (roll < 0.0028) {
          const radiusRoll = hashCoords(x, y, grasslandRadiusSeed);
          const radius = lerp(11, 23, radiusRoll);
          const cultureRoll = hashCoords(x, y, grasslandCultureSeed);
          const cultures = [
            { key: 'centaurs', label: 'Centaurs' },
            { key: 'gnolls', label: 'Gnolls' },
            { key: 'quilboar', label: 'Quilboar' }
          ];
          const index = Math.floor(cultureRoll * cultures.length) % cultures.length;
          const selected = cultures[index] || cultures[0];
          addCulturalSource({
            x,
            y,
            radius,
            falloff: 1.31,
            entries: [
              {
                key: selected.key,
                share: 1,
                label: selected.label
              }
            ]
          });
        }
      }

      if (biomeType === 'tundra') {
        const roll = hashCoords(x, y, tundraAmbientSeed);
        if (roll < 0.0029) {
          const radiusRoll = hashCoords(x, y, tundraRadiusSeed);
          const radius = lerp(10, 22, radiusRoll);
          addCulturalSource({
            x,
            y,
            radius,
            falloff: 1.32,
            entries: [
              {
                key: 'tuskar',
                share: 1,
                label: 'Tuskar'
              }
            ]
          });
        }
        continue;
      }

      if (biomeType === 'desert') {
        const roll = hashCoords(x, y, desertAmbientSeed);
        if (roll < 0.0026) {
          const radiusRoll = hashCoords(x, y, desertRadiusSeed);
          const radius = lerp(11, 23, radiusRoll);
          addCulturalSource({
            x,
            y,
            radius,
            falloff: 1.32,
            entries: [
              {
                key: 'snakemen',
                share: 1,
                label: 'Snakemen'
              }
            ]
          });
        }
        continue;
      }

      if (biomeType === 'badlands') {
        const roll = hashCoords(x, y, badlandsAmbientSeed);
        if (roll < 0.0032) {
          const radiusRoll = hashCoords(x, y, badlandsRadiusSeed);
          const radius = lerp(11, 21, radiusRoll);
          const cultureRoll = hashCoords(x, y, badlandsCultureSeed);
          const cultures = [
            { key: 'centaurs', label: 'Centaurs' },
            { key: 'gnolls', label: 'Gnolls' },
            { key: 'quilboar', label: 'Quilboar' }
          ];
          const index = Math.floor(cultureRoll * cultures.length) % cultures.length;
          const selected = cultures[index] || cultures[0];
          addCulturalSource({
            x,
            y,
            radius,
            falloff: 1.31,
            entries: [
              {
                key: selected.key,
                share: 1,
                label: selected.label
              }
            ]
          });
        }
      }

      if (biomeType === 'marsh') {
        const roll = hashCoords(x, y, marshAmbientSeed);
        if (roll < 0.0038) {
          const radiusRoll = hashCoords(x, y, marshRadiusSeed);
          const radius = lerp(12, 22, radiusRoll);
          const cultureRoll = hashCoords(x, y, marshCultureSeed);
          const isFimir = cultureRoll >= 0.5;
          addCulturalSource({
            x,
            y,
            radius,
            falloff: 1.33,
            entries: [
              {
                key: isFimir ? 'fimir' : 'ogres',
                share: 1,
                label: isFimir ? 'Fimir' : 'Ogres'
              }
            ]
          });
        }
      }

      if (biomeType !== 'forest' && biomeType !== 'mountain' && biomeType !== 'tundra') {
        const config = beastmanAmbientConfigByBiome[biomeType] || defaultBeastmanAmbientConfig;
        const seeds = getBeastmanSeedsForBiome(biomeType);
        const roll = hashCoords(x, y, seeds.ambient);
        if (roll < config.threshold) {
          const radiusRoll = hashCoords(x, y, seeds.radius);
          const [minRadius, maxRadius] = Array.isArray(config.radiusRange) && config.radiusRange.length === 2
            ? config.radiusRange
            : defaultBeastmanAmbientConfig.radiusRange;
          const radius = lerp(minRadius, maxRadius, radiusRoll);
          addCulturalSource({
            x,
            y,
            radius,
            falloff: Number.isFinite(config.falloff) ? config.falloff : defaultBeastmanAmbientConfig.falloff,
            entries: [
              {
                key: 'beastmen',
                share: 1,
                label: 'Beastmen'
              }
            ]
          });
        }
      }

      const hasHillOverlay = isHillOverlayKey(tile.overlay) || isHillOverlayKey(tile.hillOverlay);
      if (hasHillOverlay) {
        const hillMountainSearchRadius = 4;
        let nearMountain = false;
        for (let dy = -hillMountainSearchRadius; dy <= hillMountainSearchRadius && !nearMountain; dy += 1) {
          const ny = y + dy;
          if (ny < 0 || ny >= mapHeight) {
            continue;
          }
          for (let dx = -hillMountainSearchRadius; dx <= hillMountainSearchRadius; dx += 1) {
            const nx = x + dx;
            if (nx < 0 || nx >= mapWidth) {
              continue;
            }
            const neighbor = tiles[ny]?.[nx];
            if (!neighbor) {
              continue;
            }
            if (isMountainOverlayKey(neighbor.overlay) || isMountainOverlayKey(neighbor.hillOverlay)) {
              nearMountain = true;
              break;
            }
          }
        }

        if (nearMountain) {
          const roll = hashCoords(x, y, halflingHillAmbientSeed);
          if (roll < 0.0011) {
            const radiusRoll = hashCoords(x, y, halflingHillRadiusSeed);
            const radius = lerp(9, 18, radiusRoll);
            addCulturalSource({
              x,
              y,
              radius,
              falloff: 1.29,
              entries: [
                {
                  key: 'halflings',
                  share: 1,
                  label: 'Halflings'
                }
              ]
            });
          }
        }
      }
    }
  }

  if (culturalSources.length === 0) {
    return;
  }

  for (let i = 0; i < culturalSources.length; i += 1) {
    const { x, y, radius, entries, falloff, tileFilter } = culturalSources[i];
    const radiusSquared = radius * radius;
    const minX = Math.max(0, Math.floor(x - radius));
    const maxX = Math.min(mapWidth - 1, Math.ceil(x + radius));
    const minY = Math.max(0, Math.floor(y - radius));
    const maxY = Math.min(mapHeight - 1, Math.ceil(y + radius));

    for (let ty = minY; ty <= maxY; ty += 1) {
      const row = tiles[ty];
      if (!row) {
        continue;
      }
      for (let tx = minX; tx <= maxX; tx += 1) {
        const tile = row[tx];
        if (!tile) {
          continue;
        }
        const land = isTileLand(tile);
        let passesFilter = true;
        if (tileFilter) {
          passesFilter = tileFilter(tile, tx, ty) === true;
        }
        if (!land) {
          if (!tileFilter || !passesFilter) {
            continue;
          }
        } else if (tileFilter && !passesFilter) {
          continue;
        }
        const dx = tx - x;
        const dy = ty - y;
        const distanceSquared = dx * dx + dy * dy;
        if (distanceSquared > radiusSquared) {
          continue;
        }
        const distance = Math.sqrt(distanceSquared);
        const proximity = clamp(1 - distance / radius, 0, 1);
        if (proximity <= 0) {
          continue;
        }
        const influenceFactor = Math.pow(proximity, falloff);
        if (influenceFactor <= 0) {
          continue;
        }
        let store = tile.culturalInfluenceScores;
        if (!store) {
          store = Object.create(null);
          tile.culturalInfluenceScores = store;
        }
        for (let j = 0; j < entries.length; j += 1) {
          const entry = entries[j];
          const contribution = entry.share * influenceFactor;
          if (contribution <= 0) {
            continue;
          }
          store[entry.key] = (store[entry.key] || 0) + contribution;
        }
      }
    }
  }

  for (let y = 0; y < mapHeight; y += 1) {
    const row = tiles[y];
    if (!row) {
      continue;
    }
    for (let x = 0; x < mapWidth; x += 1) {
      const tile = row[x];
      if (!tile) {
        continue;
      }
      const scores = tile.culturalInfluenceScores;
      if (!scores) {
        tile.culturalInfluence = null;
        continue;
      }
      const keys = Object.keys(scores);
      if (keys.length === 0) {
        tile.culturalInfluence = null;
        delete tile.culturalInfluenceScores;
        continue;
      }
      let bestKey = null;
      let bestScore = 0;
      let totalScore = 0;
      const breakdown = [];

      for (let i = 0; i < keys.length; i += 1) {
        const key = keys[i];
        const score = Number(scores[key]) || 0;
        if (score <= 0) {
          continue;
        }
        totalScore += score;
        breakdown.push({ key, score });
        if (score > bestScore) {
          bestScore = score;
          bestKey = key;
        }
      }

      if (!bestKey || bestScore <= 0) {
        tile.culturalInfluence = null;
        delete tile.culturalInfluenceScores;
        continue;
      }

      breakdown.sort((a, b) => b.score - a.score);
      const dominantMeta = raceMetadata.get(bestKey) || {
        label: formatCultureLabel(bestKey),
        color: resolveCultureColor(null, bestKey)
      };
      const dominantStrength = clamp(bestScore, 0, 1);
      const normalizedBreakdown =
        totalScore > 0
          ? breakdown.map((entry) => {
              const meta = raceMetadata.get(entry.key) || {
                label: formatCultureLabel(entry.key),
                color: resolveCultureColor(null, entry.key)
              };
              return {
                key: entry.key,
                label: meta.label,
                color: meta.color,
                strength: clamp(entry.score, 0, 1),
                share: clamp(entry.score / totalScore, 0, 1)
              };
            })
          : [];

      tile.culturalInfluence = {
        key: bestKey,
        label: dominantMeta.label,
        color: dominantMeta.color,
        strength: dominantStrength,
        breakdown: normalizedBreakdown
      };

      delete tile.culturalInfluenceScores;
    }
  }

  const fallbackAmbientOptions = ambientStructureOptionsByCulture.others || [];
  for (let y = 0; y < mapHeight; y += 1) {
    const row = tiles[y];
    if (!row) {
      continue;
    }
    for (let x = 0; x < mapWidth; x += 1) {
      const tile = row[x];
      if (!tile || tile.ambientStructure || tile.structure || tile.river) {
        continue;
      }
      if (!isTileLand(tile)) {
        continue;
      }
      const influence = tile.culturalInfluence;
      if (!influence) {
        continue;
      }
      const cultureKey = typeof influence.key === 'string' ? influence.key : null;
      const strength = clamp(Number(influence.strength) || 0, 0, 1);
      if (strength < 0.08) {
        continue;
      }
      const options =
        ambientStructureOptionsByCulture[cultureKey] ||
        ambientStructureOptionsByCulture[cultureKey && cultureKey.replace(/[^a-z0-9]+/g, '_')] ||
        fallbackAmbientOptions;
      if (!Array.isArray(options) || options.length === 0) {
        continue;
      }
      const seeds = getAmbientStructureSeedsForCulture(cultureKey || 'others');
      const placementRoll = hashCoords(x, y, seeds.placement);
      const baseChance = 0.0015;
      const chance = baseChance + strength * 0.0075;
      if (placementRoll >= chance) {
        continue;
      }
      let adjacentToTreeCache = null;
      let isMountainTileCache = null;
      let hasForestOverlayCache = null;
      let hasTreeOverlayCache = null;
      const avoidWoodElfVicinity = isNearWoodElfTerritory(x, y);
      const eligibleOptions = options.filter((option) => {
        if (option.requiresTreeNeighbor) {
          if (adjacentToTreeCache === null) {
            adjacentToTreeCache = isTileAdjacentToTree(x, y);
          }
          return adjacentToTreeCache;
        }
        if (option.requiresTreeOverlay) {
          if (hasTreeOverlayCache === null) {
            hasTreeOverlayCache = tileHasTreeOverlay(tile);
          }
          return hasTreeOverlayCache;
        }
        if (option.requiresMountainOverlay) {
          if (isMountainTileCache === null) {
            isMountainTileCache =
              isMountainOverlayKey(tile.overlay) || isMountainOverlayKey(tile.hillOverlay);
          }
          return isMountainTileCache;
        }
        if (option.disallowForestOverlay) {
          if (hasForestOverlayCache === null) {
            hasForestOverlayCache =
              isTreeOverlayKey(tile.overlay) || isTreeOverlayKey(tile.hillOverlay);
          }
          return !hasForestOverlayCache;
        }
        if (avoidWoodElfVicinity && option.key === 'lumber_mill') {
          return false;
        }
        return true;
      });
      if (eligibleOptions.length === 0) {
        continue;
      }
      const selectionRoll = hashCoords(x, y, seeds.selection);
      const index = Math.floor(selectionRoll * eligibleOptions.length) % eligibleOptions.length;
      const option = eligibleOptions[index] || eligibleOptions[0];
      if (!option) {
        continue;
      }

      const ambientStructureData = {
        key: option.key,
        label: option.label,
        culture: cultureKey || 'others',
        cultureLabel:
          (typeof influence.label === 'string' && influence.label.trim()) ||
          formatCultureLabel(cultureKey || 'others')
      };

      const assignAmbientStructureToTile = (structureKey) => {
        tile.structure = structureKey;
        tile.structureName = option.label;
        tile.structureDetails = {
          isAmbientStructure: true,
          ambientStructure: ambientStructureData,
          displayType: option.label
        };
      };

      if (option.key === 'lumber_mill') {
        assignAmbientStructureToTile('AMBIENT_LUMBER_MILL');
        replaceTreesNearLumberMill(x, y);
      } else if (option.key === 'homestead') {
        assignAmbientStructureToTile('AMBIENT_HOMESTEAD');
      } else if (option.key === 'sleeping_dragon') {
        assignAmbientStructureToTile('AMBIENT_SLEEPING_DRAGON');
      } else if (option.key === 'great_tree') {
        const variantSeed = (seeds.selection + 0x9e3779b9) >>> 0;
        const variantRoll = hashCoords(x, y, variantSeed);
        const hasAltGreatTree = tileLookup.has('AMBIENT_GREAT_TREE_ALT');
        const structureKey =
          hasAltGreatTree && variantRoll >= 0.5 ? 'AMBIENT_GREAT_TREE_ALT' : 'AMBIENT_GREAT_TREE';
        assignAmbientStructureToTile(structureKey);
      } else if (option.key === 'moonwell_glade' || option.key === 'moonwell') {
        assignAmbientStructureToTile('AMBIENT_MOONWELL');
      }

      tile.ambientStructure = ambientStructureData;
    }
  }
}

function resolveTileName(baseKey) {
  return tileLookup.has(baseKey) ? baseKey : 'GRASS';
}

const landMaskCache = new Map();

function normalizeHighlightValue(value) {
  if (typeof value !== 'string') {
    return '';
  }
  const trimmed = value.trim();
  return trimmed ? trimmed.toUpperCase() : '';
}

function normalizeHighlightList(values = []) {
  return values
    .map((value) => normalizeHighlightValue(value))
    .filter((value) => value.length > 0);
}

function collapseHighlightValue(value) {
  return value.replace(/[^A-Z0-9]/g, '');
}

function createHighlightGroup({
  label,
  color,
  strokeColor,
  fillAlpha,
  strokeAlpha,
  keys = [],
  types = [],
  nameTokens = []
}) {
  const normalizedKeys = normalizeHighlightList(keys);
  const normalizedKeyTokens = normalizedKeys.map((value) => collapseHighlightValue(value));
  const normalizedTypes = normalizeHighlightList(types);
  const normalizedTypeTokens = normalizedTypes.map((value) => collapseHighlightValue(value));
  const normalizedNameTokens = normalizeHighlightList(nameTokens);
  const collapsedNameTokens = normalizedNameTokens.map((value) => collapseHighlightValue(value));

  return {
    label,
    color,
    strokeColor,
    fillAlpha,
    strokeAlpha,
    keys: new Set(normalizedKeys),
    normalizedKeyTokens: new Set(normalizedKeyTokens),
    types: new Set(normalizedTypes),
    normalizedTypeTokens: new Set(normalizedTypeTokens),
    nameTokens: normalizedNameTokens,
    normalizedNameTokens: collapsedNameTokens
  };
}

const structureHighlightGroups = {
  dwarfhold: createHighlightGroup({
    label: 'Dwarven Holds',
    color: '#f59e0b',
    strokeColor: '#fbbf24',
    fillAlpha: 0.28,
    strokeAlpha: 0.92,
    keys: ['DWARFHOLD', 'GREAT_DWARFHOLD', 'ABANDONED_DWARFHOLD', 'DARK_DWARFHOLD'],
    types: [
      'dwarfhold',
      'greatDwarfhold',
      'abandonedDwarfhold',
      'ruinedDwarfhold',
      'occupiedDwarfhold',
      'darkDwarfhold'
    ]
  }),
  hillhold: createHighlightGroup({
    label: 'Hillholds',
    color: '#fb7185',
    strokeColor: '#f9a8d4',
    fillAlpha: 0.26,
    strokeAlpha: 0.88,
    keys: ['HILLHOLD'],
    types: ['hillhold']
  }),
  humanSettlement: createHighlightGroup({
    label: 'Human Settlements',
    color: '#ef4444',
    strokeColor: '#f87171',
    fillAlpha: 0.24,
    strokeAlpha: 0.85,
    keys: ['TOWN', 'PORT_TOWN', 'HAMLET', 'HAMLET_SNOW'],
    types: ['city', 'town', 'village']
  }),
  woodElfGrove: createHighlightGroup({
    label: 'Wood Elf Groves',
    color: '#22c55e',
    strokeColor: '#4ade80',
    fillAlpha: 0.26,
    strokeAlpha: 0.88,
    keys: woodElfGroveStructureKeys.filter((key) => tileLookup.has(key)),
    types: ['woodElfGrove']
  }),
  lizardmenCity: createHighlightGroup({
    label: 'Lizardmen Cities',
    color: '#06b6d4',
    strokeColor: '#22d3ee',
    fillAlpha: 0.26,
    strokeAlpha: 0.88,
    keys: ['LIZARDMEN_CITY'],
    types: ['lizardmenCity']
  }),
  mine: createHighlightGroup({
    label: 'Mines',
    color: '#f97316',
    strokeColor: '#fb923c',
    fillAlpha: 0.28,
    strokeAlpha: 0.9,
    keys: ['MINE'],
    types: ['mine']
  }),
  dam: createHighlightGroup({
    label: 'Dams',
    color: '#38bdf8',
    strokeColor: '#7dd3fc',
    fillAlpha: 0.24,
    strokeAlpha: 0.85,
    keys: ['DAM'],
    types: ['dam']
  }),
  tower: createHighlightGroup({
    label: 'Towers',
    color: '#2563eb',
    strokeColor: '#60a5fa',
    fillAlpha: 0.26,
    strokeAlpha: 0.88,
    keys: ['TOWER', 'EVIL_WIZARDS_TOWER'],
    types: ['tower', 'evilWizardTower']
  }),
  camp: createHighlightGroup({
    label: 'Camps & Encampments',
    color: '#16a34a',
    strokeColor: '#4ade80',
    fillAlpha: 0.24,
    strokeAlpha: 0.85,
    keys: [
      'ORC_CAMP',
      'GNOLL_CAMP',
      'TROLL_CAMP',
      'OGRE_CAMP',
      'BANDIT_CAMP',
      'TRAVELERS_CAMP',
      'CENTAUR_ENCAMPMENT'
    ],
    types: ['orcCamp', 'gnollCamp', 'trollCamp', 'ogreCamp', 'banditCamp', 'travelerCamp', 'centaurEncampment']
  }),
  dungeon: createHighlightGroup({
    label: 'Dungeons',
    color: '#6366f1',
    strokeColor: '#818cf8',
    fillAlpha: 0.26,
    strokeAlpha: 0.9,
    keys: ['DUNGEON'],
    types: ['dungeon']
  }),
  cave: createHighlightGroup({
    label: 'Caves',
    color: '#a855f7',
    strokeColor: '#c084fc',
    fillAlpha: 0.26,
    strokeAlpha: 0.88,
    keys: ['CAVE'],
    types: ['cave']
  }),
  castle: createHighlightGroup({
    label: 'Castles',
    color: '#f97316',
    strokeColor: '#fdba74',
    fillAlpha: 0.24,
    strokeAlpha: 0.85,
    keys: ['CASTLE'],
    types: ['castle']
  }),
  monastery: createHighlightGroup({
    label: 'Monasteries',
    color: '#eab308',
    strokeColor: '#fde047',
    fillAlpha: 0.24,
    strokeAlpha: 0.85,
    keys: ['MONASTERY'],
    types: ['monastery']
  }),
  saintShrine: createHighlightGroup({
    label: 'Saint Shrines',
    color: '#d946ef',
    strokeColor: '#f0abfc',
    fillAlpha: 0.26,
    strokeAlpha: 0.88,
    keys: ['SAINT_SHRINE'],
    types: ['saintShrine']
  }),
  tavern: createHighlightGroup({
    label: 'Roadside Taverns',
    color: '#f472b6',
    strokeColor: '#f9a8d4',
    fillAlpha: 0.24,
    strokeAlpha: 0.85,
    keys: ['ROADSIDE_TAVERN'],
    types: ['roadsideTavern']
  }),
  homestead: createHighlightGroup({
    label: 'Homesteads',
    color: '#84cc16',
    strokeColor: '#bef264',
    fillAlpha: 0.2,
    strokeAlpha: 0.75,
    keys: ['AMBIENT_FARM', 'AMBIENT_FARM_VARIANT', 'AMBIENT_HUNTING_LODGE', 'AMBIENT_HOMESTEAD'],
    types: ['farm', 'huntingLodge', 'homestead']
  })
};

const structureHighlightTypeKeys = Object.keys(structureHighlightGroups);

let lastStructureHighlightMenuSignature = null;

function syncStructureHighlightMenuOptions(menu) {
  if (!menu || typeof document === 'undefined') {
    return;
  }
  const signature = structureHighlightTypeKeys
    .map((key) => {
      const group = structureHighlightGroups[key];
      const label = group && typeof group.label === 'string' ? group.label : '';
      const color = group && typeof group.color === 'string' ? group.color : '';
      return `${key}:${label}:${color}`;
    })
    .join('|');
  if (signature === lastStructureHighlightMenuSignature) {
    return;
  }
  lastStructureHighlightMenuSignature = signature;

  const existingOptions = menu.querySelectorAll('.structure-highlight-option');
  existingOptions.forEach((option) => option.remove());

  const fragment = document.createDocumentFragment();
  structureHighlightTypeKeys.forEach((typeKey) => {
    const group = structureHighlightGroups[typeKey];
    if (!group) {
      return;
    }
    const optionId = `highlight-structure-${typeKey}`;
    const label = document.createElement('label');
    label.className = 'structure-highlight-option';
    label.setAttribute('for', optionId);
    label.setAttribute('data-highlight-option', typeKey);
    if (group.color) {
      label.style.setProperty('--highlight-color', group.color);
    }

    const input = document.createElement('input');
    input.type = 'checkbox';
    input.id = optionId;
    input.name = optionId;
    input.setAttribute('data-highlight-type', typeKey);

    const swatch = document.createElement('span');
    swatch.className = 'structure-highlight-option__swatch';
    swatch.setAttribute('aria-hidden', 'true');

    const text = document.createElement('span');
    text.className = 'structure-highlight-option__label';
    text.textContent = group.label || typeKey;

    label.appendChild(input);
    label.appendChild(swatch);
    label.appendChild(text);
    fragment.appendChild(label);
  });

  const hint = menu.querySelector('.structure-highlight-menu__hint');
  if (hint && hint.parentNode === menu) {
    menu.insertBefore(fragment, hint.nextSibling);
  } else {
    menu.appendChild(fragment);
  }
}

let loadingProgressValue = 0;
let loadingProgressIntervalId = null;
let hasManualLoadingProgress = false;

const localViewConfig = {
  radius: 4,
  baseScale: 3,
  minScale: 2,
  maxCanvasSize: 768,
  highResolutionTileSubdivisions: 4,
  highResolutionExtraPadding: 2,
  highResolutionMinScale: 2,
  highResolutionMaxTileSize: 28,
  minZoom: 0.5,
  maxZoom: 3,
  zoomStep: 0.2,
  defaultZoom: 1,
  absoluteMinScale: 0.5,
  structureScaleCap: 1
};

const {
  state,
  ensureMapEditorState,
  refreshMapEditorUI,
  toggleMapEditor,
  closeMapEditor,
  setMapEditorTerrainKey,
  setMapEditorStructureKey,
  setMapEditorApplyTerrain,
  setMapEditorApplyStructure,
  setMapEditorBrushSize,
  clearMapEditorStructure,
  applyMapEditorPaint,
  ensureStructureHighlightState
} = createStateModule({
  tileSheets,
  defaultMapSize,
  defaultForestFrequency,
  defaultMountainFrequency,
  defaultWorldGenerationType,
  localViewConfig,
  clamp,
  elements,
  hideStructureContextMenu,
  hideMapTooltip,
  drawWorld,
  structureHighlightGroups,
  structureHighlightTypeKeys,
  baseTileCoords,
  documentRef: typeof document !== 'undefined' ? document : null
});

// customizerDeps will be defined after dwarfOptions and helper functions
let customizerDeps = null;

function computeFrequencyMultiplier(frequency) {
  // Convert frequency (0-100) to multiplier (0.5 to 2.0)
  // 50 (default) = 1.0, 0 = 0.5, 100 = 2.0
  const normalized = clamp(frequency / 100, 0, 1);
  return 0.5 + normalized * 1.5;
}

function sampleRange(rng, range, defaultMin, defaultMax) {
  if (!rng || typeof rng !== 'function') {
    rng = Math.random;
  }
  let min = defaultMin;
  let max = defaultMax;
  if (Array.isArray(range) && range.length >= 2) {
    if (Number.isFinite(range[0])) {
      min = range[0];
    }
    if (Number.isFinite(range[1])) {
      max = range[1];
    }
  } else if (Number.isFinite(range)) {
    return range;
  }
  if (!Number.isFinite(min) || !Number.isFinite(max)) {
    min = defaultMin;
    max = defaultMax;
  }
  if (max <= min) {
    return min;
  }
  return min + rng() * (max - min);
}

function computeDwarfholdDistributionAdjustment(x, y, height, seed) {
  // Create a deterministic spatial adjustment based on position and seed
  // This helps distribute dwarfholds more evenly across the map
  if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(height) || height <= 0) {
    return 0;
  }
  if (!Number.isFinite(seed)) {
    seed = 0;
  }
  
  // Create a hash-like value from position and seed
  const hash = ((x * 73856093) ^ (y * 19349663) ^ (seed * 83492791)) >>> 0;
  const normalized = (hash % 1000000) / 1000000;
  
  // Use normalized y position to create vertical distribution bias
  const verticalBias = (y / height) * 2 - 1; // -1 to 1
  
  // Combine hash-based noise with slight vertical bias
  // The adjustment should be small relative to typical scores
  const noise = (normalized - 0.5) * 0.15; // -0.075 to 0.075
  const verticalAdjustment = verticalBias * 0.05; // -0.05 to 0.05
  
  return noise + verticalAdjustment;
}

function computeStructurePlacementLimit(baseTarget, maxLimit, multiplier) {
  // Calculate the maximum number of structures to place
  // baseTarget: base number calculated from candidate count
  // maxLimit: hard maximum cap
  // multiplier: frequency multiplier (typically 0.5 to 2.0)
  if (!Number.isFinite(baseTarget) || baseTarget <= 0) {
    baseTarget = 1;
  }
  if (!Number.isFinite(maxLimit) || maxLimit <= 0) {
    maxLimit = 1;
  }
  if (!Number.isFinite(multiplier) || multiplier <= 0) {
    multiplier = 1;
  }
  
  // Apply multiplier and clamp to maxLimit, ensure minimum of 1
  const adjusted = baseTarget * multiplier;
  return Math.max(1, Math.min(Math.round(adjusted), maxLimit));
}

function computeAbandonedDwarfholdChance(frequencyNormalized) {
  // Calculate the chance that a dwarfhold will be abandoned
  // frequencyNormalized: normalized settlement frequency (0 to 1)
  // Lower frequency = higher chance of abandonment (more ruins)
  // Higher frequency = lower chance of abandonment (more active holds)
  if (!Number.isFinite(frequencyNormalized)) {
    frequencyNormalized = 0.5;
  }
  const clamped = clamp(frequencyNormalized, 0, 1);
  
  // Inverse relationship: low frequency (0) = high abandonment chance (0.35)
  // high frequency (1) = low abandonment chance (0.05)
  const minChance = 0.05;
  const maxChance = 0.35;
  
  // Linear interpolation: chance decreases as frequency increases
  const chance = maxChance - (clamped * (maxChance - minChance));
  
  return clamp(chance, minChance, maxChance);
}

function adjustMinDistance(baseDistance, frequencyNormalized) {
  // Adjust minimum distance between settlements based on frequency
  // baseDistance: base minimum distance
  // frequencyNormalized: normalized settlement frequency (0 to 1)
  // Higher frequency = smaller min distance (settlements can be closer)
  // Lower frequency = larger min distance (settlements stay farther apart)
  if (!Number.isFinite(baseDistance) || baseDistance <= 0) {
    return 6;
  }
  if (!Number.isFinite(frequencyNormalized)) {
    frequencyNormalized = 0.5;
  }
  const clamped = clamp(frequencyNormalized, 0, 1);
  
  // When frequency is high (1.0), reduce distance by 30% (multiply by 0.7)
  // When frequency is low (0.0), increase distance by 20% (multiply by 1.2)
  const minMultiplier = 0.7;
  const maxMultiplier = 1.2;
  
  // Linear interpolation: multiplier decreases as frequency increases
  const multiplier = maxMultiplier - (clamped * (maxMultiplier - minMultiplier));
  
  const adjusted = baseDistance * multiplier;
  return Math.max(1, Math.round(adjusted));
}

function computeNearestDistanceSq(x, y, points) {
  // Compute squared distance to nearest point in array
  if (!Number.isFinite(x) || !Number.isFinite(y) || !Array.isArray(points) || points.length === 0) {
    return Infinity;
  }
  let minDistSq = Infinity;
  for (let i = 0; i < points.length; i += 1) {
    const point = points[i];
    if (!point || !Number.isFinite(point.x) || !Number.isFinite(point.y)) {
      continue;
    }
    const dx = x - point.x;
    const dy = y - point.y;
    const distSq = dx * dx + dy * dy;
    if (distSq < minDistSq) {
      minDistSq = distSq;
    }
  }
  return minDistSq;
}

function findNearestPointWithDetails(x, y, points) {
  // Find nearest point and return it with distance information
  if (!Number.isFinite(x) || !Number.isFinite(y) || !Array.isArray(points) || points.length === 0) {
    return null;
  }
  let nearest = null;
  let minDistSq = Infinity;
  for (let i = 0; i < points.length; i += 1) {
    const point = points[i];
    if (!point || !Number.isFinite(point.x) || !Number.isFinite(point.y)) {
      continue;
    }
    const dx = x - point.x;
    const dy = y - point.y;
    const distSq = dx * dx + dy * dy;
    if (distSq < minDistSq) {
      minDistSq = distSq;
      nearest = point;
    }
  }
  if (!nearest) {
    return null;
  }
  return {
    ...nearest,
    distance: Math.sqrt(minDistSq),
    distanceSq: minDistSq
  };
}

function isMountainOverlay(overlay) {
  // Check if overlay is a mountain type
  if (!overlay || typeof overlay !== 'string') {
    return false;
  }
  return isMountainOverlayKey(overlay);
}

function escapeHtml(text) {
  // Escape HTML special characters to prevent XSS
  if (text == null || text === undefined) {
    return '';
  }
  const str = String(text);
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function findPathBetweenPoints(startX, startY, endX, endY, options) {
  // Simple line-based pathfinding between two points on a grid
  // Returns array of {x, y} coordinates or null if no path found
  if (!Number.isFinite(startX) || !Number.isFinite(startY) || 
      !Number.isFinite(endX) || !Number.isFinite(endY)) {
    return null;
  }
  
  const {
    tiles,
    width,
    height,
    waterMask,
    isLandBaseTile,
    maxDistance
  } = options || {};
  
  if (!Array.isArray(tiles) || !Number.isFinite(width) || !Number.isFinite(height)) {
    return null;
  }
  
  // Check if start/end are valid
  if (startX < 0 || startX >= width || startY < 0 || startY >= height ||
      endX < 0 || endX >= width || endY < 0 || endY >= height) {
    return null;
  }
  
  // Check if start/end are on land
  const startIdx = startY * width + startX;
  const endIdx = endY * width + endX;
  if (waterMask && (waterMask[startIdx] || waterMask[endIdx])) {
    return null;
  }
  
  const startTile = tiles[startY] && tiles[startY][startX];
  const endTile = tiles[endY] && tiles[endY][endX];
  if (!startTile || !endTile) {
    return null;
  }
  
  if (isLandBaseTile && (!isLandBaseTile(startTile.base) || !isLandBaseTile(endTile.base))) {
    return null;
  }
  
  // Simple distance check
  const dx = endX - startX;
  const dy = endY - startY;
  const distSq = dx * dx + dy * dy;
  if (Number.isFinite(maxDistance) && distSq > maxDistance * maxDistance) {
    return null;
  }
  
  // Simple line drawing algorithm (Bresenham's line algorithm)
  const path = [];
  let x0 = Math.round(startX);
  let y0 = Math.round(startY);
  let x1 = Math.round(endX);
  let y1 = Math.round(endY);
  
  const dx1 = Math.abs(x1 - x0);
  const dy1 = Math.abs(y1 - y0);
  const sx = x0 < x1 ? 1 : -1;
  const sy = y0 < y1 ? 1 : -1;
  let err = dx1 - dy1;
  
  let x = x0;
  let y = y0;
  
  while (true) {
    // Check if tile is valid
    if (x >= 0 && x < width && y >= 0 && y < height) {
      const idx = y * width + x;
      if (!waterMask || !waterMask[idx]) {
        const tile = tiles[y] && tiles[y][x];
        if (tile && (!isLandBaseTile || isLandBaseTile(tile.base))) {
          path.push({ x, y });
        }
      }
    }
    
    if (x === x1 && y === y1) {
      break;
    }
    
    const e2 = 2 * err;
    if (e2 > -dy1) {
      err -= dy1;
      x += sx;
    }
    if (e2 < dx1) {
      err += dx1;
      y += sy;
    }
  }
  
  return path.length > 0 ? path : null;
}

function connectTownsWithinRange(tiles, settlements, options) {
  // Connect settlements within maxDistance using roads
  // settlements: array of {x, y, ...} objects
  // options: {maxDistance, overlayKey, width, height, isLandBaseTile, waterMask, replaceableOverlays, ...}
  if (!Array.isArray(tiles) || !Array.isArray(settlements) || settlements.length < 2) {
    return;
  }
  
  const {
    maxDistance = 25,
    overlayKey = 'TOWN_ROAD',
    width,
    height,
    isLandBaseTile,
    waterMask,
    replaceableOverlays
  } = options || {};
  
  if (!Number.isFinite(width) || !Number.isFinite(height) || !Number.isFinite(maxDistance)) {
    return;
  }
  
  // Find all pairs of settlements within maxDistance
  const connections = [];
  for (let i = 0; i < settlements.length; i += 1) {
    const from = settlements[i];
    if (!from || !Number.isFinite(from.x) || !Number.isFinite(from.y)) {
      continue;
    }
    
    for (let j = i + 1; j < settlements.length; j += 1) {
      const to = settlements[j];
      if (!to || !Number.isFinite(to.x) || !Number.isFinite(to.y)) {
        continue;
      }
      
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const distSq = dx * dx + dy * dy;
      const dist = Math.sqrt(distSq);
      
      if (dist <= maxDistance) {
        connections.push({ from, to, dist });
      }
    }
  }
  
  // Sort by distance (connect closer settlements first)
  connections.sort((a, b) => a.dist - b.dist);
  
  // Connect settlements with paths
  const connectedPairs = new Set();
  for (let i = 0; i < connections.length; i += 1) {
    const { from, to } = connections[i];
    const fromKey = `${from.x},${from.y}`;
    const toKey = `${to.x},${to.y}`;
    const pairKey = `${fromKey}-${toKey}`;
    const reversePairKey = `${toKey}-${fromKey}`;
    
    // Skip if already connected
    if (connectedPairs.has(pairKey) || connectedPairs.has(reversePairKey)) {
      continue;
    }
    
    // Find path between settlements
    const path = findPathBetweenPoints(from.x, from.y, to.x, to.y, {
      tiles,
      width,
      height,
      waterMask,
      isLandBaseTile,
      maxDistance
    });
    
    if (!path || path.length === 0) {
      continue;
    }
    
    // Mark as connected
    connectedPairs.add(pairKey);
    
    // Place road overlay on path tiles
    for (let p = 0; p < path.length; p += 1) {
      const { x, y } = path[p];
      if (x < 0 || x >= width || y < 0 || y >= height) {
        continue;
      }
      
      const row = tiles[y];
      if (!Array.isArray(row)) {
        continue;
      }
      const tile = row[x];
      if (!tile) {
        continue;
      }
      
      // Skip if already has a road
      if (tile.overlay === overlayKey) {
        continue;
      }
      
      // Skip if tile has a structure (don't overwrite structures)
      if (tile.structure) {
        continue;
      }
      
      // Replace replaceable overlays (trees, hills) with road
      if (replaceableOverlays && replaceableOverlays.has(tile.overlay)) {
        tile.overlay = overlayKey;
      } else if (!tile.overlay) {
        // Only place road on empty overlay tiles
        tile.overlay = overlayKey;
      }
    }
  }
}

function tryPlaceDwarfhold(candidate, context) {
  // Attempt to place a dwarfhold at the candidate location
  // candidate: { x, y, score, biomeType, areaName, biomeClusterId, ... }
  // context: placement context with tiles, keys, chances, etc.
  // Returns: true if placed, false otherwise
  if (!candidate || !Number.isFinite(candidate.x) || !Number.isFinite(candidate.y)) {
    return false;
  }
  if (!context || !Array.isArray(context.tiles) || !Array.isArray(context.placed)) {
    return false;
  }
  
  const { x, y } = candidate;
  const {
    tiles,
    width,
    height,
    waterMask,
    placed,
    minDistanceSq,
    dwarfholdKey,
    darkDwarfholdKey,
    greatDwarfholdKey,
    abandonedDwarfholdKey,
    abandonedDwarfholdChance,
    rng,
    dwarfholds,
    towns,
    nearbyTownDistanceSq,
    darkDwarfholdVolcanoRadius
  } = context;
  
  // Check bounds
  if (x < 0 || x >= width || y < 0 || y >= height) {
    return false;
  }
  
  // Check water
  const idx = y * width + x;
  if (waterMask && waterMask[idx]) {
    return false;
  }
  
  // Check tile
  const row = tiles[y];
  if (!Array.isArray(row)) {
    return false;
  }
  const tile = row[x];
  if (!tile || tile.structure || tile.river) {
    return false;
  }
  
  // Check minimum distance from other placed dwarfholds
  if (Number.isFinite(minDistanceSq) && minDistanceSq > 0) {
    for (let i = 0; i < placed.length; i += 1) {
      const other = placed[i];
      if (!other || !Number.isFinite(other.x) || !Number.isFinite(other.y)) {
        continue;
      }
      const dx = x - other.x;
      const dy = y - other.y;
      const distSq = dx * dx + dy * dy;
      if (distSq < minDistanceSq) {
        return false;
      }
    }
  }
  
  // Check distance from towns
  if (Number.isFinite(nearbyTownDistanceSq) && nearbyTownDistanceSq > 0 && Array.isArray(towns)) {
    for (let i = 0; i < towns.length; i += 1) {
      const town = towns[i];
      if (!town || !Number.isFinite(town.x) || !Number.isFinite(town.y)) {
        continue;
      }
      const dx = x - town.x;
      const dy = y - town.y;
      const distSq = dx * dx + dy * dy;
      if (distSq < nearbyTownDistanceSq) {
        return false;
      }
    }
  }
  
  // Determine hold type
  const randomFn = rng || Math.random;
  let structureKey = dwarfholdKey;
  let isAbandoned = false;
  let isDark = false;
  let isGreat = false;
  
  // Check for dark dwarfhold (near volcano)
  if (darkDwarfholdKey && darkDwarfholdVolcanoRadius) {
    const volcanoRadiusSq = darkDwarfholdVolcanoRadius * darkDwarfholdVolcanoRadius;
    for (let ty = Math.max(0, y - darkDwarfholdVolcanoRadius); ty <= Math.min(height - 1, y + darkDwarfholdVolcanoRadius); ty += 1) {
      for (let tx = Math.max(0, x - darkDwarfholdVolcanoRadius); tx <= Math.min(width - 1, x + darkDwarfholdVolcanoRadius); tx += 1) {
        const checkTile = tiles[ty] && tiles[ty][tx];
        if (checkTile && isVolcanoOverlayKey(checkTile.overlay)) {
          const dx = tx - x;
          const dy = ty - y;
          if (dx * dx + dy * dy <= volcanoRadiusSq) {
            isDark = true;
            structureKey = darkDwarfholdKey;
            break;
          }
        }
      }
      if (isDark) {
        break;
      }
    }
  }
  
  // Check for great dwarfhold (high score)
  if (!isDark && greatDwarfholdKey && candidate.score > 0.75) {
    const greatRoll = randomFn();
    if (greatRoll < 0.15) {
      isGreat = true;
      structureKey = greatDwarfholdKey;
    }
  }
  
  // Check for abandoned dwarfhold
  if (!isDark && !isGreat && abandonedDwarfholdKey && Number.isFinite(abandonedDwarfholdChance)) {
    const abandonRoll = randomFn();
    if (abandonRoll < abandonedDwarfholdChance) {
      isAbandoned = true;
      structureKey = abandonedDwarfholdKey;
    }
  }
  
  if (!structureKey) {
    return false;
  }
  
  // Generate name and details
  const name = generateDwarfholdName(randomFn);
  const nearestHoldInfo = findNearestPointWithDetails(x, y, dwarfholds || []);
  const hasNearbyHumanSettlement = Array.isArray(towns) && towns.length > 0 && 
    computeNearestDistanceSq(x, y, towns) < (nearbyTownDistanceSq || Infinity);
  
  const details = generateDwarfholdDetails(name, randomFn, {
    isAbandoned,
    isDarkHold: isDark,
    isGreatHold: isGreat,
    nearestDwarfhold: nearestHoldInfo,
    hasNearbyHumanSettlement
  });
  
  // Place the structure
  tile.structure = structureKey;
  tile.structureName = name;
  tile.structureDetails = details;
  
  // Add to arrays
  placed.push(candidate);
  if (Array.isArray(dwarfholds)) {
    dwarfholds.push({ x, y, ...details });
  }
  
  return true;
}

function computeEuclideanDistanceField(mask, width, height) {
  if (!mask || !Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
    return new Float32Array(0);
  }
  const size = width * height;
  const distanceField = new Float32Array(size);
  
  // Initialize: set distance to 0 for source pixels, infinity for others
  for (let i = 0; i < size; i += 1) {
    distanceField[i] = mask[i] ? 0 : Number.MAX_VALUE;
  }
  
  // Two-pass Euclidean distance transform
  // First pass: left-to-right, top-to-bottom
  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      if (distanceField[idx] === 0) {
        continue;
      }
      let minDist = distanceField[idx];
      
      // Check left neighbor
      if (x > 0) {
        const leftIdx = idx - 1;
        const dist = distanceField[leftIdx] + 1;
        if (dist < minDist) {
          minDist = dist;
        }
      }
      
      // Check top neighbor
      if (y > 0) {
        const topIdx = idx - width;
        const dist = distanceField[topIdx] + 1;
        if (dist < minDist) {
          minDist = dist;
        }
      }
      
      // Check top-left diagonal
      if (x > 0 && y > 0) {
        const diagIdx = idx - width - 1;
        const dist = distanceField[diagIdx] + Math.SQRT2;
        if (dist < minDist) {
          minDist = dist;
        }
      }
      
      // Check top-right diagonal
      if (x < width - 1 && y > 0) {
        const diagIdx = idx - width + 1;
        const dist = distanceField[diagIdx] + Math.SQRT2;
        if (dist < minDist) {
          minDist = dist;
        }
      }
      
      distanceField[idx] = minDist;
    }
  }
  
  // Second pass: right-to-left, bottom-to-top
  for (let y = height - 1; y >= 0; y -= 1) {
    for (let x = width - 1; x >= 0; x -= 1) {
      const idx = y * width + x;
      if (distanceField[idx] === 0) {
        continue;
      }
      let minDist = distanceField[idx];
      
      // Check right neighbor
      if (x < width - 1) {
        const rightIdx = idx + 1;
        const dist = distanceField[rightIdx] + 1;
        if (dist < minDist) {
          minDist = dist;
        }
      }
      
      // Check bottom neighbor
      if (y < height - 1) {
        const bottomIdx = idx + width;
        const dist = distanceField[bottomIdx] + 1;
        if (dist < minDist) {
          minDist = dist;
        }
      }
      
      // Check bottom-left diagonal
      if (x > 0 && y < height - 1) {
        const diagIdx = idx + width - 1;
        const dist = distanceField[diagIdx] + Math.SQRT2;
        if (dist < minDist) {
          minDist = dist;
        }
      }
      
      // Check bottom-right diagonal
      if (x < width - 1 && y < height - 1) {
        const diagIdx = idx + width + 1;
        const dist = distanceField[diagIdx] + Math.SQRT2;
        if (dist < minDist) {
          minDist = dist;
        }
      }
      
      distanceField[idx] = minDist;
    }
  }
  
  // Convert to squared distances (as expected by the code)
  for (let i = 0; i < size; i += 1) {
    const dist = distanceField[i];
    distanceField[i] = dist * dist;
  }
  
  return distanceField;
}

function sanitizeFrequencyValue(value, defaultValue) {
  if (typeof defaultValue !== 'number' || !Number.isFinite(defaultValue)) {
    defaultValue = 50;
  }
  const fallback = clamp(defaultValue, 0, 100);
  if (typeof value === 'string') {
    const parsed = Number.parseInt(value, 10);
    if (Number.isNaN(parsed)) {
      return fallback;
    }
    return clamp(parsed, 0, 100);
  }
  if (typeof value !== 'number' || !Number.isFinite(value)) {
    return fallback;
  }
  return clamp(value, 0, 100);
}

function updateFrequencyDisplay(element, value) {
  if (!element || typeof value !== 'number' || !Number.isFinite(value)) {
    return;
  }
  const clampedValue = clamp(value, 0, 100);
  const percentage = Math.round(clampedValue);
  let label = 'Balanced';
  if (clampedValue < 30) {
    label = 'Very Low';
  } else if (clampedValue < 40) {
    label = 'Low';
  } else if (clampedValue < 60) {
    label = 'Balanced';
  } else if (clampedValue < 75) {
    label = 'High';
  } else {
    label = 'Very High';
  }
  if (element && typeof element.textContent !== 'undefined') {
    element.textContent = `${percentage}% — ${label}`;
  }
}

const audioState = {
  isPlaying: false,
  currentIndex: 0,
  tracks: [],
  initialised: false,
  effectsMuted: false,
  effectsVolume: 0.6
};

const structureAmbienceState = {
  currentTrack: null
};

const soundEffects = {
  randomiseClick: null
};

function playSoundEffect(audio) {
  if (!audio || audioState.effectsMuted || audioState.effectsVolume <= 0) {
    return;
  }
  try {
    if (audio && typeof audio.play === 'function') {
      audio.volume = clamp(audioState.effectsVolume, 0, 1);
      audio.play().catch(() => {
        // Ignore playback errors
      });
    }
  } catch (error) {
    // Ignore sound effect errors
  }
}

function matchesHighlightGroupValue(value, group) {
  const normalized = normalizeHighlightValue(value);
  if (!normalized || !group) {
    return false;
  }
  const collapsed = collapseHighlightValue(normalized);
  if ((group.keys && group.keys.has(normalized)) || (group.normalizedKeyTokens && group.normalizedKeyTokens.has(collapsed))) {
    return true;
  }
  if ((group.types && group.types.has(normalized)) || (group.normalizedTypeTokens && group.normalizedTypeTokens.has(collapsed))) {
    return true;
  }
  if (Array.isArray(group.nameTokens) && group.nameTokens.some((token) => normalized.includes(token))) {
    return true;
  }
  if (
    Array.isArray(group.normalizedNameTokens) &&
    group.normalizedNameTokens.some((token) => collapsed.includes(token))
  ) {
    return true;
  }
  return false;
}

function doesTileMatchHighlightGroup(tile, group) {
  if (!tile || !group) {
    return false;
  }
  const details = tile.structureDetails || {};
  return (
    matchesHighlightGroupValue(tile.structure, group) ||
    matchesHighlightGroupValue(details.type, group) ||
    matchesHighlightGroupValue(details.settlementKind, group) ||
    matchesHighlightGroupValue(details.displayType, group) ||
    matchesHighlightGroupValue(details.structureType, group) ||
    matchesHighlightGroupValue(tile.structureName, group) ||
    matchesHighlightGroupValue(details.structureName, group)
  );
}

function getHighlightGroupForTile(tile, activeTypes) {
  if (!tile || !Array.isArray(activeTypes) || activeTypes.length === 0) {
    return null;
  }
  for (let i = 0; i < activeTypes.length; i += 1) {
    const typeKey = activeTypes[i];
    const group = structureHighlightGroups[typeKey];
    if (group && doesTileMatchHighlightGroup(tile, group)) {
      return typeKey;
    }
  }
  return null;
}

function drawStructureHighlightOverlay(ctx, tileX, tileY, tileSize, group) {
  if (!ctx || !group) {
    return;
  }
  const pixelX = tileX * tileSize;
  const pixelY = tileY * tileSize;
  const fillAlpha = clamp(Number(group.fillAlpha) || 0.24, 0.05, 1);
  const strokeAlpha = clamp(Number(group.strokeAlpha) || 0.85, 0.05, 1);
  const strokeColor = typeof group.strokeColor === 'string' && group.strokeColor ? group.strokeColor : group.color;
  ctx.save();
  ctx.fillStyle = group.color;
  ctx.globalAlpha = fillAlpha;
  ctx.fillRect(pixelX, pixelY, tileSize, tileSize);
  ctx.restore();

  ctx.save();
  ctx.strokeStyle = strokeColor;
  ctx.globalAlpha = strokeAlpha;
  const lineWidth = Math.max(1, Math.round(tileSize / 6));
  ctx.lineWidth = lineWidth;
  const inset = lineWidth / 2;
  ctx.strokeRect(pixelX + inset, pixelY + inset, tileSize - lineWidth, tileSize - lineWidth);
  ctx.restore();
}

const defaultDwarfCount = 1;
const defaultHairStyleValue = 'straight_shoulder';

const baseDwarfClanOptions = [
  { value: 'stonebeard', label: 'Stonebeard' },
  { value: 'barrelbrow', label: 'Barrelbrow' },
  { value: 'oathhammer', label: 'Oathhammer' },
  { value: 'stormshield', label: 'Stormshield' },
  { value: 'granitebrow', label: 'Granitebrow' },
  { value: 'emberstone', label: 'Emberstone' },
  { value: 'blackdelve', label: 'Blackdelve' },
  { value: 'hearthhammer', label: 'Hearthhammer' },
  { value: 'mithrilbeard', label: 'Mithrilbeard' },
  { value: 'shieldbreaker', label: 'Shieldbreaker' },
  { value: 'deepcrag', label: 'Deepcrag' },
  { value: 'duskhollow', label: 'Duskhollow' },
  { value: 'hammerdeep', label: 'Hammerdeep' },
  { value: 'deepmantle', label: 'Deepmantle' },
  { value: 'ashmantle', label: 'Ashmantle' },
  { value: 'shadowhearth', label: 'Shadowhearth' },
  { value: 'angrund', label: 'Angrund — royal clan of Karak Eight Peaks' },
  { value: 'angrulok', label: 'Angrulok — royal clan of Karak Kadrin' },
  { value: 'badrikk', label: 'Badrikk — Karak Azul; metalsmiths' },
  { value: 'barruk', label: 'Barruk — North of Karag Dron; miners' },
  { value: 'burrdrik', label: 'Burrdrik — Karak Azul; metalsmiths' },
  { value: 'bronzebeards', label: 'Bronzebeards — Karak Norn; cannon-makers' },
  { value: 'bronzefist', label: 'Bronzefist — Karak Eight Peaks; lode wardens' },
  { value: 'copperback', label: 'Copperback — Karak Eight Peaks; miners' },
  { value: 'cragbrow_barak_varr_engineers', label: 'Cragbrow — Barak Varr; engineers' },
  { value: 'cragbrow_karak_azul_miners', label: 'Cragbrow — Karak Azul; miners' },
  { value: 'craghand', label: 'Craghand — Karak Eight Peaks; miners' },
  { value: 'cragtooth', label: 'Cragtooth — Karak Azgaraz; ?' },
  { value: 'donarkhun', label: 'Donarkhun — royal clan of Karak Azul' },
  { value: 'dourback', label: 'Dourback — Karak Eight Peaks; brewers' },
  { value: 'dragonback', label: 'Dragonback — Ekrund; clan of Josef Bugman' },
  { value: 'drakebeard', label: 'Drakebeard — royal clan of Karak Kadrin' },
  { value: 'drazhkarak', label: 'Drazhkarak — royal clan of Karak Hirn' },
  { value: 'dunrakin', label: 'Dunrakin — Karak Azul; brewers' },
  { value: 'firehand', label: 'Firehand — Karak Azul; metalsmiths' },
  { value: 'firehelm', label: 'Firehelm — Karak Eight Peaks; miners' },
  { value: 'flintbeard', label: 'Flintbeard — Karak Azgaraz; ?' },
  { value: 'flinthand_karak_azul_engineers', label: 'Flinthand — Karak Azul; engineers' },
  { value: 'flinthand_k8p_miners', label: 'Flinthand — Karak Eight Peaks; miners' },
  { value: 'flintheart', label: 'Flintheart — Karak Eight Peaks; metalsmiths' },
  { value: 'fooger', label: 'Fooger — Expatriate; merchants' },
  { value: 'forgehand', label: 'Forgehand — Karak Azul; runesmiths' },
  { value: 'grimhelm', label: 'Grimhelm — Karak Azgaraz; ?' },
  { value: 'grimstone', label: 'Grimstone — Karak Eight Peaks; prospectors' },
  { value: 'growlsh', label: "Growlsh — infamous drinkers; disgraced after failing to protect High King Alrik Deathdealer's daughter" },
  { value: 'gunnarsson', label: 'Gunnarsson — unknown; possibly Barak Varr' },
  { value: 'gunnisson_first', label: 'Gunnisson (First contingent) — Karaz-a-Karak; warriors' },
  { value: 'gunnisson_second', label: 'Gunnisson (Second contingent) — destroyed attempting to reclaim Mount Silverspear' },
  { value: 'gunnisson_third', label: 'Gunnisson (Third contingent) — Itinerant; Orc-hunters' },
  { value: 'guttrik', label: 'Guttrik — Karak Eight Peaks; rope-makers' },
  { value: 'halgakrin', label: 'Halgakrin — Karak Azul; carpenters' },
  { value: 'hammerback', label: 'Hammerback — Karak Azgaraz; miners' },
  { value: 'helhein', label: 'Helhein — Karak Eight Peaks; warriors' },
  { value: 'irebeard', label: 'Irebeard — Karak Azgaraz; ?' },
  { value: 'ironbeard', label: 'Ironbeard — Karag Durak' },
  { value: 'ironarm', label: 'Ironarm — Karak Azgaraz; ?' },
  { value: 'ironback', label: 'Ironback — Karak Eight Peaks; miners' },
  { value: 'ironfinger', label: 'Ironfinger — Karak Azul; from Eight Peaks; metalsmiths' },
  { value: 'ironfist_cities', label: 'Ironfist — Metallschlacke, Neiderwind, Altdorf, Ubersreik' },
  { value: 'ironforge', label: 'Ironforge — Karak Azul; runesmiths' },
  { value: 'ironhammer', label: 'Ironhammer — Karak Azul; metalsmiths' },
  { value: 'ironpick', label: 'Ironpick — royal clan of Karak Norn' },
  { value: 'ironspike', label: 'Ironspike — Karak Eight Peaks; carpenters' },
  { value: 'izorgrung', label: 'Izorgrung — royal clan of Karak Izor' },
  { value: 'kaznagar', label: 'Kaznagar — Karak Azul; jewelsmiths' },
  { value: 'magrest', label: 'Magrest — Karak Kadrin; miners (possibly)' },
  { value: 'norgrimlings', label: 'Norgrimlings — Karak Eight Peaks; miners' },
  { value: 'oakbarrel', label: 'Oakbarrel — Neiderwind, Altdorf; brewers' },
  { value: 'redbeard', label: 'Redbeard — Karak Azul; runesmiths' },
  { value: 'silverscar', label: 'Silverscar — Karak Azgaraz; engineers' },
  { value: 'skorrun', label: 'Skorrun — Karak Azgal; foreign imports merchants' },
  { value: 'steelcrag', label: 'Steelcrag — Karak Azgaraz; ?' },
  { value: 'sternbeard', label: 'Sternbeard — Karak Azul' },
  { value: 'stoneback', label: 'Stoneback — Karak Eight Peaks; masons' },
  { value: 'stonebeard_k8p_engineers', label: 'Stonebeard — Karak Eight Peaks; engineers' },
  { value: 'stonebeater', label: 'Stonebeater — Karak Azul; masons' },
  { value: 'stonebreakers', label: 'Stonebreakers — Zhufbar; masons and miners' },
  { value: 'stonehammer_cities', label: 'Stonehammer — Neiderwind, Altdorf' },
  { value: 'stonehand', label: 'Stonehand — Karak Azul; masons' },
  { value: 'stoneheart', label: 'Stoneheart — Karak Azul; masons' },
  { value: 'stoutgirth', label: 'Stoutgirth — Karak Azul; brewers' },
  { value: 'stoutpeak', label: 'Stoutpeak — Karak Azul; carpenters' },
  { value: 'svengeln', label: 'Svengeln — Karak Azul; prospectors' },
  { value: 'threkkson', label: 'Threkkson — Karak Azul; lode wardens' },
  { value: 'thundergun', label: 'Thundergun — Metallschlacke, Altdorf' },
  { value: 'thunderheart', label: 'Thunderheart — Karak Azul; jewelsmiths' },
  { value: 'thunderstone', label: 'Thunderstone — Karak Azgaraz; runesmiths' },
  { value: 'ullek', label: 'Ullek (the Ullekssons) — Karaz-a-Karak; warriors' },
  { value: 'varnskan', label: 'Varnskan — Karak Azul; miners' },
  { value: 'vorgrund', label: 'Vorgrund — unknown; possibly Karak Kadrin' },
  { value: 'yinlinsson', label: 'Yinlinsson — Karaz-a-Karak; brewers' },
  { value: 'ironfist', label: 'Ironfist' },
  { value: 'coppervein', label: 'Coppervein' },
  { value: 'graniteheart', label: 'Graniteheart' },
  { value: 'deepdelver', label: 'Deepdelver' },
  { value: 'amberpick', label: 'Amberpick' },
  { value: 'oakenshield', label: 'Oakenshield' },
  { value: 'frosthammer', label: 'Frosthammer' },
  { value: 'berylbraid', label: 'Berylbraid' },
  { value: 'silverhollow', label: 'Silverhollow' },
  { value: 'brazenaxe', label: 'Brazenaxe' },
  { value: 'stormhammer', label: 'Stormhammer' },
  { value: 'deeprock', label: 'Deeprock' },
  { value: 'goldvein', label: 'Goldvein' },
  { value: 'runesmith', label: 'Runesmith' },
  { value: 'aleswiller', label: 'Aleswiller' },
  { value: 'argent_hand', label: 'Argent Hand' },
  { value: 'axebreaker', label: 'Axebreaker' },
  { value: 'blackfire', label: 'Blackfire' },
  { value: 'bloodstone', label: 'Bloodstone' },
  { value: 'boulderscorch', label: 'Boulderscorch' },
  { value: 'duergar', label: 'Duergar' },
  { value: 'fiania', label: 'Fiania' },
  { value: 'goldenforge', label: 'Goldenforge' },
  { value: 'gordemuncher', label: 'Gordemuncher' },
  { value: 'hammerhead', label: 'Hammerhead' },
  { value: 'ironson', label: 'Ironson' },
  { value: 'kazak_uruk', label: 'Kazak Uruk' },
  { value: 'orcsplitter', label: 'Orcsplitter' },
  { value: 'rockcrawler', label: 'Rockcrawler' },
  { value: 'shattered_stone', label: 'Shattered Stone' },
  { value: 'bronzebeard', label: 'Bronzebeard' },
  { value: 'stormpike', label: 'Stormpike' },
  { value: 'stonefist', label: 'Stonefist' },
  { value: 'hylar', label: 'Hylar' },
  { value: 'daergar', label: 'Daergar' },
  { value: 'daewar', label: 'Daewar' },
  { value: 'theiwar', label: 'Theiwar' },
  { value: 'aghar', label: 'Aghar' },
  { value: 'battlehammer', label: 'Battlehammer' },
  { value: 'bitterroot', label: 'Bitterroot' },
  { value: 'black_axe', label: 'Black Axe' },
  { value: 'boldenbar', label: 'Boldenbar' },
  { value: 'bouldershoulder', label: 'Bouldershoulder' },
  { value: 'brawnanvil', label: 'Brawnanvil' },
  { value: 'brightblade', label: 'Brightblade' },
  { value: 'brighthelm', label: 'Brighthelm' },
  { value: 'broodhull', label: 'Broodhull' },
  { value: 'bruenghor', label: 'Bruenghor' },
  { value: 'bukbukken', label: 'Bukbukken' },
  { value: 'chistlesmith', label: 'Chistlesmith' },
  { value: 'eaglecleft', label: 'Eaglecleft' },
  { value: 'flameshade', label: 'Flameshade' },
  { value: 'muzgardt', label: 'Muzgardt' },
  { value: 'stoneshaft', label: 'Stoneshaft' },
  { value: 'ticklebeard', label: 'Ticklebeard' },
  { value: 'dankil', label: 'Dankil' },
  { value: 'daraz', label: 'Daraz' },
  { value: 'forgebar', label: 'Forgebar' },
  { value: 'gemcrypt', label: 'Gemcrypt' },
  { value: 'girdaur', label: 'Girdaur' },
  { value: 'hammerhand', label: 'Hammerhand' },
  { value: 'hardhammer', label: 'Hardhammer' },
  { value: 'herlinga', label: 'Herlinga' },
  { value: 'hillborn', label: 'Hillborn' },
  { value: 'hillsafar', label: 'Hillsafar' },
  { value: 'horn', label: 'Horn' },
  { value: 'icehammer', label: 'Icehammer' },
  { value: 'ironeater', label: 'Ironeater' },
  { value: 'ironstar', label: 'Ironstar' },
  { value: 'licehair', label: 'Licehair' },
  { value: 'ludwakazar', label: 'Ludwakazar' },
  { value: 'madbeards', label: 'Madbeards' },
  { value: 'mcknuckles', label: 'McKnuckles' },
  { value: 'mcruff', label: 'McRuff' },
  { value: 'melairkyn', label: 'Melairkyn' },
  { value: 'orcsmasher', label: 'Orcsmasher' },
  { value: 'orothiar', label: 'Orothiar' },
  { value: 'pwent', label: 'Pwent' },
  { value: 'rockjaw', label: 'Rockjaw' },
  { value: 'rookoath', label: 'Rookoath' },
  { value: 'rustfire', label: 'Rustfire' },
  { value: 'sandbeards', label: 'Sandbeards' },
  { value: 'shattershield', label: 'Shattershield' },
  { value: 'stonebridge', label: 'Stonebridge' },
  { value: 'stoneshoulder', label: 'Stoneshoulder' },
  { value: 'stouthammer', label: 'Stouthammer' },
  { value: 'sunblight', label: 'Sunblight' },
  { value: 'undurr', label: 'Undurr' },
  { value: 'grimlock', label: 'Grimlock' },
  { value: 'maccloud', label: 'MacCloud' },
  { value: 'thundermore', label: 'Thundermore' },
  { value: 'enogtorad', label: 'Enogtorad' },
  { value: 'drummond', label: 'Drummond' },
  { value: 'tolorr', label: 'Tolorr' },
  { value: 'vanderholl', label: 'Vanderholl' },
  { value: 'aringeld', label: 'Aringeld' },
  { value: 'firecask', label: 'Firecask', description: 'Brewers and distillers.' },
  { value: 'gelderon', label: 'Gelderon' },
  { value: 'grimmark', label: 'Grimmark' },
  { value: 'molgrade', label: 'Molgrade', description: 'Smiths, traps, and locks.' },
  { value: 'runebinder', label: 'Runebinder', description: 'Arcane magic, particularly runes.' },
  { value: 'orridus_ironheart', label: 'Orridus Ironheart', description: 'Sages who focus on the dwarven pantheon.' },
  { value: 'shalefoot', label: 'Shalefoot' },
  { value: 'silverhair', label: 'Silverhair' },
  { value: 'copperlung_stonescar', label: 'Copperlung Stonescar' },
  { value: 'flintbristle', label: 'Flintbristle' },
  { value: 'spire_crag', label: 'Spire-Crag' },
  { value: 'stonehollow', label: 'Stonehollow' },
  { value: 'silverpick', label: 'Silverpick' },
  { value: 'ironheart', label: 'Ironheart' },
  { value: 'weoughld', label: 'Weoughld' },
  { value: 'llyrnillach', label: 'Llyrnillach' },
  { value: 'highhelm', label: 'Highhelm' }
];

const dwarfClanCategories = new Map([
  ['stonebeard', ['Hill Dwarf', 'Dark Dwarf', 'Grey Dwarf', 'Mountain Dwarf']],
  ['angrund', ['Hill Dwarf', 'Dark Dwarf', 'Grey Dwarf', 'Mountain Dwarf']],
  ['ironfist', ['Hill Dwarf', 'Dark Dwarf', 'Grey Dwarf', 'Mountain Dwarf']],
  ['oakenshield', ['Hill Dwarf', 'Dark Dwarf', 'Grey Dwarf', 'Mountain Dwarf']],
  ['runebinder', ['Hill Dwarf', 'Dark Dwarf', 'Grey Dwarf', 'Mountain Dwarf']],
  ['barrelbrow', ['Hill Dwarf', 'Mountain Dwarf']],
  ['hearthhammer', ['Hill Dwarf', 'Mountain Dwarf']],
  ['hammerback', ['Hill Dwarf', 'Mountain Dwarf']],
  ['stoneback', ['Hill Dwarf', 'Mountain Dwarf']],
  ['stonehand', ['Hill Dwarf', 'Mountain Dwarf']],
  ['stoneheart', ['Hill Dwarf', 'Mountain Dwarf']],
  ['stonebeater', ['Hill Dwarf', 'Mountain Dwarf']],
  ['stonebreakers', ['Hill Dwarf', 'Mountain Dwarf']],
  ['stonehammer_cities', ['Hill Dwarf', 'Mountain Dwarf']],
  ['stonebeard_k8p_engineers', ['Hill Dwarf', 'Mountain Dwarf']],
  ['stonefist', ['Hill Dwarf', 'Mountain Dwarf']],
  ['oakbarrel', ['Hill Dwarf']],
  ['hillborn', ['Hill Dwarf']],
  ['hillsafar', ['Hill Dwarf']],
  ['bitterroot', ['Hill Dwarf']],
  ['stonebridge', ['Hill Dwarf']],
  ['stonehollow', ['Hill Dwarf']],
  ['stoutgirth', ['Hill Dwarf']],
  ['stoutpeak', ['Hill Dwarf']],
  ['aleswiller', ['Hill Dwarf']],
  ['aghar', ['Hill Dwarf']],
  ['pwent', ['Hill Dwarf']],
  ['blackdelve', ['Dark Dwarf', 'Mountain Dwarf']],
  ['duskhollow', ['Dark Dwarf', 'Mountain Dwarf']],
  ['ashmantle', ['Dark Dwarf', 'Mountain Dwarf']],
  ['blackfire', ['Dark Dwarf', 'Mountain Dwarf']],
  ['bloodstone', ['Dark Dwarf', 'Mountain Dwarf']],
  ['boulderscorch', ['Dark Dwarf', 'Mountain Dwarf']],
  ['rustfire', ['Dark Dwarf', 'Mountain Dwarf']],
  ['shattered_stone', ['Dark Dwarf', 'Mountain Dwarf']],
  ['grimlock', ['Dark Dwarf', 'Mountain Dwarf']],
  ['growlsh', ['Dark Dwarf', 'Mountain Dwarf']],
  ['shadowhearth', ['Dark Dwarf']],
  ['sunblight', ['Dark Dwarf']],
  ['duergar', ['Grey Dwarf', 'Dark Dwarf']],
  ['daergar', ['Grey Dwarf', 'Dark Dwarf']],
  ['theiwar', ['Grey Dwarf', 'Dark Dwarf']],
  ['grimhelm', ['Grey Dwarf', 'Dark Dwarf']],
  ['grimstone', ['Grey Dwarf', 'Dark Dwarf']],
  ['melairkyn', ['Grey Dwarf', 'Dark Dwarf']],
  ['daewar', ['Grey Dwarf', 'Mountain Dwarf']],
  ['ironbeard', ['Grey Dwarf', 'Mountain Dwarf']],
  ['ironpick', ['Grey Dwarf', 'Mountain Dwarf']],
  ['silverhair', ['Grey Dwarf', 'Mountain Dwarf']],
  ['tolorr', ['Grey Dwarf', 'Mountain Dwarf']],
  ['emberstone', ['Grey Dwarf', 'Mountain Dwarf']],
  ['silverhollow', ['Grey Dwarf', 'Mountain Dwarf']],
  ['ironhammer', ['Grey Dwarf', 'Mountain Dwarf']],
  ['ironheart', ['Grey Dwarf', 'Mountain Dwarf']],
  ['goldvein', ['Grey Dwarf', 'Mountain Dwarf']],
  ['thunderstone', ['Grey Dwarf', 'Mountain Dwarf']]
]);

function getClanCategories(clanValue) {
  if (!clanValue) {
    return ['Mountain Dwarf'];
  }
  const categories = dwarfClanCategories.get(clanValue);
  return Array.isArray(categories) && categories.length > 0 ? categories : ['Mountain Dwarf'];
}

function addCategoriesToDwarfClanOptions(options) {
  if (!Array.isArray(options)) {
    return [];
  }
  return options.map((option) => ({
    ...option,
    categories: getClanCategories(option?.value)
  }));
}

const dwarfClanOptions = addCategoriesToDwarfClanOptions(
  baseDwarfClanOptions.concat(generateAdditionalDwarfClanNames(50, Math.random))
);

const dwarfClanFamilyNames = new Map([
  ['stonebeard', ['AshStone', 'StoneHold', 'BarBeard', 'StoneWatch', 'StormBeard']],
  ['barrelbrow', ['BarrelGrudge', 'StoneBrow', 'BrowPeak', 'BarrelStone', 'BarrelHall']],
  ['oathhammer', ['ThunderOath', 'OathGate', 'OathThrong', 'HammerMantle', 'AshHammer']],
  ['stormshield', ['ShieldStorm', 'ShieldWard', 'ShieldBridge', 'ShieldHold', 'StormSdottir']],
  ['granitebrow', ['BrowScar', 'FrostGranite', 'BrowKeep', 'GraniteThrong', 'AshBrow']],
  ['emberstone', ['DeepStone', 'StoneBraid', 'StoneEmber', 'GrimStone', 'EmberBinder']],
  ['blackdelve', ['ShadowDelve', 'DelveBane', 'DelveBridge', 'DeepDelve', 'DeepBlack']],
  ['hearthhammer', ['CoalHammer', 'HammerVault', 'HearthSson', 'HammerScar', 'HammerBridge']],
  ['mithrilbeard', ['MithrilThrong', 'BeardThrong', 'MithrilBlood', 'ThunderMithril', 'MithrilVault']],
  ['shieldbreaker', ['BreakerGate', 'ShieldSson', 'BreakerBinder', 'BreakerBraid', 'ShieldWatch']],
  ['deepcrag', ['GrimDeep', 'FrostDeep', 'CragBraid', 'CragStone', 'SilverCrag']],
  ['duskhollow', ['DuskSdottir', 'DeepDusk', 'DuskHold', 'DuskVault', 'BlackDusk']],
  ['hammerdeep', ['ShadowDeep', 'DeepBraid', 'StormHammer', 'HammerSson', 'DeepMantle']],
  ['deepmantle', ['MantleWatch', 'MantleScar', 'RuneDeep', 'BronzeDeep', 'GrimDeep']],
  ['ashmantle', ['BlackMantle', 'MantleBorn', 'StormMantle', 'MantleStone', 'MantleBane']],
  ['shadowhearth', ['SilverHearth', 'FrostHearth', 'ShadowMantle', 'SteelHearth', 'SilverShadow']],
  ['angrund', ['DeepAn', 'AnHammer', 'GrundFist', 'AnKin', 'AnHall']],
  ['angrulok', ['AngrulokSong', 'AngrulokForge', 'ThunderAngrulok', 'AngrulokBane', 'AshAngrulok']],
  ['badrikk', ['BadrikkKeep', 'SteelBadrikk', 'BadrikkSong', 'BadrikkBorn', 'AnvilBadrikk']],
  ['barruk', ['CoalBarruk', 'BarrukGuard', 'StormBarruk', 'BarrukBraid', 'BarrukBorn']],
  ['burrdrik', ['BurrGate', 'BurrHammer', 'BurrMantle', 'DrikBurr', 'AmberBurr']],
  ['bronzebeards', ['IronBronze', 'BronzeBraid', 'BronzeBridge', 'BeardsWatch', 'BeardsSson']],
  ['bronzefist', ['BronzeDelve', 'BronzeMantle', 'BronzeSdottir', 'FistBronze', 'FistScar']],
  ['copperback', ['BackVein', 'BackGuard', 'BackWard', 'BackBorn', 'BackBraid']],
  ['cragbrow_barak_varr_engineers', ['CragHammer', 'BrowKin', 'GraniteCrag', 'BrowForge', 'BrowHall']],
  ['cragbrow_karak_azul_miners', ['CragPeak', 'IronCrag', 'RuneBrow', 'StoneBrow', 'CragMaul']],
  ['craghand', ['HandHall', 'EmberCrag', 'CragStone', 'CragThane', 'HandBorn']],
  ['cragtooth', ['ToothBinder', 'EmberTooth', 'ToothHammer', 'CragSdottir', 'StormCrag']],
  ['donarkhun', ['DonarkhunPeak', 'DonarkhunKeep', 'DonarkhunVein', 'AnvilDonarkhun', 'ShadowDonarkhun']],
  ['dourback', ['BackRunes', 'GrimBack', 'ThunderDour', 'BackGuard', 'DourFist']],
  ['dragonback', ['IronDragon', 'BackHearth', 'BackRunes', 'SilverDragon', 'BackDelver']],
  ['drakebeard', ['DrakeKin', 'DrakeVein', 'DrakeWard', 'FrostBeard', 'DrakeSong']],
  ['drazhkarak', ['GraniteDrazhkarak', 'DrazhkarakBane', 'DeepDrazhkarak', 'GrimDrazhkarak', 'DrazhkarakForge']],
  ['dunrakin', ['StormKin', 'ThunderDunra', 'DunraThane', 'BarDunra', 'KinBorn']],
  ['firehand', ['ShadowHand', 'IronHand', 'AmberHand', 'HandGuard', 'AmberFire']],
  ['firehelm', ['HelmDelve', 'GloomHelm', 'FireKeep', 'FireRunes', 'HelmBane']],
  ['flintbeard', ['DeepBeard', 'BeardBorn', 'FlintBinder', 'FlintKin', 'FlintThrong']],
  ['flinthand_karak_azul_engineers', ['FlintSson', 'FlintWatch', 'AmberFlint', 'IronHand', 'FlintThane']],
  ['flinthand_k8p_miners', ['SteelFlint', 'FlintBorn', 'BronzeFlint', 'BronzeHand', 'StoneFlint']],
  ['flintheart', ['ThunderHeart', 'AshHeart', 'HeartVein', 'FlintHearth', 'HeartFist']],
  ['fooger', ['FoogerDelve', 'BarFooger', 'FoogerBreaker', 'CoalFooger', 'GraniteFooger']],
  ['forgehand', ['HandHearth', 'HandVault', 'StormHand', 'HandBlood', 'HandKeep']],
  ['grimhelm', ['HelmVein', 'CoalGrim', 'GrimDelver', 'BlackHelm', 'HelmBlood']],
  ['grimstone', ['FrostGrim', 'BlackStone', 'IronGrim', 'ThunderStone', 'StoneForge']],
  ['growlsh', ['GrowlshHall', 'GrowlshWard', 'GrowlshSson', 'GrowlshFist', 'GrimGrowlsh']],
  ['gunnarsson', ['GunnarssonBraid', 'GunnarssonHammer', 'GunnarssonWard', 'GunnarssonSdottir', 'GunnarssonRunes']],
  ['gunnisson_first', ['BarGunnisson', 'ContingentKeep', 'ContingentThrong', 'ContingentThane', 'IronFirst']],
  ['gunnisson_second', ['SecondBlood', 'GrimContingent', 'StoneGunnisson', 'RuneSecond', 'BlackSecond']],
  ['gunnisson_third', ['ThirdBraid', 'ThirdMantle', 'ContingentMaul', 'ContingentBraid', 'GunnissonMaul']],
  ['guttrik', ['GuttrikGrudge', 'GuttrikFist', 'RuneGuttrik', 'StoneGuttrik', 'GuttrikBreaker']],
  ['halgakrin', ['HalgakrinHold', 'IronHalgakrin', 'HalgakrinGuard', 'HalgakrinVein', 'HalgakrinBane']],
  ['hammerback', ['CoalBack', 'BackGate', 'BackRunes', 'BarBack', 'BackBinder']],
  ['helhein', ['HelheinHall', 'HelheinThrong', 'HelheinWatch', 'HelheinSong', 'GrimHelhein']],
  ['irebeard', ['BronzeBeard', 'ThunderBeard', 'IreBane', 'BeardPeak', 'EmberBeard']],
  ['ironbeard', ['StormIron', 'BeardVein', 'BeardHammer', 'BeardKeep', 'DeepIron']],
  ['ironarm', ['GloomArm', 'ArmMantle', 'IronBridge', 'ArmSson', 'CoalIron']],
  ['ironback', ['BackKin', 'SilverIron', 'SilverBack', 'BackBraid', 'IronBridge']],
  ['ironfinger', ['ThunderIron', 'FingerDelve', 'IronKeep', 'FrostFinger', 'CoalFinger']],
  ['ironfist_cities', ['IronDelver', 'FistBlood', 'IronGrudge', 'IronShield', 'IronWatch']],
  ['ironforge', ['FrostForge', 'StormIron', 'SilverForge', 'IronScar', 'FrostIron']],
  ['ironhammer', ['IronMaul', 'IronGrudge', 'HammerBorn', 'IronRunes', 'StormHammer']],
  ['ironpick', ['PickBraid', 'SteelIron', 'StonePick', 'IronHall', 'IronVault']],
  ['ironspike', ['IronStone', 'AshSpike', 'SpikeForge', 'RuneIron', 'AnvilIron']],
  ['izorgrung', ['IzorgrungDelve', 'RuneIzorgrung', 'IzorgrungDelver', 'EmberIzorgrung', 'IzorgrungWard']],
  ['kaznagar', ['KaznagarBinder', 'KaznagarDelver', 'KaznagarVault', 'KaznagarSong', 'SilverKaznagar']],
  ['magrest', ['MagrestRunes', 'MagrestForge', 'RuneMagrest', 'MagrestSdottir', 'GloomMagrest']],
  ['norgrimlings', ['NorgrimlingsPeak', 'NorgrimlingsBorn', 'NorgrimlingsRunes', 'NorgrimlingsDelve', 'ShadowNorgrimlings']],
  ['oakbarrel', ['OakSdottir', 'OakSson', 'BarrelMaul', 'ShadowOak', 'OakKin']],
  ['redbeard', ['CoalBeard', 'RedBlood', 'BeardGate', 'RedBinder', 'BeardFist']],
  ['silverscar', ['ScarRunes', 'ScarVein', 'ScarPeak', 'ScarBorn', 'ScarSson']],
  ['skorrun', ['RunDelver', 'RunBridge', 'AshRun', 'SkorBinder', 'AnvilSkor']],
  ['steelcrag', ['AshSteel', 'CragForge', 'CragBraid', 'RuneSteel', 'StormSteel']],
  ['sternbeard', ['BeardGrudge', 'SternHearth', 'BeardRunes', 'SternBreaker', 'BeardBlood']],
  ['stoneback', ['BackDelve', 'AnvilStone', 'BackStone', 'CoalStone', 'SteelStone']],
  ['stonebeard_k8p_engineers', ['FrostBeard', 'EmberBeard', 'StormBeard', 'BeardShield', 'GraniteStone']],
  ['stonebeater', ['BeaterHearth', 'BarBeater', 'ShadowStone', 'BeaterHall', 'AnvilBeater']],
  ['stonebreakers', ['EmberBreakers', 'StoneShield', 'BreakersMaul', 'AnvilStone', 'AshBreakers']],
  ['stonehammer_cities', ['StoneRunes', 'GrimStone', 'HammerVault', 'BarStone', 'EmberStone']],
  ['stonehand', ['StoneMantle', 'HandBreaker', 'HandWard', 'StoneKeep', 'StoneBorn']],
  ['stoneheart', ['SilverHeart', 'BarHeart', 'HeartPeak', 'HeartBinder', 'HeartWatch']],
  ['stoutgirth', ['EmberStoutgirth', 'StoutgirthBraid', 'StoutgirthWatch', 'StoutgirthHold', 'StoutgirthDelver']],
  ['stoutpeak', ['PeakSong', 'PeakStone', 'PeakHold', 'CoalStout', 'PeakRunes']],
  ['svengeln', ['StormSvengeln', 'SvengelnSdottir', 'SvengelnBreaker', 'SvengelnThrong', 'ShadowSvengeln']],
  ['threkkson', ['ThrekksonShield', 'ShadowThrekkson', 'ThrekksonVein', 'ThrekksonBridge', 'BronzeThrekkson']],
  ['thundergun', ['BronzeThunder', 'BronzeGun', 'StormGun', 'ThunderHold', 'GunHall']],
  ['thunderheart', ['HeartRunes', 'ThunderMantle', 'GrimHeart', 'HeartThrong', 'HeartBridge']],
  ['thunderstone', ['AnvilStone', 'AshThunder', 'ThunderBridge', 'StoneBinder', 'GrimStone']],
  ['ullek', ['UllekMantle', 'DeepUllekssons', 'FrostUllekssons', 'UllekssonsThe', 'GraniteUllekssons']],
  ['varnskan', ['VarnskanGate', 'VarnskanForge', 'ShadowVarnskan', 'AshVarnskan', 'VarnskanGuard']],
  ['vorgrund', ['GrundBreaker', 'StoneGrund', 'GrundVor', 'VorScar', 'ShadowVor']],
  ['yinlinsson', ['AshYinlinsson', 'AnvilYinlinsson', 'YinlinssonStone', 'YinlinssonGuard', 'YinlinssonGrudge']],
  ['ironfist', ['FistGuard', 'IronWatch', 'FistWatch', 'IronKin', 'FistIron']],
  ['coppervein', ['CopperveinGuard', 'GraniteCoppervein', 'CopperveinFist', 'CopperveinKin', 'CopperveinDelver']],
  ['graniteheart', ['GraniteKeep', 'BronzeHeart', 'GraniteWatch', 'HeartForge', 'HeartStone']],
  ['deepdelver', ['DelverBraid', 'DelverGate', 'DeepBreaker', 'GrimDeep', 'DeepStone']],
  ['amberpick', ['PickHold', 'PickFist', 'AmberFist', 'PickRunes', 'PickBinder']],
  ['oakenshield', ['RuneOaken', 'OakenGuard', 'OakenMantle', 'BlackOaken', 'OakenFist']],
  ['frosthammer', ['HammerGrudge', 'FrostPeak', 'HammerHold', 'SteelHammer', 'FrostHall']],
  ['berylbraid', ['BerylbraidFist', 'BerylbraidRunes', 'DeepBerylbraid', 'BerylbraidVein', 'BerylbraidThrong']],
  ['silverhollow', ['AnvilHollow', 'AmberHollow', 'HollowDelve', 'BronzeSilver', 'HollowBinder']],
  ['brazenaxe', ['ShadowBrazenaxe', 'BrazenaxeBlood', 'BrazenaxeWard', 'BrazenaxeDelve', 'BrazenaxeSdottir']],
  ['stormhammer', ['EmberHammer', 'HammerGate', 'StormDelver', 'StormBane', 'HammerFist']],
  ['deeprock', ['RockScar', 'ShadowDeep', 'DeepFist', 'ShadowRock', 'DeepForge']],
  ['goldvein', ['VeinGold', 'VeinHearth', 'SteelGold', 'SteelVein', 'StormVein']],
  ['runesmith', ['RuneDelve', 'ThunderRune', 'SmithMantle', 'AnvilRune', 'SmithScar']],
  ['aleswiller', ['AleswillerHearth', 'AleswillerBraid', 'AleswillerBreaker', 'RuneAleswiller', 'ThunderAleswiller']],
  ['argent_hand', ['ArgentGate', 'ArgentVein', 'ArgentBlood', 'BronzeArgent', 'ArgentPeak']],
  ['axebreaker', ['AxeMaul', 'BreakerAxe', 'AxeBorn', 'SteelAxe', 'AxeBinder']],
  ['blackfire', ['BlackGuard', 'BlackPeak', 'FireWatch', 'DeepFire', 'BlackDelve']],
  ['bloodstone', ['BloodHold', 'SteelBlood', 'GloomBlood', 'BloodDelve', 'StoneKeep']],
  ['boulderscorch', ['AnvilBoulderscorch', 'BoulderscorchDelve', 'BoulderscorchShield', 'BoulderscorchBlood', 'BoulderscorchBraid']],
  ['duergar', ['SilverDuergar', 'DuergarWatch', 'DuergarKin', 'DuergarBridge', 'RuneDuergar']],
  ['fiania', ['FianiaBinder', 'FianiaBane', 'FianiaKin', 'AshFiania', 'BarFiania']],
  ['goldenforge', ['GoldenDelver', 'BarForge', 'ForgeMantle', 'ForgeGrudge', 'ForgeSson']],
  ['gordemuncher', ['GordemuncherFist', 'GordemuncherWatch', 'GordemuncherHearth', 'GordemuncherGrudge', 'GrimGordemuncher']],
  ['hammerhead', ['GraniteHammer', 'HammerForge', 'HeadBlood', 'GrimHammer', 'HammerThane']],
  ['ironson', ['IronHammer', 'IronBridge', 'SonGate', 'SonFist', 'IronGuard']],
  ['kazak_uruk', ['KazakGuard', 'ThunderUruk', 'KazakThrong', 'KazakMaul', 'KazakWatch']],
  ['orcsplitter', ['OrcsplitterHammer', 'OrcsplitterShield', 'AshOrcsplitter', 'OrcsplitterBlood', 'OrcsplitterThane']],
  ['rockcrawler', ['IronRockcrawler', 'RockcrawlerKeep', 'RockcrawlerPeak', 'RockcrawlerGate', 'RockcrawlerBinder']],
  ['shattered_stone', ['RuneRed', 'StoneHall', 'GraniteShatte', 'ShadowStone', 'IronShatte']],
  ['bronzebeard', ['BeardHammer', 'IronBronze', 'BeardThane', 'BronzeKin', 'BronzeBinder']],
  ['stormpike', ['StormSong', 'GloomPike', 'PikeGrudge', 'AshPike', 'SilverStorm']],
  ['stonefist', ['StoneSson', 'StoneScar', 'BronzeFist', 'GrimStone', 'FistWard']],
  ['hylar', ['HylarWard', 'HylarStone', 'GloomHylar', 'BronzeHylar', 'HylarBorn']],
  ['daergar', ['DaergarDelver', 'DaergarGate', 'GloomDaergar', 'DaergarFist', 'DaergarSong']],
  ['daewar', ['DaewarMaul', 'DaewarBinder', 'DaewarGrudge', 'DaewarThrong', 'DaewarSson']],
  ['theiwar', ['TheiwarStone', 'ShadowTheiwar', 'BronzeTheiwar', 'TheiwarMaul', 'AshTheiwar']],
  ['aghar', ['AgharBane', 'AgharDelve', 'BronzeAghar', 'AgharSson', 'FrostAghar']],
  ['battlehammer', ['BattleThrong', 'BattleVault', 'HammerForge', 'BattleBorn', 'HammerWard']],
  ['bitterroot', ['GraniteBitterroot', 'BitterrootWatch', 'CoalBitterroot', 'FrostBitterroot', 'BitterrootGuard']],
  ['black_axe', ['ShadowAxe', 'AxeHall', 'BlackGrudge', 'AxeBreaker', 'StormAxe']],
  ['boldenbar', ['BoldenbarVein', 'AmberBoldenbar', 'BoldenbarBraid', 'BoldenbarFist', 'BoldenbarBane']],
  ['bouldershoulder', ['BouldershoulderGate', 'BouldershoulderWard', 'AnvilBouldershoulder', 'BlackBouldershoulder', 'RuneBouldershoulder']],
  ['brawnanvil', ['BrawnanvilGuard', 'BrawnanvilThrong', 'BlackBrawnanvil', 'ShadowBrawnanvil', 'BrawnanvilKeep']],
  ['brightblade', ['BrightbladeRunes', 'BrightbladeHearth', 'BrightbladeThrong', 'BarBrightblade', 'ThunderBrightblade']],
  ['brighthelm', ['GrimHelm', 'AshBright', 'BrightBreaker', 'HelmBorn', 'HelmVein']],
  ['broodhull', ['BroodhullGuard', 'BroodhullBraid', 'BroodhullKeep', 'StoneBroodhull', 'BroodhullThane']],
  ['bruenghor', ['GraniteBruenghor', 'BruenghorVein', 'BruenghorStone', 'BruenghorGate', 'BruenghorHammer']],
  ['bukbukken', ['BukbukkenScar', 'SilverBukbukken', 'BukbukkenGate', 'BukbukkenKin', 'BukbukkenBreaker']],
  ['chistlesmith', ['AmberChistlesmith', 'ChistlesmithHearth', 'SteelChistlesmith', 'ChistlesmithShield', 'AnvilChistlesmith']],
  ['eaglecleft', ['EaglecleftBorn', 'EaglecleftBinder', 'RuneEaglecleft', 'BlackEaglecleft', 'EaglecleftFist']],
  ['flameshade', ['FlameshadePeak', 'FlameshadeKeep', 'FlameshadeThrong', 'BarFlameshade', 'RuneFlameshade']],
  ['muzgardt', ['MuzgardtVault', 'MuzgardtPeak', 'MuzgardtStone', 'MuzgardtGrudge', 'IronMuzgardt']],
  ['stoneshaft', ['GraniteShaft', 'StoneVault', 'ShaftBlood', 'ShaftHearth', 'StoneHearth']],
  ['ticklebeard', ['BeardBlood', 'BeardVault', 'TickleBorn', 'TickleHold', 'AshTickle']],
  ['dankil', ['BronzeDankil', 'DankilWatch', 'AmberDankil', 'BlackDankil', 'DankilSson']],
  ['daraz', ['GraniteDaraz', 'DarazHold', 'StormDaraz', 'DarazHearth', 'DarazFist']],
  ['forgebar', ['ForgebarSdottir', 'BlackForgebar', 'ForgebarWatch', 'ForgebarScar', 'ForgebarHammer']],
  ['gemcrypt', ['GemcryptHall', 'GemcryptMaul', 'GemcryptSong', 'ShadowGemcrypt', 'GemcryptThrong']],
  ['girdaur', ['RuneGirdaur', 'GrimGirdaur', 'SilverGirdaur', 'GirdaurBinder', 'GraniteGirdaur']],
  ['hammerhand', ['StormHand', 'CoalHand', 'HandBreaker', 'HandHold', 'HammerGrudge']],
  ['hardhammer', ['ThunderHammer', 'DeepHard', 'HammerDelver', 'BarHard', 'RuneHard']],
  ['herlinga', ['HerlingaMantle', 'HerlingaGuard', 'ShadowHerlinga', 'HerlingaBridge', 'BlackHerlinga']],
  ['hillborn', ['HillbornDelver', 'HillbornStone', 'HillbornRunes', 'StoneHillborn', 'AshHillborn']],
  ['hillsafar', ['BarHillsafar', 'HillsafarShield', 'HillsafarBorn', 'AnvilHillsafar', 'HillsafarThrong']],
  ['horn', ['IronHorn', 'FrostHorn', 'HornBraid', 'HornFist', 'HornDelver']],
  ['icehammer', ['HammerHold', 'CoalHammer', 'SteelHammer', 'HammerBreaker', 'GraniteIce']],
  ['ironeater', ['SilverEater', 'IronBorn', 'EaterHammer', 'IronWatch', 'IronThrong']],
  ['ironstar', ['StarIron', 'IronDelver', 'StarDelver', 'StarWatch', 'IronBlood']],
  ['licehair', ['AshLicehair', 'LicehairMantle', 'GloomLicehair', 'CoalLicehair', 'LicehairSong']],
  ['ludwakazar', ['CoalLudwakazar', 'GrimLudwakazar', 'LudwakazarStone', 'GraniteLudwakazar', 'EmberLudwakazar']],
  ['madbeards', ['MadbeardsBane', 'CoalMadbeards', 'MadbeardsGrudge', 'MadbeardsWard', 'MadbeardsDelve']],
  ['mcknuckles', ['McknucklesStone', 'McknucklesHall', 'McknucklesGrudge', 'BarMcknuckles', 'GloomMcknuckles']],
  ['mcruff', ['McruffRunes', 'McruffSong', 'McruffWatch', 'McruffScar', 'McruffVault']],
  ['melairkyn', ['MelairkynScar', 'MelairkynBridge', 'MelairkynThrong', 'StormMelairkyn', 'MelairkynVein']],
  ['orcsmasher', ['OrcsmasherHearth', 'OrcsmasherForge', 'OrcsmasherMaul', 'OrcsmasherBlood', 'GraniteOrcsmasher']],
  ['orothiar', ['OrothiarShield', 'OrothiarGrudge', 'GrimOrothiar', 'AshOrothiar', 'OrothiarStone']],
  ['pwent', ['PwentBane', 'PwentBinder', 'PwentDelve', 'PwentBridge', 'PwentKin']],
  ['rockjaw', ['BlackRockjaw', 'RockjawMaul', 'BronzeRockjaw', 'GloomRockjaw', 'FrostRockjaw']],
  ['rookoath', ['OathShield', 'AmberRook', 'RookForge', 'OathMaul', 'GraniteRook']],
  ['rustfire', ['EmberRust', 'StoneFire', 'FireDelve', 'AshFire', 'RustKeep']],
  ['sandbeards', ['BronzeSandbeards', 'SandbeardsMantle', 'CoalSandbeards', 'SandbeardsForge', 'SteelSandbeards']],
  ['shattershield', ['ShieldHall', 'ShatterHammer', 'AmberShatter', 'ShieldGate', 'ShatterKeep']],
  ['stonebridge', ['BridgeForge', 'GrimStone', 'StoneBinder', 'RuneBridge', 'BridgeShield']],
  ['stonehand', ['StoneMantle', 'HandBreaker', 'HandWard', 'StoneKeep', 'StoneBorn']],
  ['stoneshoulder', ['ShoulderRunes', 'StoneMaul', 'StoneKin', 'ShoulderBreaker', 'StoneVein']],
  ['stouthammer', ['BlackHammer', 'IronHammer', 'SteelHammer', 'SilverStout', 'HammerScar']],
  ['sunblight', ['SunblightSdottir', 'SunblightThane', 'SunblightForge', 'ThunderSunblight', 'GloomSunblight']],
  ['undurr', ['UndurrBorn', 'UndurrWatch', 'UndurrKeep', 'SteelUndurr', 'AshUndurr']],
  ['grimlock', ['BronzeGrim', 'GrimGuard', 'LockHold', 'LockMantle', 'SteelLock']],
  ['maccloud', ['CoalMaccloud', 'MaccloudWatch', 'MaccloudBlood', 'FrostMaccloud', 'MaccloudGate']],
  ['thundermore', ['ThunderWard', 'ThunderDelver', 'ThunderVein', 'MoreBridge', 'GrimThunder']],
  ['enogtorad', ['EnogtoradForge', 'EnogtoradMaul', 'EnogtoradGrudge', 'AmberEnogtorad', 'GloomEnogtorad']],
  ['drummond', ['DrummondBorn', 'DrummondBlood', 'DrummondThrong', 'DrummondStone', 'DrummondMaul']],
  ['tolorr', ['RuneTolorr', 'BlackTolorr', 'CoalTolorr', 'AshTolorr', 'TolorrFist']],
  ['vanderholl', ['VanderhollBraid', 'VanderhollVein', 'VanderhollShield', 'VanderhollRunes', 'VanderhollWard']],
  ['stonefist', ['StoneSson', 'StoneScar', 'BronzeFist', 'GrimStone', 'FistWard']],
  ['aringeld', ['BronzeAringeld', 'GloomAringeld', 'AringeldSdottir', 'AringeldForge', 'AringeldWatch']],
  ['gelderon', ['GelderonDelver', 'GelderonSong', 'AshGelderon', 'GelderonThrong', 'GelderonThane']],
  ['grimmark', ['MarkWard', 'MarkStone', 'MarkHammer', 'EmberGrim', 'GrimFist']],
  ['shalefoot', ['EmberShalefoot', 'ShalefootShield', 'ShalefootMantle', 'ShalefootKin', 'ShalefootBorn']],
  ['silverhair', ['SilverBridge', 'AmberSilver', 'SilverStone', 'HairHearth', 'HairBraid']],
  ['copperlung_stonescar', ['StonePeak', 'ScarSdottir', 'ScarPeak', 'CoalCopperlung', 'StoneVault']],
  ['stouthammer', ['BlackHammer', 'IronHammer', 'SteelHammer', 'SilverStout', 'HammerScar']],
  ['flintbristle', ['FlintbristleSson', 'CoalFlintbristle', 'FlintbristleThane', 'FlintbristleDelve', 'FlintbristleShield']],
  ['spire_crag', ['SpireHall', 'CragKeep', 'SilverSpire', 'SpireThrong', 'SpireWard']],
  ['stonehollow', ['StoneHall', 'HollowDelve', 'StoneVein', 'HollowHearth', 'DeepStone']],
  ['silverpick', ['PickBane', 'PickHearth', 'SilverThane', 'DeepSilver', 'SilverKin']],
  ['ironheart', ['IronGate', 'IronKin', 'AshHeart', 'SteelIron', 'CoalIron']],
  ['weoughld', ['WeoughldBane', 'WeoughldVein', 'WeoughldKin', 'StoneWeoughld', 'WeoughldSdottir']],
  ['llyrnillach', ['LlyrnillachBridge', 'LlyrnillachHall', 'LlyrnillachPeak', 'LlyrnillachThane', 'LlyrnillachHold']],
  ['highhelm', ['HighSong', 'HighBraid', 'ShadowHigh', 'FrostHigh', 'HighMaul']],
]);

const dwarfGuildOptions = [
  { value: 'miners-guild', label: 'Miners Guild' },
  { value: 'coopers-guild', label: 'Coopers Guild' },
  { value: 'merchants-guild', label: 'Merchants Guild' },
  { value: 'commerce-guild', label: 'Commerce Guild' },
  { value: 'armourers-weaponsmiths-guild', label: 'Armourers and Weaponsmiths Guild' },
  { value: 'artisans-guild', label: 'Artisans Guild' },
  { value: 'bakers-guild', label: 'Bakers Guild' },
  { value: 'brewers-guild', label: 'Brewers Guild' },
  { value: 'carpenters-guild', label: 'Carpenters Guild' },
  { value: 'construction-guild', label: 'Construction Guild' },
  { value: 'corpsebinders-guild', label: 'Corpsebinders Guild' },
  { value: 'distiller-guild', label: 'Distiller Guild' },
  { value: 'dyers-guild', label: 'Dyers Guild' },
  { value: 'engineers-guild', label: 'Engineers Guild' },
  { value: 'farmers-herders-guild', label: 'Farmers and Herders Guild' },
  { value: 'gemcutters-guild', label: 'Gemcutters Guild' },
  { value: 'goldsmiths-guild', label: 'Goldsmiths Guild' },
  { value: 'guild-of-alchemists', label: 'Guild of Alchemists' },
  { value: 'jewelsmiths-guild', label: 'Jewelsmiths Guild' },
  { value: 'leatherworkers-guild', label: 'Leatherworkers Guild' },
  { value: 'metalsmiths-guild', label: 'Metalsmiths Guild' },
  { value: 'powdermakers-guild', label: 'Powdermakers Guild' },
  { value: 'saltworkers-guild', label: 'Saltworkers Guild' },
  { value: 'stonemasons-guild', label: 'Stonemasons Guild' },
  { value: 'runescribes-guild', label: 'Runescribes Guild' },
  { value: 'runesmiths', label: 'Runesmiths' },
  { value: 'warriors-guild', label: 'Warriors Guild' },
  { value: 'toolmakers-guild', label: "Toolmakers' Guild" },
  { value: 'soapmakers-guild', label: 'Soapmakers Guild' },
  { value: 'candlelighters-guild', label: 'Candlelighters Guild' },
  { value: 'lamplighters-guild', label: 'Lamplighters Guild' },
  { value: 'butchers-guild', label: 'Butchers Guild' },
  { value: 'ropemakers-guild', label: 'Ropemakers Guild' },
  { value: 'cartwrights-wheelwrights-guild', label: 'Cartwrights & Wheelwrights Guild' },
  { value: 'glassblowers-guild', label: 'Glassblowers Guild' },
  { value: 'millers-guild', label: 'Millers Guild' },
  { value: 'cobblers-guild', label: 'Cobblers Guild' },
  { value: 'cartographers-guild', label: 'Cartographers Guild' },
  { value: 'explorers-guild', label: 'Explorers Guild' },
  { value: 'lorekeepers-guild', label: 'Lorekeepers Guild' },
  { value: 'tunnel-wardens-guild', label: 'Tunnel Wardens Guild' },
  { value: 'smelters-guild', label: 'Smelters Guild' }
];

function generateProfessionsFromGuilds(guildOptions, existingOptions = []) {
  const professions = [];
  const seenValues = new Set(existingOptions.map((p) => p.value));

  const addProfession = (value, label) => {
    if (!seenValues.has(value)) {
      professions.push({ value, label });
      seenValues.add(value);
    }
  };

  guildOptions.forEach(guild => {
    // Handle multi-discipline guilds that should spawn multiple professions
    if (guild.value === 'armourers-weaponsmiths-guild') {
      addProfession('armourer', 'Armourer');
      addProfession('weaponsmith', 'Weaponsmith');
      return;
    }
    if (guild.value === 'farmers-herders-guild') {
      addProfession('farmer', 'Farmer');
      addProfession('herder', 'Herder');
      return;
    }

    let label = guild.label;
    let value = guild.value;

    // Remove "Guild" or "Guild of" and "s" from the end
    label = label.replace(/ Guild( of)?/i, '').replace(/s$/, '');
    value = value.replace(/-guild(of-)?/i, '').replace(/s$/, '');

    // Special cases or common transformations
    if (label.includes('Cartwright') && label.includes('Wheelwright')) {
      label = 'Cartwright & Wheelwright';
      value = 'cartwright-wheelwright';
    } else if (label === 'Alchemist') {
      label = 'Alchemist';
      value = 'alchemist';
    } else if (label === 'Runescribe') {
      label = 'Runescribe';
      value = 'runescribe';
    } else if (label === 'Runesmith') {
      label = 'Runesmith';
      value = 'runesmith';
    } else if (label === 'Warrior') {
      label = 'Warrior';
      value = 'warrior';
    } else if (label === 'Toolmaker') {
      label = 'Toolmaker';
      value = 'toolmaker';
    } else if (label === 'Lorekeeper') {
      label = 'Lorekeeper';
      value = 'lorekeeper';
    } else if (label === 'Tunnel Warden') {
      label = 'Tunnel Warden';
      value = 'tunnel-warden';
    } else if (label === 'Smelter') {
      label = 'Smelter';
      value = 'smelter';
    } else if (label === 'Explorer') {
      label = 'Explorer';
      value = 'explorer';
    } else if (label === 'Cartographer') {
      label = 'Cartographer';
      value = 'cartographer';
    } else if (label === 'Cobbler') {
      label = 'Cobbler';
      value = 'cobbler';
    } else if (label === 'Miller') {
      label = 'Miller';
      value = 'miller';
    } else if (label === 'Glassblower') {
      label = 'Glassblower';
      value = 'glassblower';
    } else if (label === 'Ropemaker') {
      label = 'Ropemaker';
      value = 'ropemaker';
    } else if (label === 'Butcher') {
      label = 'Butcher';
      value = 'butcher';
    } else if (label === 'Lamplighter') {
      label = 'Lamplighter';
      value = 'lamplighter';
    } else if (label === 'Candlelighter') {
      label = 'Candlelighter';
      value = 'candlelighter';
    } else if (label === 'Soapmaker') {
      label = 'Soapmaker';
      value = 'soapmaker';
    } else if (label === 'Metalsmith') {
      label = 'Metalsmith';
      value = 'metalsmith';
    } else if (label === 'Leatherworker') {
      label = 'Leatherworker';
      value = 'leatherworker';
    } else if (label === 'Jewelsmith') {
      label = 'Jewelsmith';
      value = 'jewelsmith';
    } else if (label === 'Goldsmith') {
      label = 'Goldsmith';
      value = 'goldsmith';
    } else if (label === 'Gemcutter') {
      label = 'Gemcutter';
      value = 'gemcutter';
    } else if (label === 'Engineer') {
      label = 'Engineer';
      value = 'engineer';
    } else if (label === 'Dyer') {
      label = 'Dyer';
      value = 'dyer';
    } else if (label === 'Distiller') {
      label = 'Distiller';
      value = 'distiller';
    } else if (label === 'Corpsebinder') {
      label = 'Corpsebinder';
      value = 'corpsebinder';
    } else if (label === 'Construction') {
      label = 'Construction Worker'; // More specific
      value = 'construction-worker';
    } else if (label === 'Carpenter') {
      label = 'Carpenter';
      value = 'carpenter';
    } else if (label === 'Brewer') {
      label = 'Brewer';
      value = 'brewer';
    } else if (label === 'Baker') {
      label = 'Baker';
      value = 'baker';
    } else if (label === 'Artisan') {
      label = 'Artisan';
      value = 'artisan';
    } else if (label === 'Miner') {
      label = 'Miner';
      value = 'miner';
    } else if (label === 'Cooper') {
      label = 'Cooper';
      value = 'cooper';
    } else if (label === 'Merchant') {
      label = 'Merchant';
      value = 'merchant';
    } else if (label === 'Commerce') {
      label = 'Commerce Agent'; // More specific
      value = 'commerce-agent';
    } else if (label === 'Powdermaker') {
      label = 'Powdermaker';
      value = 'powdermaker';
    } else if (label === 'Saltworker') {
      label = 'Saltworker';
      value = 'saltworker';
    } else if (label === 'Stonemason') {
      label = 'Stonemason';
      value = 'stonemason';
    }


    // Add "Master" prefix for certain professions if not already present
    if (['Mason', 'Smith', 'Carpenter', 'Brewer'].includes(label) && !label.startsWith('Master')) {
      label = `Master ${label}`;
    }
    // Add "Chief" prefix for Engineer if not already present
    if (label === 'Engineer' && !label.startsWith('Chief')) {
      label = `Chief ${label}`;
    }
    // Add "Lore" prefix for Scholar if not already present
    if (label === 'Scholar' && !label.startsWith('Lore')) {
      label = `Lore ${label}`;
    }
    // Add "Captain" prefix for Ranger if not already present
    if (label === 'Ranger' && !label.startsWith('Ranger')) {
      label = `Ranger ${label}`;
    }


    addProfession(value, label);
  });

  return professions;
}

const baseDwarfProfessionOptions = [
  { value: 'miner', label: 'Miner' },
  { value: 'mason', label: 'Mason' },
  { value: 'smith', label: 'Smith' },
  { value: 'brewer', label: 'Brewmaster' },
  { value: 'engineer', label: 'Engineer' },
  { value: 'scholar', label: 'Scholar' },
  { value: 'ranger', label: 'Ranger' },
  { value: 'carpenter', label: 'Carpenter' },
  { value: 'gemcutter', label: 'Gemcutter' },
  { value: 'banker', label: 'Banker' },
  { value: 'cooper', label: 'Cooper' },
  { value: 'merchant', label: 'Merchant' },
  { value: 'armourer', label: 'Armourer' },
  { value: 'weaponsmith', label: 'Weaponsmith' },
  { value: 'artisan', label: 'Artisan' },
  { value: 'baker', label: 'Baker' },
  { value: 'brewer-guild', label: 'Brewer' },
  { value: 'carpenter-guild', label: 'Carpenter' },
  { value: 'construction-worker', label: 'Construction Worker' },
  { value: 'corpsebinder', label: 'Corpsebinder' },
  { value: 'distiller', label: 'Distiller' },
  { value: 'dyer', label: 'Dyer' },
  { value: 'engineer-guild', label: 'Engineer' },
  { value: 'farmer', label: 'Farmer' },
  { value: 'herder', label: 'Herder' },
  { value: 'goldsmith', label: 'Goldsmith' },
  { value: 'alchemist', label: 'Alchemist' },
  { value: 'jewelsmith', label: 'Jewelsmith' },
  { value: 'leatherworker', label: 'Leatherworker' },
  { value: 'metalsmith', label: 'Metalsmith' },
  { value: 'powdermaker', label: 'Powdermaker' },
  { value: 'saltworker', label: 'Saltworker' },
  { value: 'stonemason', label: 'Stonemason' },
  { value: 'runescribe', label: 'Runescribe' },
  { value: 'runesmith', label: 'Runesmith' },
  { value: 'warrior', label: 'Warrior' },
  { value: 'toolmaker', label: 'Toolmaker' },
  { value: 'soapmaker', label: 'Soapmaker' },
  { value: 'candlelighter', label: 'Candlelighter' },
  { value: 'lamplighter', label: 'Lamplighter' },
  { value: 'butcher', label: 'Butcher' },
  { value: 'ropemaker', label: 'Ropemaker' },
  { value: 'cartwright-wheelwright', label: 'Cartwright & Wheelwright' },
  { value: 'glassblower', label: 'Glassblower' },
  { value: 'miller', label: 'Miller' },
  { value: 'cobbler', label: 'Cobbler' },
  { value: 'cartographer', label: 'Cartographer' },
  { value: 'explorer', label: 'Explorer' },
  { value: 'lorekeeper', label: 'Lorekeeper' },
  { value: 'tunnel-warden', label: 'Tunnel Warden' },
  { value: 'smelter', label: 'Smelter' }
];

const dwarfProfessionOptions = baseDwarfProfessionOptions.concat(
  generateProfessionsFromGuilds(dwarfGuildOptions, baseDwarfProfessionOptions)
);

const dwarfHairStyles = {
  bald: {
    label: 'Bald',
    description: 'bald',
    rows: { default: null },
    hideHairColorDescription: true
  },
  straight_shoulder: {
    label: 'Straight — Shoulder Length',
    description: 'shoulder-length straight',
    sheet: 'hair',
    rows: { default: 5 }
  },
  straight_short: {
    label: 'Straight — Short Crop',
    description: 'short straight',
    sheet: 'hair',
    rows: { default: 4 }
  },
  straight_braided: {
    label: 'Straight — Braided Tail',
    description: 'braided straight',
    sheet: 'hair',
    rows: { default: 8 }
  },
  curly_stubble: {
    label: 'Curly — Close Shave',
    description: 'closely shorn curly',
    sheet: 'hairCurly',
    rows: { default: 0 }
  },
  curly_short_unkempt: {
    label: 'Curly — Short & Tousled',
    description: 'short unkempt curly',
    sheet: 'hairCurly',
    rows: { default: 1 }
  },
  curly_mid_unkempt: {
    label: 'Curly — Mid-Length Tousled',
    description: 'mid-length unkempt curly',
    sheet: 'hairCurly',
    rows: { default: 2 }
  },
  curly_long_unkempt: {
    label: 'Curly — Long & Tousled',
    description: 'long unkempt curly',
    sheet: 'hairCurly',
    rows: { default: 3 }
  },
  curly_short_combed: {
    label: 'Curly — Short Combed',
    description: 'short combed curly',
    sheet: 'hairCurly',
    rows: { default: 4 }
  },
  curly_mid_combed: {
    label: 'Curly — Mid-Length Combed',
    description: 'mid-length combed curly',
    sheet: 'hairCurly',
    rows: { default: 5 }
  },
  curly_long_combed: {
    label: 'Curly — Long Combed',
    description: 'long combed curly',
    sheet: 'hairCurly',
    rows: { default: 6 }
  },
  curly_short_braided: {
    label: 'Curly — Short Braids',
    description: 'short braided curly',
    sheet: 'hairCurly',
    rows: { default: 7 }
  },
  curly_mid_braided: {
    label: 'Curly — Mid Braids',
    description: 'mid-length braided curly',
    sheet: 'hairCurly',
    rows: { default: 8 }
  },
  curly_long_braided: {
    label: 'Curly — Long Braids',
    description: 'long braided curly',
    sheet: 'hairCurly',
    rows: { default: 9 }
  },
  curly_short_double_braids: {
    label: 'Curly — Short Double Braids',
    description: 'short double-braided curly',
    sheet: 'hairCurly',
    rows: { default: 10 }
  },
  curly_mid_double_braids: {
    label: 'Curly — Mid Double Braids',
    description: 'mid-length double-braided curly',
    sheet: 'hairCurly',
    rows: { default: 11 }
  },
  curly_long_double_braids: {
    label: 'Curly — Long Double Braids',
    description: 'long double-braided curly',
    sheet: 'hairCurly',
    rows: { default: 12 }
  }
};

const dwarfHairStyleAliases = {
  curly_short: 'curly_short_combed',
  curly_full: 'curly_mid_combed',
  curly_wild: 'curly_long_combed'
};

const dwarfHeadTypes = {
  type1: { label: 'Head Type I', column: 0 },
  type2: { label: 'Head Type II', column: 1 },
  type3: { label: 'Head Type III', column: 2 },
  type4: { label: 'Head Type IV', column: 3 },
  type5: { label: 'Head Type V', column: 4 },
  type6: { label: 'Head Type VI', column: 5 },
  type7: { label: 'Head Type VII', column: 6 },
  type8: { label: 'Head Type VIII', column: 7 }
};

const dwarfHeadOptions = Object.entries(dwarfHeadTypes).map(([value, config]) => ({
  value,
  label: config.label
}));

const defaultHeadTypeValue = 'type5';

function resolveHeadTypeValue(value) {
  if (!value) {
    return defaultHeadTypeValue;
  }
  return Object.prototype.hasOwnProperty.call(dwarfHeadTypes, value) ? value : defaultHeadTypeValue;
}

const dwarfOptions = {
  gender: [
    { value: 'female', label: 'Female' },
    { value: 'male', label: 'Male' }
  ],
  skin: [
    { value: 'coal', label: 'Coal Black', color: '#1a0f10' },
    { value: 'umber', label: 'Deep Umber', color: '#4d3123' },
    { value: 'russet', label: 'Russet Bronze', color: '#6b3a22' },
    { value: 'sienna', label: 'Burnt Sienna', color: '#8a4b2a' },
    { value: 'dawn', label: 'Dawn Rose', color: '#c68d7d' },
    { value: 'pearl', label: 'Pale Pearl', color: '#dfc4b3' },
    { value: 'ashen', label: 'Ashen Slate', color: '#9c8f8b' }
  ],
  eyes: [
    { value: 'amber', label: 'Amber', color: '#c18f32' },
    { value: 'hazel', label: 'Hazel', color: '#7f5b30' },
    { value: 'emerald', label: 'Emerald', color: '#3b8b4f' },
    { value: 'ice', label: 'Ice Blue', color: '#7fb8d6' },
    { value: 'onyx', label: 'Onyx', color: '#1f1b1c' },
    { value: 'steel', label: 'Steel Grey', color: '#8d9aa7' },
    { value: 'violet', label: 'Violet', color: '#8d6bb0' }
  ],
  hairStyle: Object.entries(dwarfHairStyles).map(([value, config]) => ({
    value,
    label: config.label
  })),
  hair: [
    { value: 'obsidian', label: 'Obsidian Black', color: '#141015' },
    { value: 'umber', label: 'Rich Umber', color: '#3f2416' },
    { value: 'auburn', label: 'Deep Auburn', color: '#5b2813' },
    { value: 'copper', label: 'Copper Red', color: '#8c3d17' },
    { value: 'golden', label: 'Golden Wheat', color: '#b58a2f' },
    { value: 'ashen', label: 'Ashen Silver', color: '#c0c6d1' },
    { value: 'white', label: 'Snow White', color: '#f1f2f4' }
  ],
  head: dwarfHeadOptions,
  beard: [
    { value: 'clean', label: 'Clean-shaven' },
    { value: 'short', label: 'Short Beard' },
    { value: 'full', label: 'Full Beard' },
    { value: 'braided', label: 'Braided Beard' },
    { value: 'forked', label: 'Forked Beard' },
    { value: 'mutton', label: 'Mutton Chops' },
    { value: 'stubble', label: 'Stubble Beard' },
    { value: 'trimmed', label: 'Trimmed Beard' },
    { value: 'goatee', label: 'Goatee' },
    { value: 'imperial', label: 'Imperial Mustache' },
    { value: 'wizard', label: 'Wizard Beard' },
    { value: 'ringed', label: 'Ringed Beard' }
  ],
  clan: dwarfClanOptions,
  guild: dwarfGuildOptions,
  profession: dwarfProfessionOptions
};

function getOptionByValue(category, value) {
  if (!category || !value || typeof category !== 'string' || typeof value !== 'string') {
    return null;
  }
  const options = dwarfOptions[category];
  if (!Array.isArray(options)) {
    return null;
  }
  return options.find((option) => option && option.value === value) || null;
}

function getOptionLabel(category, value) {
  if (!category || !value) {
    return value || '';
  }
  const option = getOptionByValue(category, value);
  if (option && typeof option.label === 'string') {
    return option.label;
  }
  return value || '';
}

// Initialize customizerDeps now that all dependencies are available
customizerDeps = {
  state,
  elements,
  getOptionByValue,
  getOptionLabel,
  getHairSummaryPhrase,
  getHairStyleConfig,
  resolveHairStyleValue,
  resolveHeadTypeValue,
  dwarfHeadTypes,
  dwarfSpriteSheets,
  characterCreatorPortraitAssets,
  characterCreatorBeardAssetMap,
  characterCreatorHairAssetMap,
  characterCreatorHairStyleCategoryMap,
  characterCreatorDefaultSkinColor,
  characterCreatorDefaultHairColor,
  getCharacterCreatorSkinTintLayers,
  getCharacterCreatorHairTintLayers,
  setActiveDwarf,
  getActiveDwarf
};

const editableDwarfTraits = new Set([
  'gender',
  'skin',
  'eyes',
  'head',
  'hairStyle',
  'hair',
  'beard',
  'clan',
  'guild',
  'profession'
]);



const dwarfNamePools = {
  female: [
    'Domas',
    'Rigòth',
    'Kadôl',
    'Meng',
    'Onol',
    'Rith',
    'Sigrid',
    'Thilda',
    'Asgrid',
    'Helga',
    'Goden',
    'Emera'
  ],
  male: [
    'Urist',
    'Thob',
    'Kadol',
    'Stukos',
    'Likot',
    'Datan',
    'Mörul',
    'Logem',
    'Rakust',
    'Thorin',
    'Gorim',
    'Norgrim'
  ]
};

const presetDwarfFirstNames = new Set(
  Object.values(dwarfNamePools).reduce((allNames, pool) => allNames.concat(pool), [])
);



function resolveHairStyleValue(value) {
  if (!value) {
    return defaultHairStyleValue;
  }
  const alias = dwarfHairStyleAliases[value];
  const key = alias || value;
  return dwarfHairStyles[key] ? key : defaultHairStyleValue;
}

function getHairStyleConfig(value) {
  const key = resolveHairStyleValue(value);
  return dwarfHairStyles[key];
}

function getHairStyleDescription(value) {
  const config = getHairStyleConfig(value);
  return config?.description || getOptionLabel('hairStyle', value);
}

function getHairSummaryPhrase(dwarf) {
  const styleConfig = getHairStyleConfig(dwarf?.hairStyle);
  const hairStyleDescription = (getHairStyleDescription(dwarf?.hairStyle) || '').toLowerCase();
  if (styleConfig?.hideHairColorDescription) {
    return hairStyleDescription || 'bald';
  }
  const hairLabel = (getOptionLabel('hair', dwarf?.hair) || '').toLowerCase();
  if (hairStyleDescription && hairLabel) {
    return `${hairStyleDescription} ${hairLabel} hair`;
  }
  if (hairStyleDescription) {
    return `${hairStyleDescription} hair`;
  }
  if (hairLabel) {
    return `${hairLabel} hair`;
  }
  return 'hair';
}

function ensureSelectValue(selectElement, value, fallback) {
  if (!selectElement) {
    return;
  }
  selectElement.value = value;
  if (selectElement.value !== value) {
    selectElement.value = fallback;
  }
}

function getTraitOptions(trait) {
  const options = dwarfOptions[trait];
  return Array.isArray(options) ? options : [];
}

function updateTraitSliderDisplay(trait, sliderElement, valueElement, indexOverride) {
  if (!sliderElement) {
    return;
  }
  const options = getTraitOptions(trait);
  const maxIndex = Math.max(0, options.length - 1);
  const rawIndex =
    typeof indexOverride === 'number' && Number.isFinite(indexOverride)
      ? indexOverride
      : Math.round(Number(sliderElement.value) || 0);
  const index = clamp(rawIndex, 0, maxIndex);
  const option = options[index];

  sliderElement.setAttribute('aria-valuemin', '0');
  sliderElement.setAttribute('aria-valuemax', String(maxIndex));
  sliderElement.setAttribute('aria-valuenow', String(index));
  sliderElement.setAttribute('aria-valuetext', option ? option.label : '');

  if (valueElement) {
    if (option) {
      valueElement.textContent = option.label;
      if (option.color) {
        valueElement.style.setProperty('--trait-color', option.color);
        valueElement.classList.add('has-color');
      } else {
        valueElement.style.removeProperty('--trait-color');
        valueElement.classList.remove('has-color');
      }
      valueElement.dataset.traitValue = option.value;
    } else {
      valueElement.textContent = '—';
      valueElement.style.removeProperty('--trait-color');
      valueElement.classList.remove('has-color');
      delete valueElement.dataset.traitValue;
    }
  }
}

function ensureTraitSliderValue(trait, sliderElement, valueElement, value, fallback) {
  if (!sliderElement) {
    return;
  }
  const options = getTraitOptions(trait);
  const fallbackValue = fallback ?? options[0]?.value ?? null;
  let targetIndex = options.findIndex((option) => option.value === value);
  if (targetIndex === -1 && fallbackValue) {
    targetIndex = options.findIndex((option) => option.value === fallbackValue);
  }
  if (targetIndex === -1) {
    targetIndex = 0;
  }
  targetIndex = clamp(targetIndex, 0, Math.max(0, options.length - 1));
  sliderElement.max = String(Math.max(0, options.length - 1));
  sliderElement.value = String(targetIndex);
  updateTraitSliderDisplay(trait, sliderElement, valueElement, targetIndex);
}

function setupTraitSliderControl(trait, sliderElement, valueElement) {
  if (!sliderElement) {
    return;
  }
  const options = getTraitOptions(trait);
  const maxIndex = Math.max(0, options.length - 1);
  sliderElement.min = '0';
  sliderElement.max = String(maxIndex);
  sliderElement.step = '1';
  sliderElement.value = clamp(Number(sliderElement.value) || 0, 0, maxIndex).toString();
  sliderElement.dataset.trait = trait;
  sliderElement.disabled = options.length === 0;

  const updateDisplay = (index) => {
    updateTraitSliderDisplay(trait, sliderElement, valueElement, index);
  };

  sliderElement.addEventListener('input', () => {
    const currentIndex = clamp(Math.round(Number(sliderElement.value)), 0, maxIndex);
    sliderElement.value = String(currentIndex);
    updateDisplay(currentIndex);
    const option = options[currentIndex];
    if (option) {
      updateDwarfTrait(trait, option.value);
    }
  });

  sliderElement.addEventListener('change', () => {
    const currentIndex = clamp(Math.round(Number(sliderElement.value)), 0, maxIndex);
    sliderElement.value = String(currentIndex);
    updateDisplay(currentIndex);
  });

  updateDisplay();
}
function updateGenderButtonsUI(selectedValue) {
  const container = elements.dwarfGenderButtons;
  if (!container) {
    return;
  }
  const buttons = Array.from(container.querySelectorAll('[data-gender-value]'));
  if (buttons.length === 0) {
    return;
  }
  const fallback = dwarfOptions.gender[0]?.value;
  const targetValue = buttons.some((button) => button.dataset.genderValue === selectedValue)
    ? selectedValue
    : fallback;

  buttons.forEach((button) => {
    const isActive = button.dataset.genderValue === targetValue;
    button.classList.toggle('active', isActive);
    button.setAttribute('aria-checked', isActive ? 'true' : 'false');
    button.tabIndex = isActive ? 0 : -1;
  });
}

function updateBeardFieldState(dwarf) {
  const fieldGroup = elements.dwarfBeardFieldGroup;
  const beardSlider = elements.dwarfBeardSlider;
  if (!fieldGroup || !beardSlider) {
    return;
  }
  const isFemale = dwarf?.gender === 'female';
  fieldGroup.classList.toggle('hidden', isFemale);
  fieldGroup.setAttribute('aria-hidden', isFemale ? 'true' : 'false');
  beardSlider.disabled = isFemale;
  if (isFemale) {
    beardSlider.setAttribute('tabindex', '-1');
  } else {
    beardSlider.removeAttribute('tabindex');
  }
}

function extractFirstName(fullName) {
  if (!fullName || typeof fullName !== 'string') {
    return '';
  }
  const trimmed = fullName.trim();
  const spaceIndex = trimmed.indexOf(' ');
  if (spaceIndex > 0) {
    return trimmed.substring(0, spaceIndex);
  }
  return trimmed;
}

function isPresetDwarfFirstName(name) {
  if (!name || typeof name !== 'string') {
    return false;
  }
  return presetDwarfFirstNames.has(name.trim());
}

function generateDwarfFirstName(gender) {
  const genderKey = gender === 'female' ? 'female' : 'male';
  const namePool = dwarfNamePools[genderKey] || dwarfNamePools.male;
  if (!Array.isArray(namePool) || namePool.length === 0) {
    return gender === 'female' ? 'Domas' : 'Urist';
  }
  return pickRandomFrom(namePool, Math.random) || (gender === 'female' ? 'Domas' : 'Urist');
}

function generateDwarfName(gender, clan) {
  const firstName = generateDwarfFirstName(gender);
  if (!clan) {
    return firstName;
  }
  const clanLabel = getOptionLabel('clan', clan);
  if (!clanLabel) {
    return firstName;
  }
  const baseSurname = getPrimaryClanName(clanLabel, clan) || clanLabel;
  const clanFamilyNames = getClanFamilyNames(clan);
  const surnameOptions = Array.isArray(clanFamilyNames) && clanFamilyNames.length > 0
    ? [baseSurname, ...clanFamilyNames]
    : [baseSurname];
  const surname = pickRandomFrom(surnameOptions, Math.random) || baseSurname;
  return `${firstName} ${surname}`;
}

function createRandomDwarf() {
  const gender = Math.random() < 0.5 ? 'male' : 'female';
  const clan = Array.isArray(dwarfOptions.clan) && dwarfOptions.clan.length > 0
    ? pickRandomFrom(dwarfOptions.clan, Math.random)?.value || dwarfOptions.clan[0].value
    : null;
  const profession = Array.isArray(dwarfOptions.profession) && dwarfOptions.profession.length > 0
    ? pickRandomFrom(dwarfOptions.profession, Math.random)?.value || dwarfOptions.profession[0].value
    : null;
  const skin = Array.isArray(dwarfOptions.skin) && dwarfOptions.skin.length > 0
    ? pickRandomFrom(dwarfOptions.skin, Math.random)?.value || dwarfOptions.skin[0].value
    : 'russet';
  const eyes = Array.isArray(dwarfOptions.eyes) && dwarfOptions.eyes.length > 0
    ? pickRandomFrom(dwarfOptions.eyes, Math.random)?.value || dwarfOptions.eyes[0].value
    : 'amber';
  const hair = Array.isArray(dwarfOptions.hair) && dwarfOptions.hair.length > 0
    ? pickRandomFrom(dwarfOptions.hair, Math.random)?.value || dwarfOptions.hair[0].value
    : 'umber';
  const hairStyle = Array.isArray(dwarfOptions.hairStyle) && dwarfOptions.hairStyle.length > 0
    ? pickRandomFrom(dwarfOptions.hairStyle, Math.random)?.value || defaultHairStyleValue
    : defaultHairStyleValue;
  const head = Array.isArray(dwarfOptions.head) && dwarfOptions.head.length > 0
    ? pickRandomFrom(dwarfOptions.head, Math.random)?.value || dwarfOptions.head[0].value
    : null;
  const beard = gender === 'female'
    ? 'clean'
    : (Array.isArray(dwarfOptions.beard) && dwarfOptions.beard.length > 0
      ? pickRandomFrom(dwarfOptions.beard, Math.random)?.value || 'clean'
      : 'clean');
  
  return {
    name: generateDwarfName(gender, clan),
    gender,
    clan: clan || null,
    profession: profession || null,
    skin,
    eyes,
    hair,
    hairStyle,
    head: head || null,
    beard
  };
}

function ensureDwarfParty(options = {}) {
  const { forceReset = false } = options;
  if (!state.dwarfParty || forceReset) {
    state.dwarfParty = {
      dwarves: [],
      activeIndex: 0
    };
  }
  if (!Array.isArray(state.dwarfParty.dwarves)) {
    state.dwarfParty.dwarves = [];
  }
  if (typeof state.dwarfParty.activeIndex !== 'number' || !Number.isFinite(state.dwarfParty.activeIndex)) {
    state.dwarfParty.activeIndex = 0;
  }
  if (state.dwarfParty.dwarves.length === 0) {
    state.dwarfParty.dwarves.push(createRandomDwarf());
  }
  state.dwarfParty.activeIndex = clamp(state.dwarfParty.activeIndex, 0, Math.max(0, state.dwarfParty.dwarves.length - 1));
}

function getActiveDwarf() {
  if (!state.dwarfParty || !Array.isArray(state.dwarfParty.dwarves)) {
    return null;
  }
  return state.dwarfParty.dwarves[state.dwarfParty.activeIndex] || null;
}

function updateCustomizerUI() {
  ensureDwarfParty();
  const dwarf = getActiveDwarf();
  if (!dwarf) {
    return;
  }
  dwarf.head = resolveHeadTypeValue(dwarf.head);
  const total = state.dwarfParty.dwarves.length;
  if (elements.dwarfSlotLabel) {
    elements.dwarfSlotLabel.textContent =
      total > 1 ? `Dwarf ${state.dwarfParty.activeIndex + 1} of ${total}` : '';
  }
  if (elements.dwarfNameInput) {
    elements.dwarfNameInput.value = dwarf.name;
  }

  updateGenderButtonsUI(dwarf.gender);
  ensureSelectValue(
    elements.dwarfClanSelect,
    dwarf.clan,
    dwarfOptions.clan[0].value
  );
  ensureSelectValue(
    elements.dwarfProfessionSelect,
    dwarf.profession,
    dwarfOptions.profession[0].value
  );
  ensureTraitSliderValue(
    'skin',
    elements.dwarfSkinSlider,
    elements.dwarfSkinSliderValue,
    dwarf.skin,
    dwarfOptions.skin[0].value
  );
  ensureTraitSliderValue(
    'eyes',
    elements.dwarfEyeSlider,
    elements.dwarfEyeSliderValue,
    dwarf.eyes,
    dwarfOptions.eyes[0].value
  );
  ensureTraitSliderValue(
    'hairStyle',
    elements.dwarfHairStyleSlider,
    elements.dwarfHairStyleSliderValue,
    resolveHairStyleValue(dwarf.hairStyle),
    defaultHairStyleValue
  );
  ensureTraitSliderValue(
    'hair',
    elements.dwarfHairSlider,
    elements.dwarfHairSliderValue,
    dwarf.hair,
    dwarfOptions.hair[0].value
  );
  if (dwarf.gender === 'female' && dwarf.beard !== 'clean') {
    dwarf.beard = 'clean';
  }
  ensureTraitSliderValue(
    'beard',
    elements.dwarfBeardSlider,
    elements.dwarfBeardSliderValue,
    dwarf.beard,
    dwarfOptions.beard[0].value
  );

  updateBeardFieldState(dwarf);

    updateDwarfPortrait(dwarf, customizerDeps);
    updateDwarfTraitSummary(customizerDeps);
    updateRosterList(customizerDeps);
  }

function setActiveDwarf(index) {
  ensureDwarfParty();
  const total = state.dwarfParty.dwarves.length;
  const clampedIndex = clamp(index, 0, Math.max(0, total - 1));
  state.dwarfParty.activeIndex = clampedIndex;
  updateCustomizerUI();
}

function changeActiveDwarf(step) {
  ensureDwarfParty();
  const total = state.dwarfParty.dwarves.length;
  if (total === 0) {
    return;
  }
  const nextIndex = (state.dwarfParty.activeIndex + step + total) % total;
  setActiveDwarf(nextIndex);
}

function updateDwarfTrait(trait, value) {
  const dwarf = getActiveDwarf();
  if (!dwarf) {
    return;
  }
  if (trait === 'name') {
    dwarf.name = value;
    updateDwarfPortrait(dwarf, customizerDeps);
    updateRosterList(customizerDeps);
    return;
  }
  if (trait === 'clan') {
    const previousClanValue = dwarf.clan;
    dwarf.clan = value;
    const previousClanLabel = previousClanValue ? getOptionLabel('clan', previousClanValue) : null;
    const nextClanLabel = value ? getOptionLabel('clan', value) : null;
    const trimmedName = (dwarf.name || '').trim();
    if (nextClanLabel && trimmedName) {
      const matchesPreviousClan =
        previousClanLabel && trimmedName.endsWith(` ${previousClanLabel}`);
      const baseName = matchesPreviousClan
        ? trimmedName.slice(0, trimmedName.length - previousClanLabel.length).trim()
        : trimmedName;
      if (matchesPreviousClan || !previousClanLabel) {
        const rebuiltName = `${baseName} ${nextClanLabel}`.trim();
        dwarf.name = rebuiltName;
      }
    } else if (nextClanLabel) {
      dwarf.name = generateDwarfName(dwarf.gender, value);
    }
  } else if (editableDwarfTraits.has(trait)) {
    if (trait === 'gender') {
      const previousGender = dwarf.gender;
      const trimmedName = (dwarf.name || '').trim();
      dwarf.gender = value;
      if (value === 'female') {
        dwarf.beard = 'clean';
      }
      if (value !== previousGender && trimmedName) {
        const firstName = extractFirstName(trimmedName);
        const clanLabel = dwarf.clan ? getOptionLabel('clan', dwarf.clan) : null;
        const matchesClan = clanLabel
          ? trimmedName === `${firstName} ${clanLabel}`
          : trimmedName === firstName;
        if (firstName && matchesClan && isPresetDwarfFirstName(firstName)) {
          const newFirstName = generateDwarfFirstName(value);
          dwarf.name = clanLabel ? `${newFirstName} ${clanLabel}` : newFirstName;
        }
      }
    } else if (trait === 'head') {
      dwarf.head = resolveHeadTypeValue(value);
    } else if (trait === 'hairStyle') {
      dwarf[trait] = resolveHairStyleValue(value);
    } else if (trait === 'beard' && dwarf.gender === 'female') {
      dwarf.beard = 'clean';
    } else {
      dwarf[trait] = value;
    }
  }
  updateCustomizerUI();
}

function randomiseActiveDwarf() {
  ensureDwarfParty();
  const { activeIndex, dwarves } = state.dwarfParty;
  if (!dwarves || !dwarves[activeIndex]) {
    return;
  }
  dwarves[activeIndex] = createRandomDwarf();
  setActiveDwarf(activeIndex);
}

function isDwarfCustomizerVisible() {
  return Boolean(elements.dwarfCustomizer && !elements.dwarfCustomizer.classList.contains('hidden'));
}

function openDwarfCustomizer(options = {}) {
  const { resetParty = false } = options;
  ensureDwarfParty({ forceReset: resetParty });
  if (elements.worldInfoModal) {
    elements.worldInfoModal.classList.add('hidden');
  }
  if (elements.dwarfCustomizer) {
    elements.dwarfCustomizer.classList.remove('hidden');
  }
  updateCustomizerUI();
  const activeGenderButton = elements.dwarfGenderButtons
    ? elements.dwarfGenderButtons.querySelector('.gender-toggle-button.active') ||
      elements.dwarfGenderButtons.querySelector('.gender-toggle-button')
    : null;
  const focusTarget = elements.dwarfNameInput || activeGenderButton;
  if (focusTarget) {
    focusTarget.focus();
    if (typeof focusTarget.select === 'function') {
      focusTarget.select();
    }
  }
}

function closeDwarfCustomizer(options = {}) {
  const { keepWorldInfoHidden = false, returnFocus = false } = options;
  if (elements.dwarfCustomizer) {
    elements.dwarfCustomizer.classList.add('hidden');
  }
  if (!keepWorldInfoHidden && elements.worldInfoModal) {
    elements.worldInfoModal.classList.remove('hidden');
    if (returnFocus && elements.worldNameInput) {
      elements.worldNameInput.focus();
      elements.worldNameInput.select();
    }
  }
}

const chronologyBias = {
  age: {
    min: 2,
    max: 20,
    exponent: 1.6
  },
  year: {
    min: 0,
    max: 50000,
    exponent: 2.8,
    biasWeight: 0.65
  }
};

function biasedRandomInt(min, max, exponent = 1) {
  const lower = Math.ceil(min);
  const upper = Math.floor(max);
  if (upper <= lower) {
    return lower;
  }
  if (!Number.isFinite(exponent) || exponent <= 0) {
    return randomInt(lower, upper);
  }
  const range = upper - lower + 1;
  const skewed = Math.pow(Math.random(), exponent);
  const offset = Math.floor(skewed * range);
  return clamp(lower + offset, lower, upper);
}

function randomAge() {
  const { min, max, exponent } = chronologyBias.age;
  return biasedRandomInt(min, max, exponent);
}

function randomYear() {
  const { min, max, exponent, biasWeight = 1 } = chronologyBias.year;
  const lower = Math.ceil(min);
  const upper = Math.floor(max);
  if (upper <= lower) {
    return lower;
  }
  if (!Number.isFinite(exponent) || exponent <= 0) {
    return randomInt(lower, upper);
  }
  const clampedWeight = clamp(biasWeight, 0, 1);
  const effectiveExponent = 1 + clampedWeight * (exponent - 1);
  const quadrupleDigitThreshold = 1000;
  const maxRetries = 4;
  const highYearPenalty = 0.85;

  let year = biasedRandomInt(lower, upper, effectiveExponent);

  if (year >= quadrupleDigitThreshold) {
    let retries = 0;
    const amplifiedExponent = effectiveExponent * 1.5;
    while (
      year >= quadrupleDigitThreshold &&
      retries < maxRetries &&
      Math.random() < highYearPenalty
    ) {
      year = biasedRandomInt(lower, upper, amplifiedExponent);
      retries += 1;
    }
  }

  return year;
}

function generateRandomChronology() {
  return { year: randomYear(), age: randomAge() };
}

function isChronologyValid(chronology) {
  if (!chronology) {
    return false;
  }
  const { year, age } = chronology;
  return (
    Number.isFinite(year) &&
    Number.isFinite(age) &&
    year >= chronologyBias.year.min &&
    year <= chronologyBias.year.max &&
    age >= chronologyBias.age.min &&
    age <= chronologyBias.age.max
  );
}

function sanitizeChronologyValues(yearValue, ageValue) {
  const { min: yearMin, max: yearMax } = chronologyBias.year;
  const safeYear = clamp(Math.round(yearValue), yearMin, yearMax);
  const { min: ageMin, max: ageMax } = chronologyBias.age;
  const safeAge = clamp(Math.round(ageValue), ageMin, ageMax);
  return { year: safeYear, age: safeAge };
}

function ensureChronology() {
  if (!isChronologyValid(state.worldChronology)) {
    state.worldChronology = generateRandomChronology();
  }
  return state.worldChronology;
}

function formatOrdinal(value) {
  const mod100 = value % 100;
  if (mod100 >= 11 && mod100 <= 13) {
    return 'th';
  }
  switch (value % 10) {
    case 1:
      return 'st';
    case 2:
      return 'nd';
    case 3:
      return 'rd';
    default:
      return 'th';
  }
}

function formatChronology(year, age) {
  const ordinal = formatOrdinal(age);
  const formattedYear = Number.isFinite(year)
    ? year.toLocaleString('en-US')
    : String(year);
  return `Year ${formattedYear} of the ${age}${ordinal} Age`;
}

function getSanitisedChronologyFromInputs() {
  if (!elements.worldYearInput || !elements.worldAgeInput) {
    return null;
  }
  const parsedYear = Number.parseInt(elements.worldYearInput.value, 10);
  const parsedAge = Number.parseInt(elements.worldAgeInput.value, 10);
  if (
    Number.isNaN(parsedYear) ||
    Number.isNaN(parsedAge) ||
    parsedYear < chronologyBias.year.min ||
    parsedAge < 1
  ) {
    return null;
  }
  return sanitizeChronologyValues(parsedYear, parsedAge);
}

function updateChronologyDisplay() {
  if (!elements.worldInfoChronology) {
    return;
  }
  const inputChronology = getSanitisedChronologyFromInputs();
  if (inputChronology) {
    elements.worldInfoChronology.textContent = formatChronology(
      inputChronology.year,
      inputChronology.age
    );
    return;
  }
  if (isChronologyValid(state.worldChronology)) {
    elements.worldInfoChronology.textContent = formatChronology(
      state.worldChronology.year,
      state.worldChronology.age
    );
    return;
  }
  elements.worldInfoChronology.textContent = '—';
}

function updateWorldInfoSizeDisplay() {
  if (!elements.worldInfoSize) {
    return;
  }
  const preset = getMapSizePreset(state.settings.mapSize);
  elements.worldInfoSize.textContent = getMapSizeLabel(
    preset,
    state.settings.width,
    state.settings.height
  );
}

function getWorldGenerationProfile(key) {
  if (key && worldGenerationProfiles[key]) {
    return worldGenerationProfiles[key];
  }
  return worldGenerationProfiles[defaultWorldGenerationType];
}

function getWorldGenerationProfileLabel(key) {
  const profile = getWorldGenerationProfile(key);
  if (profile && profile.label) {
    return profile.label;
  }
  const fallbackProfile = worldGenerationProfiles[defaultWorldGenerationType];
  return fallbackProfile && fallbackProfile.label ? fallbackProfile.label : 'Normal';
}

function ensureLandMaskForProfile(profileKey) {
  const profile = getWorldGenerationProfile(profileKey);
  if (!profile) {
    return state.landMask;
  }
  const cacheKey = profile.key;
  if (landMaskCache.has(cacheKey)) {
    const cachedMask = landMaskCache.get(cacheKey);
    if (cachedMask) {
      state.landMask = cachedMask;
    }
    return cachedMask || state.landMask;
  }
  if (typeof profile.createMask === 'function') {
    const generatedMask = profile.createMask();
    if (generatedMask) {
      landMaskCache.set(cacheKey, generatedMask);
      state.landMask = generatedMask;
      return generatedMask;
    }
  }
  if (cacheKey === defaultWorldGenerationType && state.landMask) {
    landMaskCache.set(cacheKey, state.landMask);
    return state.landMask;
  }
  if (cacheKey !== defaultWorldGenerationType) {
    return ensureLandMaskForProfile(defaultWorldGenerationType);
  }
  return state.landMask;
}

function setWorldGenerationType(type) {
  const profile = getWorldGenerationProfile(type);
  state.settings.worldGenerationType = profile.key;
  ensureLandMaskForProfile(profile.key);
  if (elements.worldGenerationTypeSelect) {
    elements.worldGenerationTypeSelect.value = profile.key;
  }
  if (elements.worldInfoGenerationTypeSelect) {
    elements.worldInfoGenerationTypeSelect.value = profile.key;
  }
  updateWorldInfoGenerationTypeDisplay();
}

function updateWorldInfoGenerationTypeDisplay() {
  if (!elements.worldInfoGenerationType) {
    return;
  }
  const label = getWorldGenerationProfileLabel(state.settings.worldGenerationType);
  elements.worldInfoGenerationType.textContent = label;
}

function updateWorldInfoSeedDisplay(seedValue) {
  if (!elements.worldInfoSeed) {
    return;
  }
  const trimmed = typeof seedValue === 'string' ? seedValue.trim() : '';
  elements.worldInfoSeed.textContent = trimmed || 'Random';
}

function applyFormSettings() {
  const sliderInputHandlers = [
    {
      input: elements.forestFrequencyInput,
      valueElement: elements.forestFrequencyValue,
      defaultValue: defaultForestFrequency,
      key: 'forestFrequency'
    },
    {
      input: elements.mountainFrequencyInput,
      valueElement: elements.mountainFrequencyValue,
      defaultValue: defaultMountainFrequency,
      key: 'mountainFrequency'
    },
    {
      input: elements.riverFrequencyInput,
      valueElement: elements.riverFrequencyValue,
      defaultValue: 50,
      key: 'riverFrequency'
    },
    {
      input: elements.humanSettlementFrequencyInput,
      valueElement: elements.humanSettlementFrequencyValue,
      defaultValue: 50,
      key: 'humanSettlementFrequency'
    },
    {
      input: elements.dwarfSettlementFrequencyInput,
      valueElement: elements.dwarfSettlementFrequencyValue,
      defaultValue: 50,
      key: 'dwarfSettlementFrequency'
    },
    {
      input: elements.woodElfSettlementFrequencyInput,
      valueElement: elements.woodElfSettlementFrequencyValue,
      defaultValue: 50,
      key: 'woodElfSettlementFrequency'
    },
    {
      input: elements.lizardmenSettlementFrequencyInput,
      valueElement: elements.lizardmenSettlementFrequencyValue,
      defaultValue: 50,
      key: 'lizardmenSettlementFrequency'
    }
  ];

  sliderInputHandlers.forEach(({ input, valueElement, defaultValue, key }) => {
    if (!input) {
      return;
    }
    const rawValue = Number.parseInt(input.value, 10);
    const sanitisedValue = sanitizeFrequencyValue(
      Number.isNaN(rawValue) ? state.settings[key] : rawValue,
      defaultValue
    );
    state.settings[key] = sanitisedValue;
    if (input.value !== sanitisedValue.toString()) {
      input.value = sanitisedValue.toString();
    }
    updateFrequencyDisplay(valueElement, sanitisedValue);
  });

  const selectedMapSizeKey = elements.mapSizeSelect
    ? elements.mapSizeSelect.value
    : state.settings.mapSize;
  const mapSizePreset = getMapSizePreset(selectedMapSizeKey);
  applyMapSizePresetToState(state, mapSizePreset);
  if (elements.mapSizeSelect) {
    elements.mapSizeSelect.value = state.settings.mapSize;
  }
  if (elements.worldMapSizeSelect) {
    elements.worldMapSizeSelect.value = state.settings.mapSize;
  }
  updateWorldInfoSizeDisplay();

  const selectedGenerationType = elements.worldGenerationTypeSelect
    ? elements.worldGenerationTypeSelect.value
    : state.settings.worldGenerationType;
  setWorldGenerationType(selectedGenerationType);

  const seedInputValue = elements.seedInput ? elements.seedInput.value.trim() : '';
  if (elements.seedInput && seedInputValue !== elements.seedInput.value) {
    elements.seedInput.value = seedInputValue;
  }
  state.settings.seedString = seedInputValue;
  let finalSeed = seedInputValue;
  if (!finalSeed) {
    finalSeed = ensureSeedString();
    if (elements.seedInput) {
      elements.seedInput.value = finalSeed;
    }
  }
  state.settings.lastSeedString = finalSeed;
  updateWorldInfoSeedDisplay(finalSeed);
  if (elements.worldSeedInput && elements.worldSeedInput !== elements.seedInput) {
    elements.worldSeedInput.value = finalSeed;
  }

  return {
    mapSize: state.settings.mapSize,
    worldGenerationType: state.settings.worldGenerationType,
    seed: finalSeed
  };
}

function ensureSeedString() {
  const trimmed = (state.settings.seedString || '').trim();
  if (trimmed) {
    state.settings.seedString = trimmed;
    return trimmed;
  }
  const generated = randomSeedString();
  state.settings.seedString = generated;
  return generated;
}

function openWorldInfoModal() {
  state.dwarfParty = {
    dwarves: [],
    activeIndex: 0
  };
  if (
    !elements.worldInfoModal ||
    !elements.worldInfoSize ||
    !elements.worldInfoSeed ||
    !elements.worldNameInput
  ) {
    if (!state.worldName) {
      state.worldName = getRandomWorldName();
    }
    ensureChronology();
    beginGame();
    ensureMusicStarted();
    return;
  }
  const sizePreset = getMapSizePreset(state.settings.mapSize);
  applyMapSizePresetToState(state, sizePreset);
  if (elements.worldMapSizeSelect) {
    elements.worldMapSizeSelect.value = state.settings.mapSize;
  }
  if (elements.mapSizeSelect) {
    elements.mapSizeSelect.value = state.settings.mapSize;
  }
  updateWorldInfoSizeDisplay();
  if (elements.worldInfoGenerationTypeSelect) {
    elements.worldInfoGenerationTypeSelect.value = state.settings.worldGenerationType;
  }
  updateWorldInfoGenerationTypeDisplay();

  const seed = ensureSeedString();
  state.settings.lastSeedString = seed;
  if (elements.worldSeedInput) {
    elements.worldSeedInput.value = seed;
  }
  if (elements.seedInput) {
    elements.seedInput.value = seed;
  }
  updateWorldInfoSeedDisplay(seed);

  const chronology = ensureChronology();
  if (elements.worldYearInput) {
    elements.worldYearInput.value = chronology.year.toString();
  }
  if (elements.worldAgeInput) {
    elements.worldAgeInput.value = chronology.age.toString();
  }
  updateChronologyDisplay();

  const currentName = (state.worldName || '').trim();
  const nameToUse = currentName || getRandomWorldName();
  state.worldName = nameToUse;
  elements.worldNameInput.value = nameToUse;

  if (elements.titleScreen) {
    elements.titleScreen.classList.add('hidden');
  }
  elements.worldInfoModal.classList.remove('hidden');
  ensureMusicStarted();
  const focusInput = () => {
    if (!elements.worldNameInput) {
      return;
    }
    elements.worldNameInput.focus();
    elements.worldNameInput.select();
  };
  if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
    window.requestAnimationFrame(focusInput);
  } else {
    focusInput();
  }
}

function closeWorldInfoModal(options = {}) {
  const { returnFocus = false, keepTitleHidden = false } = options;
  if (elements.worldInfoModal) {
    elements.worldInfoModal.classList.add('hidden');
  }
  if (
    !keepTitleHidden &&
    elements.gameContainer &&
    elements.gameContainer.classList.contains('hidden')
  ) {
    showTitleScreen();
    state.settings.seedString = '';
  }
  if (returnFocus && elements.startButton) {
    elements.startButton.focus();
  }
}

function showTitleScreen(options = {}) {
  const { focusStartButton = false } = options;
  if (elements.gameContainer) {
    elements.gameContainer.classList.add('hidden');
    elements.gameContainer.setAttribute('aria-hidden', 'true');
  }
  if (elements.titleScreen) {
    elements.titleScreen.classList.remove('hidden');
    elements.titleScreen.setAttribute('aria-hidden', 'false');
  }
  if (focusStartButton && elements.startButton && typeof elements.startButton.focus === 'function') {
    try {
      elements.startButton.focus({ preventScroll: true });
    } catch (_) {
      elements.startButton.focus();
    }
  }
}

function estimateSeaLevels(elevationField, targetWaterRatio = 0.45) {
  const sorted = Array.from(elevationField).sort((a, b) => a - b);
  const total = sorted.length;
  if (total === 0) {
    return { seaLevel: 0.42, deepSeaLevel: 0.24 };
  }
  const clampedRatio = clamp(targetWaterRatio, 0.2, 0.8);
  const waterIndex = Math.min(total - 1, Math.max(0, Math.floor(total * clampedRatio)));
  const seaLevel = clamp(sorted[waterIndex], 0.25, 0.65);
  const deepSeaLevel = clamp(seaLevel - 0.18, 0.05, seaLevel - 0.05);
  return { seaLevel, deepSeaLevel };
}

const viewState = {
  scale: 1,
  translateX: 0,
  translateY: 0,
  minScale: 0.25,
  maxScale: 6,
  containScale: 1,
  coverScale: 1,
  wrapperSize: { width: 0, height: 0 },
  worldSize: { width: 0, height: 0 },
  hasInteracted: false
};

const dwarfholdScreenConfig = {
  baseTileSize: 28,
  minTileSize: 8,
  maxCanvasSize: 960,
  viewportPadding: 48
};

const localMapDefaultMessage = 'Click the world map to open a local preview.';

const structureDetailsTabIds = ['main', 'history', 'features', 'economy'];

const structureDetailsState = {
  visible: false,
  activeTab: structureDetailsTabIds[0],
  tabContent: {}
};

const settlementHistoryFractionBands = [
  [0.78, 0.96],
  [0.6, 0.78],
  [0.42, 0.59],
  [0.28, 0.41],
  [0.12, 0.27],
  [0.05, 0.11],
  [0.02, 0.05]
];

const settlementHistoryDirections = ['western', 'eastern', 'northern', 'southern'];
const settlementHistoryAuthorityTitles = [
  'King',
  'Queen',
  'Duke',
  'Duchess',
  'Prince',
  'Princess',
  'Marshal',
  'High Steward',
  'Archduke',
  'Lord Protector'
];
const settlementHistoryConflictNames = [
  'Goblin Wars',
  'Red Banner Rebellion',
  'War of Falling Ash',
  'Stormshroud Campaign',
  'Skysunder Crusade',
  'War of Seven Bells',
  'Bronze Crown Conflict'
];
const settlementHistoryTownLandmarks = [
  'Brass Lantern Tavern',
  'Stonebridge Inn',
  'Silver Anvil Foundry',
  'Traveler\'s Resthall',
  'Copper Cup Brewery',
  'Singing Sails Guildhall',
  'Old Millhouse Bakery'
];
const settlementHistoryGuardTitles = ['guard captain', 'sheriff', 'magistrate', 'constable', 'watchmarshal'];
const settlementHistoryShrineDedications = [
  'Saint Lyra',
  'the Dawnmother',
  'the Winter Father',
  'the Lady of Lanterns',
  'the Storm Herald',
  'Saint Corvin',
  'the Emberwatcher'
];
const settlementHistoryFestivalNames = [
  'Festival of Sails',
  'Amber Harvest Fair',
  'Night of Lanterns',
  'Seven Bells Jubilee',
  'Riverblossom Revel',
  'Moonrise Masquerade'
];
const settlementHistoryTradeGoods = [
  'grain tithes from the riverlands',
  'silver ingots from the hill mines',
  'saffron caravans from the south',
  'amberglass ferried from the coast',
  'rare dyes bargained from distant bazaars',
  'oak barrels packed with aged whiskey'
];

const dwarvenBrewNames = [
  "Bralwra's Brew",
  'Stonebeard Reserve',
  'Deepdelver Stout',
  'Molten Ember Ale',
  'Rune-Etched Porter',
  'Glittergold Mead'
];
const dwarvenAncientEnemies = [
  'an orc war-host',
  'a troll legion',
  'a goblin horde',
  'a duergar battalion',
  'an army of ogres'
];
const dwarvenDragonNames = ['Smaug', 'Glaurag', 'Vythrak', 'Azroth', 'Skarlith', 'Thauriss'];
const dwarvenGreatWorks = [
  'Deepgate Bastion',
  'Skyforge Lifts',
  'Anvilspan Bridge',
  'Underking Vaults',
  'Rune-lit Aqueduct',
  'Sunguard Bastion'
];

const woodElfEnemyPhrases = [
  'ironwood poachers',
  'blight-touched beasts',
  'orc fire-raisers',
  'necromancer cultists',
  'ashen drakes'
];
const woodElfRitualNames = [
  'Rite of the Whispered Glade',
  'Dance of Falling Stars',
  'Moonbloom Vigil',
  'Song of the Silver Bough',
  'Heartroot Concord'
];
const woodElfPhenomena = [
  'a comet painted the canopy in emerald light',
  'the Heartroot awoke and sang through the leaves',
  'starlight fell as gentle rain upon the groves',
  'faerie lights braided between every bough',
  'the ancient ents marched in solemn procession'
];

const lizardmenPortents = [
  'the eclipse of twin suns',
  'a storm of burning glass',
  'the rising of the obsidian tide',
  'the awakening drums of Xol-Quan',
  'a rain of jade scales'
];
const lizardmenCampaigns = [
  'the War of Emerald Spears',
  'the Sunblood Crusade',
  'the Tide of Sacred Fire',
  'the Reaping of Broken Fangs',
  'the Sky-Serpent Pursuit'
];

const towerAlarmEvents = [
  'a border alarm rallied every banner to the walls',
  'wyvern riders were spotted and the beacons blazed all night',
  'a tide of raiders tested the battlements before breaking',
  'a rogue sorcerer assaulted the gate with conjured stormfire'
];
const towerVisitors = [
  'envoys from the capital',
  'a circle of battle mages',
  'a company of griffon knights',
  'a caravan of dwarven quartermasters'
];

const wizardTowerCatastrophes = [
  'a summoning tore open a screaming rift',
  'an experiment transmuted the east wing into crystal',
  'binding runes failed and phantoms prowled the halls',
  'a demonic pact backfired and scorched the courtyards'
];
const wizardTowerExperiments = [
  'the Sevenfold Convergence',
  'the Midnight Ascension',
  'the Silent Hour Ritual',
  'the Voidglass Synthesis',
  'the Oathbinding of Shadows'
];

const mineIncidents = [
  'a cave-in sealed the lower galleries for a month',
  'slag fires raged for three days before being quenched',
  'a vein collapse released pockets of choking gas',
  'a swarm of tunnel horrors forced the miners to retreat'
];
const mineDiscoveries = [
  'a glittering vein of mithril ore',
  'ancient runic vaults packed with relics',
  'crystal seams that hummed with latent magic',
  'a buried river that now powers waterwheels'
];

const goblinSchemes = [
  'cobbled together a barbed chariot train',
  'stole temple bells and hung them as trophies',
  'captured a dwarven envoy for ransom',
  'mapped a secret tunnel into a rival hold'
];
const goblinRaids = [
  'raided the river caravans',
  'burned the frontier farms',
  'ambushed a company of knights',
  'looted a royal tithe train'
];

const genericHistoryMoments = [
  'an uncanny aurora shimmered overhead for seven nights',
  'a comet omen sent every sage into frantic study',
  'a dragon shadow passed overhead, but the beast never descended',
  'storm floods forced the folk to rebuild their bridges',
  'wandering heroes left behind a trove of strange relics'
];

function normalizeStructureDetailsTabId(tabId) {
  if (typeof tabId !== 'string') {
    return structureDetailsTabIds[0];
  }
  const normalized = tabId.trim().toLowerCase();
  return structureDetailsTabIds.includes(normalized) ? normalized : structureDetailsTabIds[0];
}

function getStructureDetailsPlaceholder(message) {
  const resolvedMessage =
    typeof message === 'string' && message.trim().length > 0
      ? message.trim()
      : 'No additional records are available for this settlement yet.';
  return `
    <div class="structure-details-column structure-details-column--primary">
      <p class="structure-details-empty structure-details-empty--standalone">${escapeHtml(resolvedMessage)}</p>
    </div>
  `;
}

function normalizeSettlementTypeForHistory(details, tile) {
  const detailType = typeof details?.type === 'string' ? details.type.trim() : '';
  if (detailType) {
    return detailType.toLowerCase();
  }
  const structureValue = typeof tile?.structure === 'string' ? tile.structure.trim() : '';
  if (structureValue) {
    return structureValue.toLowerCase();
  }
  const displayType = typeof details?.displayType === 'string' ? details.displayType.trim() : '';
  if (displayType) {
    return displayType.replace(/\s+/g, '').toLowerCase();
  }
  return 'settlement';
}

function resolveHistorySpan(foundedYearsAgo, rng, options = {}) {
  if (Number.isFinite(foundedYearsAgo) && foundedYearsAgo >= 1) {
    return Math.max(1, Math.round(foundedYearsAgo));
  }
  const min = Math.max(1, Math.round(options.min ?? 40));
  const max = Math.max(min, Math.round(options.max ?? min + 160));
  const span = max - min;
  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const value = min + Math.round(randomFn() * span);
  return Math.max(1, value);
}

function resolveHistoryEventCount(rng, options = {}) {
  const min = Math.max(1, Math.floor(options.min ?? 20));
  const max = Math.max(min, Math.floor(options.max ?? 80));
  if (max === min) {
    return min;
  }
  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const span = max - min + 1;
  const offset = Math.floor(randomFn() * span);
  return Math.max(min, Math.min(max, min + offset));
}

function randomBetween(min, max, rng) {
  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const lower = Number.isFinite(min) ? min : 0;
  const upper = Number.isFinite(max) ? max : lower;
  if (upper <= lower) {
    return lower;
  }
  return lower + (upper - lower) * randomFn();
}

function generateHistoryYearSet(horizon, count, rng) {
  if (!Number.isFinite(horizon) || horizon <= 1 || !Number.isFinite(count) || count <= 0) {
    return [];
  }
  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const usableHorizon = Math.max(2, Math.round(horizon));
  const desiredCount = Math.max(0, Math.floor(count));
  const used = new Set();
  const results = [];

  for (let i = 0; results.length < desiredCount && i < settlementHistoryFractionBands.length; i += 1) {
    const band = settlementHistoryFractionBands[i];
    if (!Array.isArray(band) || band.length === 0) {
      continue;
    }
    const [bandStart, bandEnd] = band;
    const minFraction = Math.min(bandStart ?? 0, bandEnd ?? 0.05);
    const maxFraction = Math.max(bandStart ?? 0, bandEnd ?? 0.05);
    const fraction = randomBetween(minFraction, maxFraction, randomFn);
    let candidate = Math.round(usableHorizon * fraction);
    if (candidate >= usableHorizon) {
      candidate = Math.max(1, usableHorizon - (i + 1));
    }
    candidate = Math.max(1, candidate);
    while (candidate >= 1 && (candidate >= usableHorizon || used.has(candidate))) {
      candidate -= 1;
    }
    if (candidate >= 1 && !used.has(candidate)) {
      used.add(candidate);
      results.push(candidate);
    }
  }

  let fallback = usableHorizon - 1;
  while (results.length < desiredCount && fallback >= 1) {
    if (!used.has(fallback)) {
      used.add(fallback);
      results.push(fallback);
    }
    fallback -= 1;
  }

  return results.sort((a, b) => b - a);
}

function createHistoryEntry(yearsAgo, description, label = null) {
  if (!description || typeof description !== 'string') {
    return null;
  }
  const trimmedDescription = description.trim();
  if (!trimmedDescription) {
    return null;
  }
  const resolvedYearsAgo = Number.isFinite(yearsAgo) ? Math.max(1, Math.round(yearsAgo)) : null;
  const resolvedLabel = typeof label === 'string' && label.trim().length > 0 ? label.trim() : null;
  return { yearsAgo: resolvedYearsAgo, description: trimmedDescription, label: resolvedLabel };
}

function pickLabelFromOptions(options, rng) {
  if (!Array.isArray(options) || options.length === 0) {
    return null;
  }
  const choice = pickRandomFrom(options, rng);
  if (typeof choice === 'string') {
    return choice;
  }
  if (choice && typeof choice.label === 'string') {
    return choice.label;
  }
  return null;
}

function selectHistoryTemplates(templateFns, count, rng) {
  if (!Array.isArray(templateFns) || templateFns.length === 0 || count <= 0) {
    return [];
  }
  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const pool = templateFns.slice();
  const selections = [];
  for (let i = 0; i < count; i += 1) {
    if (pool.length === 0) {
      pool.push(...templateFns);
    }
    if (pool.length === 0) {
      break;
    }
    const index = Math.floor(randomFn() * pool.length);
    const clampedIndex = Math.max(0, Math.min(pool.length - 1, index));
    const [template] = pool.splice(clampedIndex, 1);
    if (typeof template === 'function') {
      selections.push(template);
    }
  }
  return selections;
}

function createSettlementHistoryContext(tile, details, context, rng) {
  const nameCandidate = typeof details?.name === 'string' && details.name.trim().length > 0 ? details.name.trim() : null;
  const displayCandidate =
    typeof details?.displayType === 'string' && details.displayType.trim().length > 0
      ? details.displayType.trim()
      : formatStructureDetailLabel(details?.type);
  const settlementName = nameCandidate || tile?.structureName || 'Settlement';
  const displayType = displayCandidate || 'Settlement';
  const kindLower = displayType.toLowerCase();
  const normalizedType = normalizeSettlementTypeForHistory(details, tile);
  const prominentClan =
    typeof details?.prominentClan === 'string' && details.prominentClan.trim().length > 0
      ? details.prominentClan.trim()
      : null;
  const prominentGroup =
    typeof details?.prominentGroup === 'string' && details.prominentGroup.trim().length > 0
      ? details.prominentGroup.trim()
      : prominentClan;
  const rulerTitle =
    typeof details?.ruler?.title === 'string' && details.ruler.title.trim().length > 0
      ? details.ruler.title.trim()
      : typeof details?.ruler?.label === 'string' && details.ruler.label.trim().length > 0
      ? details.ruler.label.trim()
      : null;
  const rulerName =
    typeof details?.ruler?.name === 'string' && details.ruler.name.trim().length > 0
      ? details.ruler.name.trim()
      : null;
  const regionName = typeof tile?.areaName === 'string' && tile.areaName.trim().length > 0 ? tile.areaName.trim() : null;
  const chronologyYear = Number.isFinite(state?.worldChronology?.year)
    ? Math.round(state.worldChronology.year)
    : null;
  const foundedYearsAgo = Number.isFinite(details?.foundedYearsAgo)
    ? Math.max(1, Math.round(details.foundedYearsAgo))
    : null;
  const randomFn = typeof rng === 'function' ? rng : Math.random;

  return {
    name: settlementName,
    displayType,
    kindLower,
    type: normalizedType,
    classification: details?.classification || null,
    prominentClan,
    prominentGroup,
    hallmark: details?.hallmark || null,
    rulerTitle,
    rulerName,
    regionName,
    currentYear: chronologyYear,
    foundedYearsAgo,
    details,
    tile,
    context,
    rng: randomFn
  };
}

function generateTownPersonName(rng) {
  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const pool = [];
  if (Array.isArray(townFirstNamePools?.male)) {
    pool.push(...townFirstNamePools.male);
  }
  if (Array.isArray(townFirstNamePools?.female)) {
    pool.push(...townFirstNamePools.female);
  }
  if (Array.isArray(townFirstNamePools?.neutral)) {
    pool.push(...townFirstNamePools.neutral);
  }
  const first = pickRandomFrom(pool, randomFn) || 'Aldric';
  const last = pickRandomFrom(townProminentFamilyNames, randomFn) || 'Ambermere';
  if (randomFn() < 0.35) {
    return `Old ${first}`;
  }
  return `${first} ${last}`;
}

function generateRealmAuthorityName(rng) {
  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const title = pickRandomFrom(settlementHistoryAuthorityTitles, randomFn) || 'King';
  const pool = [];
  if (Array.isArray(townFirstNamePools?.male)) {
    pool.push(...townFirstNamePools.male);
  }
  if (Array.isArray(townFirstNamePools?.female)) {
    pool.push(...townFirstNamePools.female);
  }
  if (Array.isArray(townFirstNamePools?.neutral)) {
    pool.push(...townFirstNamePools.neutral);
  }
  const first = pickRandomFrom(pool, randomFn) || 'Garran';
  const last = pickRandomFrom(townProminentFamilyNames, randomFn) || 'Stormholt';
  return `${title} ${first} ${last}`;
}

function generateTownLandmarkName(rng) {
  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const name = pickRandomFrom(settlementHistoryTownLandmarks, randomFn) || 'Brass Lantern Tavern';
  return `the ${name}`;
}

function generateTownFestivalName(rng) {
  const randomFn = typeof rng === 'function' ? rng : Math.random;
  return pickRandomFrom(settlementHistoryFestivalNames, randomFn) || 'Harvest Fair';
}

function generateLoreDwarfName(rng, options = {}) {
  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const pool = [];
  if (Array.isArray(dwarfNamePools?.male)) {
    pool.push(...dwarfNamePools.male);
  }
  if (Array.isArray(dwarfNamePools?.female)) {
    pool.push(...dwarfNamePools.female);
  }
  const first = pickRandomFrom(pool, randomFn) || 'Urist';
  const clanName =
    options?.clan && typeof options.clan === 'string'
      ? options.clan
      : pickLabelFromOptions(dwarfClanOptions, randomFn) || 'Stonebeard';
  if (options?.singleName) {
    return first;
  }
  return `${first} ${clanName}`;
}

function generateDragonName(rng) {
  const randomFn = typeof rng === 'function' ? rng : Math.random;
  return pickRandomFrom(dwarvenDragonNames, randomFn) || 'Smaug';
}

function generateHistoryFromTemplates(years, templateFns, context, rng) {
  if (!Array.isArray(years) || years.length === 0 || !Array.isArray(templateFns) || templateFns.length === 0) {
    return [];
  }
  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const events = [];
  const available = templateFns.slice();
  years.forEach((year) => {
    let description = null;
    let attempts = 0;
    while (!description && attempts < templateFns.length * 2) {
      if (available.length === 0) {
        available.push(...templateFns);
      }
      if (available.length === 0) {
        break;
      }
      const index = Math.floor(randomFn() * available.length);
      const clampedIndex = Math.max(0, Math.min(available.length - 1, index));
      const [template] = available.splice(clampedIndex, 1);
      attempts += 1;
      if (typeof template !== 'function') {
        continue;
      }
      const result = template(context, randomFn);
      if (typeof result === 'string' && result.trim().length > 0) {
        description = result.trim();
      }
    }
    if (description) {
      const entry = createHistoryEntry(year, description);
      if (entry) {
        events.push(entry);
      }
    }
  });
  return events;
}

function generateHumanSettlementHistory(context, rng) {
  const horizon = resolveHistorySpan(context.foundedYearsAgo, rng, { min: 40, max: 420 });
  const events = [];
  if (horizon) {
    const regionPhrase = context.regionName ? ` near ${context.regionName}` : '';
    events.push(
      createHistoryEntry(horizon, `${context.name} was founded${regionPhrase}.`)
    );
  }
  const eventCount = resolveHistoryEventCount(rng);
  const additionalYears = generateHistoryYearSet(horizon, eventCount, rng);
  const templateFns = [
    (ctx, randomFn) =>
      `the entire ${ctx.kindLower} militia was conscripted by ${generateRealmAuthorityName(randomFn)} to fight in the ${
        pickRandomFrom(settlementHistoryConflictNames, randomFn) || 'Goblin Wars'
      }.`,
    (ctx) => `a major famine left nearly half the ${ctx.kindLower} dead or gone.`,
    (ctx, randomFn) =>
      `${generateTownPersonName(randomFn)} opened ${generateTownLandmarkName(randomFn)}, and it still welcomes travelers today.`,
    (ctx, randomFn) =>
      `townsfolk dragged a corrupt ${pickRandomFrom(settlementHistoryGuardTitles, randomFn) || 'guard captain'} from office and reclaimed the watch.`,
    (ctx, randomFn) => {
      const threatFn = pickRandomFrom(
        [
          () =>
            `orc raiders burned the ${pickRandomFrom(settlementHistoryDirections, randomFn) || 'western'} quarter before the watch rallied.`,
          () => `goblin warbands pillaged the granaries until the townsfolk drove them into the river.`,
          () => `a cabal of cultists set fire to the market square before being unmasked.`,
          () => `bandit companies seized the road tolls until militia rode them down.`,
          () => `a flight of wyverns scorched the rooftops before archers brought them down.`
        ],
        randomFn
      );
      return threatFn ? threatFn() : null;
    },
    (ctx, randomFn) => {
      const goods = pickRandomFrom(settlementHistoryTradeGoods, randomFn);
      return goods ? `merchants brokered a charter guaranteeing ${goods}.` : null;
    },
    (ctx, randomFn) =>
      `the ${generateTownFestivalName(randomFn)} was first celebrated with bonfires on the green.`,
    (ctx, randomFn) => {
      const shrine = pickRandomFrom(settlementHistoryShrineDedications, randomFn);
      return shrine ? `a shrine to ${shrine} was dedicated, drawing pilgrims from afar.` : null;
    },
    (ctx, randomFn) => {
      if (!ctx.prominentGroup) {
        return null;
      }
      return `${ctx.prominentGroup} seized control of the guild council for a generation.`;
    },
    (ctx, randomFn) => {
      const guild = pickRandomFrom(townGuildOptions, randomFn);
      const guildLabel = typeof guild === 'string' ? guild : guild?.label;
      return guildLabel ? `the ${guildLabel} received its royal charter.` : null;
    }
  ];

  events.push(...generateHistoryFromTemplates(additionalYears, templateFns, context, rng));
  return events;
}

function generateDwarvenSettlementHistory(context, rng, options = {}) {
  const fallbackRange = options?.fallbackRange || { min: 180, max: 680 };
  const horizon = resolveHistorySpan(context.foundedYearsAgo, rng, fallbackRange);
  const clanName = context.prominentClan || pickLabelFromOptions(dwarfClanOptions, rng) || 'Stonebeard';
  const events = [];
  if (horizon) {
    events.push(
      createHistoryEntry(
        horizon,
        `${context.name} was founded by ${generateLoreDwarfName(rng, { clan: clanName })} of Clan ${clanName}.`
      )
    );
  }

  const eventCount = resolveHistoryEventCount(rng);
  const additionalYears = generateHistoryYearSet(horizon, eventCount, rng);
  const templateFns = [
    (ctx, randomFn) =>
      `${pickRandomFrom(dwarvenAncientEnemies, randomFn) || 'an orc war-host'} lay siege to the gates, but the defenders held firm.`,
    (ctx, randomFn) =>
      `the dragon ${generateDragonName(randomFn)} scorched the upper terraces before being driven into the deeps.`,
    (ctx, randomFn) => `${pickRandomFrom(dwarvenBrewNames, randomFn) || "Bralwra's Brew"} was first brewed in the hold's brass halls.`,
    (ctx, randomFn) => {
      const guildLabel = pickLabelFromOptions(dwarfGuildOptions, randomFn);
      return guildLabel ? `the ${guildLabel} forged a new charter beneath the basalt vaults.` : null;
    },
    (ctx) => `the ${clanName} Clan rose to become the largest clan in the hold.`,
    (ctx, randomFn) => `stonewrights completed the ${pickRandomFrom(dwarvenGreatWorks, randomFn) || 'Deepgate Bastion'}.`,
    (ctx, randomFn) =>
      `Thane ${generateLoreDwarfName(randomFn, { clan: clanName })} fell in battle; ${generateLoreDwarfName(randomFn, {
        clan: clanName
      })} took up the mantle of ${context.rulerTitle || 'Thane'}.`,
    (ctx, randomFn) => {
      const trove = pickRandomFrom(
        ['glimmering mithril', 'forgotten rune-stones', 'ancestral relics', 'sealed horrors now entombed'],
        randomFn
      );
      return trove ? `miners breached an ancient vault filled with ${trove}.` : null;
    }
  ];

  events.push(...generateHistoryFromTemplates(additionalYears, templateFns, context, rng));

  if (options.variant === 'occupied') {
    const recentYear =
      Math.min(...additionalYears, Math.max(1, Math.round(horizon * 0.22))) ||
      Math.max(1, Math.round(horizon * 0.22));
    const occupier = pickRandomFrom(
      ['an orc warlord', 'a duergar tyrant', 'a dragon cult', 'hobgoblin legates'],
      rng
    );
    events.push(createHistoryEntry(recentYear, `${occupier || 'raiders'} seized the hold and drove the dwarves into exile.`));
  } else if (options.variant === 'ruined') {
    const collapseYear =
      Math.min(...additionalYears, Math.max(1, Math.round(horizon * 0.18))) ||
      Math.max(1, Math.round(horizon * 0.18));
    events.push(createHistoryEntry(collapseYear, 'cataclysmic quakes shattered the underways and toppled the great halls.'));
  } else if (options.variant === 'abandoned') {
    const sealYear =
      Math.min(...additionalYears, Math.max(1, Math.round(horizon * 0.25))) ||
      Math.max(1, Math.round(horizon * 0.25));
    events.push(createHistoryEntry(sealYear, 'the last thane sealed the gates and led the clans to safer halls.'));
  }

  return events;
}

function generateWoodElfSettlementHistory(context, rng) {
  const horizon = resolveHistorySpan(context.foundedYearsAgo, rng, { min: 140, max: 520 });
  const events = [];
  if (horizon) {
    events.push(createHistoryEntry(horizon, `${context.name} took root beneath the elder trees.`));
  }
  const eventCount = resolveHistoryEventCount(rng);
  const additionalYears = generateHistoryYearSet(horizon, eventCount, rng);
  const templateFns = [
    (ctx, randomFn) => {
      const circle = pickRandomFrom(woodElfGroveCircleNames, randomFn) || 'Circle of the Silver Bough';
      return `the ${circle} sealed a rift to the Feywild.`;
    },
    (ctx, randomFn) =>
      `wardens drove back ${pickRandomFrom(woodElfEnemyPhrases, randomFn) || 'ironwood poachers'} from the sacred trees.`,
    (ctx, randomFn) => `${pickRandomFrom(woodElfRitualNames, randomFn) || 'Moonbloom Vigil'} was first danced beneath the luminous canopy.`,
    (ctx, randomFn) => `${pickRandomFrom(woodElfPhenomena, randomFn) || 'starlight fell through every leaf'}.`,
    (ctx, randomFn) => {
      const visitor = pickRandomFrom(['dwarven emissaries', 'human archdruids', 'griffon riders', 'arcane sages'], randomFn);
      return visitor ? `${visitor} were welcomed into the grove for counsel.` : null;
    },
    (ctx, randomFn) => {
      if (!ctx.prominentGroup) {
        return null;
      }
      return `the ${ctx.prominentGroup} renewed their oath to guard the Heartroot.`;
    }
  ];

  events.push(...generateHistoryFromTemplates(additionalYears, templateFns, context, rng));
  return events;
}

function generateLizardmenSettlementHistory(context, rng) {
  const horizon = resolveHistorySpan(context.foundedYearsAgo, rng, { min: 160, max: 520 });
  const events = [];
  if (horizon) {
    events.push(createHistoryEntry(horizon, `${context.name} was raised as a sacred ${context.displayType.toLowerCase()}.`));
  }
  const eventCount = resolveHistoryEventCount(rng);
  const additionalYears = generateHistoryYearSet(horizon, eventCount, rng);
  const templateFns = [
    (ctx, randomFn) =>
      `the oracles proclaimed ${pickRandomFrom(lizardmenPortents, randomFn) || 'a blazing omen'}, reshaping temple rites.`,
    (ctx, randomFn) =>
      `scale-priests led ${pickRandomFrom(lizardmenCampaigns, randomFn) || 'the Sunblood Crusade'}, sending legions into the jungles.`,
    (ctx, randomFn) => `${pickRandomFrom(['pyramid terraces', 'sunken ziggurats', 'obsidian causeways'], randomFn) || 'obsidian terraces'} were carved to honor the gods.`,
    (ctx, randomFn) => `${pickRandomFrom(['saurus cohorts', 'razorback cavalry', 'skink skirmishers'], randomFn) || 'saurus cohorts'} swore fealty to the ruling temple.`,
    (ctx, randomFn) => {
      const orderName = ctx.prominentGroup || pickRandomFrom(lizardmenCityOrders, randomFn);
      return orderName ? `the ${orderName} warded the vaults against serpent cultists.` : null;
    }
  ];

  events.push(...generateHistoryFromTemplates(additionalYears, templateFns, context, rng));
  return events;
}

function generateTowerSettlementHistory(context, rng) {
  const horizon = resolveHistorySpan(context.foundedYearsAgo, rng, { min: 28, max: 260 });
  const events = [];
  if (horizon) {
    events.push(
      createHistoryEntry(
        horizon,
        `${context.name} was established under ${context.rulerTitle || 'Castellan'} ${context.rulerName || 'Aldren Stonewatch'}.`
      )
    );
  }
  const eventCount = resolveHistoryEventCount(rng);
  const additionalYears = generateHistoryYearSet(horizon, eventCount, rng);
  const templateFns = [
    (ctx, randomFn) => pickRandomFrom(towerAlarmEvents, randomFn),
    (ctx, randomFn) => `the beacon-chain was repaired after lightning shattered the signal spire.`,
    (ctx, randomFn) => `${pickRandomFrom(towerVisitors, randomFn) || 'envoys from the capital'} inspected the defenses.`,
    (ctx, randomFn) => `${pickRandomFrom(['engineers raised new ballistae', 'alchemists fortified the battlements', 'masons rebuilt the curtain wall'], randomFn)}.`,
    (ctx, randomFn) => {
      const order = ctx.prominentGroup || pickRandomFrom(towerOrderNames, randomFn);
      return order ? `the ${order} swore a new oath of vigilance.` : null;
    }
  ];

  events.push(...generateHistoryFromTemplates(additionalYears, templateFns, context, rng));
  return events;
}

function generateEvilWizardSettlementHistory(context, rng) {
  const horizon = resolveHistorySpan(context.foundedYearsAgo, rng, { min: 40, max: 260 });
  const events = [];
  if (horizon) {
    events.push(createHistoryEntry(horizon, `${context.name} rose when ${context.rulerTitle || 'Archwizard'} ${context.rulerName || 'Malachar'} claimed the spire.`));
  }
  const eventCount = resolveHistoryEventCount(rng);
  const additionalYears = generateHistoryYearSet(horizon, eventCount, rng);
  const templateFns = [
    (ctx, randomFn) => `${pickRandomFrom(wizardTowerCatastrophes, randomFn) || 'a summoning tore open a screaming rift'}`,
    (ctx, randomFn) => `${pickRandomFrom(wizardTowerExperiments, randomFn) || 'Midnight Ascension'} bound the tower to planar ley-lines.`,
    (ctx, randomFn) => `${pickRandomFrom(['a legion of constructs', 'a host of chained wraiths', 'a cabal of cursed apprentices'], randomFn) || 'a legion of constructs'} marched from the gates.`,
    (ctx, randomFn) => `${pickRandomFrom(['rebellious apprentices', 'paladins of the Dawn', 'an order of witch hunters'], randomFn) || 'paladins'} besieged the tower and were repelled.`,
    (ctx, randomFn) => {
      if (!ctx.prominentGroup) {
        return null;
      }
      return `${ctx.prominentGroup} completed a grand ritual atop the obsidian dais.`;
    }
  ];
  events.push(...generateHistoryFromTemplates(additionalYears, templateFns, context, rng));
  return events;
}

function generateMineSettlementHistory(context, rng) {
  const horizon = resolveHistorySpan(context.foundedYearsAgo, rng, { min: 24, max: 90 });
  const events = [];
  if (horizon) {
    events.push(createHistoryEntry(horizon, `${context.name} was sunk to tap the mountain riches.`));
  }
  const eventCount = resolveHistoryEventCount(rng);
  const additionalYears = generateHistoryYearSet(horizon, eventCount, rng);
  const templateFns = [
    (ctx, randomFn) => `${pickRandomFrom(mineIncidents, randomFn) || 'a cave-in sealed the lower galleries for a month'}.`,
    (ctx, randomFn) => `${pickRandomFrom(mineDiscoveries, randomFn) || 'a glittering vein of mithril ore'} was discovered.`,
    (ctx, randomFn) => `the Miners Guild struck for fair shares and won new charter terms.`,
    (ctx, randomFn) => `${pickRandomFrom(['steam drills were installed along the deep shafts', 'ore caravans began nightly departures', 'new lifts were carved into the heartrock'], randomFn)}.`,
    (ctx, randomFn) => `engineers diverted an underground river to power the smelters.`,
    (ctx, randomFn) => `${pickRandomFrom(['tunnel sentries fought off a delver beast', 'kobold saboteurs were caught with stolen ore', 'the overseer ordered triple shifts to meet royal quotas'], randomFn)}.`
  ];
  events.push(...generateHistoryFromTemplates(additionalYears, templateFns, context, rng));
  return events;
}

function generateCaveSettlementHistory(context, rng) {
  const horizon = resolveHistorySpan(context.foundedYearsAgo, rng, { min: 30, max: 140 });
  const events = [];
  if (horizon) {
    events.push(createHistoryEntry(horizon, `${context.name} warrens were carved by scheming goblins.`));
  }
  const eventCount = resolveHistoryEventCount(rng);
  const additionalYears = generateHistoryYearSet(horizon, eventCount, rng);
  const templateFns = [
    (ctx, randomFn) => `${ctx.prominentGroup || 'the clan'} ${pickRandomFrom(goblinSchemes, randomFn) || 'plotted under cover of drums'}.`,
    (ctx, randomFn) => `${pickRandomFrom(['trap-makers laced the tunnels with deadfalls', 'war drums thundered through the night', 'a new chieftain painted the cavern walls with trophies'], randomFn)}.`,
    (ctx, randomFn) => `${pickRandomFrom(goblinRaids, randomFn) || 'raided the river caravans'} before melting back into the caves.`,
    (ctx, randomFn) => `shamans bargained with underdark spirits for cruel blessings.`,
    (ctx, randomFn) => `skulkers tunneled toward a dwarven vault before collapsing the passage.`,
    (ctx, randomFn) => `${pickRandomFrom(['wolf riders', 'beast tamers', 'hobgoblin allies'], randomFn) || 'wolf riders'} swore themselves to the chieftain.`
  ];
  events.push(...generateHistoryFromTemplates(additionalYears, templateFns, context, rng));
  return events;
}

function generateGenericSettlementHistory(context, rng) {
  const horizon = resolveHistorySpan(context.foundedYearsAgo, rng, { min: 40, max: 360 });
  const events = [];
  if (horizon) {
    events.push(createHistoryEntry(horizon, `${context.name} first appears in the oldest surviving chronicles.`));
  }
  const eventCount = resolveHistoryEventCount(rng);
  const additionalYears = generateHistoryYearSet(horizon, eventCount, rng);
  const templateFns = [
    (ctx, randomFn) => `${pickRandomFrom(genericHistoryMoments, randomFn) || 'storm floods forced the folk to rebuild their bridges'}.`,
    (ctx, randomFn) => `a council of elders forged new laws to guide the ${ctx.kindLower}.`,
    (ctx, randomFn) => `travelers from distant realms brought tales and rare curiosities.`,
    (ctx, randomFn) => `${pickRandomFrom(['mysterious lights danced above the hills', 'a wandering saint blessed the wellspring', 'the harvest overflowed and filled every granary'], randomFn)}.`,
    (ctx, randomFn) => `craftsfolk raised a hall that became the heart of the community.`,
    (ctx, randomFn) => {
      if (!ctx.prominentGroup) {
        return null;
      }
      return `${ctx.prominentGroup} guided the settlement through a time of unrest.`;
    }
  ];
  events.push(...generateHistoryFromTemplates(additionalYears, templateFns, context, rng));
  return events;
}

function identifyPopulationShockEvents(events) {
  if (!Array.isArray(events) || events.length === 0) {
    return [];
  }

  return events
    .map((event) => {
      if (!event || typeof event.description !== 'string') {
        return null;
      }

      const normalizedDescription = event.description.toLowerCase();
      const includesSiege = normalizedDescription.includes('siege');
      const includesDragon = normalizedDescription.includes('dragon');
      const includesOnslaught = normalizedDescription.includes('onslaught');
      if (!includesSiege && !includesDragon && !includesOnslaught) {
        return null;
      }

      const yearsAgo = Number.isFinite(event.yearsAgo) ? Math.max(1, Math.round(event.yearsAgo)) : null;
      if (yearsAgo === null) {
        return null;
      }

      const severity = includesDragon || includesOnslaught ? 'dragon' : 'siege';
      return {
        yearsAgo,
        severity,
        description: event.description
      };
    })
    .filter((entry) => entry !== null)
    .sort((a, b) => b.yearsAgo - a.yearsAgo);
}

function applyPopulationHistoryShocks(timeline, events, rng, options = {}) {
  if (!Array.isArray(timeline) || timeline.length === 0) {
    return timeline;
  }

  const shockEvents = identifyPopulationShockEvents(events);
  if (shockEvents.length === 0) {
    return timeline;
  }

  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const currentYear = Number.isFinite(options?.currentYear) ? Math.round(options.currentYear) : null;
  const finalPopulation = Number.isFinite(options?.finalPopulation)
    ? Math.max(0, Math.round(options.finalPopulation))
    : null;

  const adjustedTimeline = timeline.slice();

  shockEvents.forEach((event) => {
    const yearsAgo = event.yearsAgo;
    let insertIndex = adjustedTimeline.findIndex((point) =>
      Number.isFinite(point?.yearsAgo) && point.yearsAgo <= yearsAgo
    );
    if (insertIndex === -1) {
      insertIndex = adjustedTimeline.length;
    }

    const olderIndex = Math.max(0, insertIndex - 1);
    const olderPoint = adjustedTimeline[olderIndex];
    const newerPoint = adjustedTimeline[insertIndex] || adjustedTimeline[adjustedTimeline.length - 1];

    const olderYears = Number.isFinite(olderPoint?.yearsAgo) ? olderPoint.yearsAgo : yearsAgo;
    const newerYears = Number.isFinite(newerPoint?.yearsAgo) ? newerPoint.yearsAgo : yearsAgo;
    const olderPopulation = Number.isFinite(olderPoint?.population)
      ? olderPoint.population
      : Number.isFinite(newerPoint?.population)
      ? newerPoint.population
      : Number.isFinite(finalPopulation)
      ? finalPopulation
      : 0;
    const newerPopulation = Number.isFinite(newerPoint?.population)
      ? newerPoint.population
      : Number.isFinite(olderPoint?.population)
      ? olderPoint.population
      : Number.isFinite(finalPopulation)
      ? finalPopulation
      : 0;

    let baselinePopulation = newerPopulation;
    if (Number.isFinite(olderYears) && Number.isFinite(newerYears) && olderYears !== newerYears) {
      if (olderYears > newerYears) {
        const span = Math.max(olderYears - newerYears, 1);
        const position = clamp((yearsAgo - newerYears) / span, 0, 1);
        baselinePopulation = Math.round(lerp(newerPopulation, olderPopulation, position));
      } else {
        const span = Math.max(newerYears - olderYears, 1);
        const position = clamp((yearsAgo - olderYears) / span, 0, 1);
        baselinePopulation = Math.round(lerp(olderPopulation, newerPopulation, position));
      }
    } else if (Number.isFinite(olderPopulation)) {
      baselinePopulation = Math.round(olderPopulation);
    }

    const severityRange = event.severity === 'dragon' ? { min: 260, max: 620 } : { min: 160, max: 480 };
    const dropMagnitude = severityRange.min + randomFn() * (severityRange.max - severityRange.min);
    const safeDrop = Math.min(baselinePopulation, Math.round(dropMagnitude));
    const dipPopulation = Math.max(0, baselinePopulation - safeDrop);

    const eventYear = currentYear !== null ? Math.round(currentYear - yearsAgo) : null;
    const existingIndex = adjustedTimeline.findIndex(
      (point) => Number.isFinite(point?.yearsAgo) && point.yearsAgo === yearsAgo
    );

    if (existingIndex !== -1) {
      const updatedPoint = {
        ...adjustedTimeline[existingIndex],
        population: dipPopulation,
        value: dipPopulation,
        year: eventYear
      };
      adjustedTimeline.splice(existingIndex, 1, updatedPoint);
      insertIndex = existingIndex;
    } else {
      const newPoint = {
        population: dipPopulation,
        value: dipPopulation,
        yearsAgo,
        year: eventYear
      };
      adjustedTimeline.splice(insertIndex, 0, newPoint);
    }

  });

  return adjustedTimeline.sort((a, b) => {
    const aYears = Number.isFinite(a?.yearsAgo) ? a.yearsAgo : 0;
    const bYears = Number.isFinite(b?.yearsAgo) ? b.yearsAgo : 0;
    return bYears - aYears;
  });
}

function generateDwarfholdPopulationTimeline(historyContext, events, rng) {
  
  const holdTypes = new Set([
    'dwarfhold',
    'greatdwarfhold',
    'hillhold',
    'occupieddwarfhold',
    'occupyddwarfhold',
    'abandoneddwarfhold',
    'ruineddwarfhold'
  ]);
  if (!historyContext || !holdTypes.has(historyContext.type)) {
    return null;
  }

  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const finalPopulation = Number.isFinite(historyContext?.details?.population)
    ? Math.max(0, Math.round(historyContext.details.population))
    : null;
  if (finalPopulation === null) {
    return null;
  }

  const yearsSpan = Number.isFinite(historyContext?.foundedYearsAgo)
    ? clamp(Math.round(historyContext.foundedYearsAgo), 40, 4200)
    : 360;
  const pointCount = clamp(Math.round(yearsSpan / 120) + 5, 6, 14);

  const typeKey = historyContext.type;
  const declineVariants = new Set(['occupieddwarfhold', 'occupyddwarfhold', 'abandoneddwarfhold', 'ruineddwarfhold']);
  const isDeclineVariant = declineVariants.has(typeKey);

  let peakPopulation;
  if (isDeclineVariant) {
    const baseline =
      finalPopulation > 0
        ? finalPopulation * (1.45 + randomFn() * 0.55)
        : 900 + randomFn() * 3200;
    peakPopulation = Math.round(Math.max(baseline, finalPopulation + 400 + randomFn() * 900));
  } else {
    const growthFactor = 1.08 + randomFn() * 0.35;
    const additiveBoost = 180 + randomFn() * 900;
    peakPopulation = Math.round(Math.max(finalPopulation, finalPopulation * growthFactor + additiveBoost));
  }
  if (finalPopulation > 0) {
    const maxMultiplier = isDeclineVariant ? 2.8 : 1.9;
    peakPopulation = Math.min(peakPopulation, Math.round(finalPopulation * maxMultiplier));
  } else {
    peakPopulation = Math.max(peakPopulation, 800);
  }

  const startPopulation = Math.max(40, Math.round(peakPopulation * (0.12 + randomFn() * 0.18)));
  const declineStart = isDeclineVariant ? 0.55 + randomFn() * 0.12 : 0.82 + randomFn() * 0.08;

  const timeline = [];
  for (let index = 0; index < pointCount; index += 1) {
    const progress = pointCount === 1 ? 1 : index / (pointCount - 1);
    let targetValue;
    if (isDeclineVariant && progress >= declineStart) {
      const declineProgress = (progress - declineStart) / Math.max(1 - declineStart, 0.0001);
      const easedDecline = Math.pow(clamp(declineProgress, 0, 1), 0.85);
      targetValue = lerp(peakPopulation, finalPopulation, easedDecline);
    } else {
      const growthProgress = Math.min(progress / Math.max(declineStart, 0.0001), 1);
      const easedGrowth = 1 - Math.pow(1 - growthProgress, 1.6);
      const growthTarget = isDeclineVariant ? peakPopulation : finalPopulation;
      targetValue = lerp(startPopulation, growthTarget, easedGrowth);
    }
    const noiseAmplitude = isDeclineVariant ? 0.12 : 0.08;
    const jitter = targetValue * noiseAmplitude * (randomFn() - 0.5) * 2;
    let value = Math.max(0, Math.round(targetValue + jitter));
    if (index === 0) {
      value = startPopulation;
    } else if (index === pointCount - 1) {
      value = finalPopulation;
    } else if (!isDeclineVariant) {
      const previous = timeline[index - 1]?.population || startPopulation;
      value = Math.max(value, previous - Math.round(previous * 0.1));
    } else if (progress < declineStart) {
      const previous = timeline[index - 1]?.population || startPopulation;
      value = Math.max(value, previous);
    }

    const yearsAgo = Math.round(yearsSpan - progress * yearsSpan);
    const currentYear = Number.isFinite(historyContext?.currentYear) ? Math.round(historyContext.currentYear) : null;
    const year = currentYear !== null ? Math.round(currentYear - yearsAgo) : null;

    timeline.push({
      population: value,
      value,
      yearsAgo,
      year
    });
  }

  return applyPopulationHistoryShocks(timeline, events, randomFn, {
    currentYear,
    finalPopulation
  });
}

function generateVillagePopulationTimeline(historyContext, events, rng) {
  const villageTypes = new Set(['village', 'hamlet']);
  if (!historyContext || !villageTypes.has(historyContext.type)) {
    return null;
  }

  const randomFn = typeof rng === 'function' ? rng : Math.random;
  const finalPopulation = Number.isFinite(historyContext?.details?.population)
    ? Math.max(0, Math.round(historyContext.details.population))
    : null;
  if (finalPopulation === null) {
    return null;
  }

  const yearsSpan = Number.isFinite(historyContext?.foundedYearsAgo)
    ? clamp(Math.round(historyContext.foundedYearsAgo), 20, 1000)
    : 200;
  const pointCount = clamp(Math.round(yearsSpan / 50) + 4, 5, 12);

  const growthFactor = 1.1 + randomFn() * 0.5;
  const additiveBoost = 20 + randomFn() * 150;
  let peakPopulation = Math.round(Math.max(finalPopulation, finalPopulation * growthFactor + additiveBoost));
  if (finalPopulation > 0) {
    const maxMultiplier = 2.5;
    peakPopulation = Math.min(peakPopulation, Math.round(finalPopulation * maxMultiplier));
  } else {
    peakPopulation = Math.max(peakPopulation, 100);
  }

  const startPopulation = Math.max(5, Math.round(peakPopulation * (0.1 + randomFn() * 0.15)));

  const timeline = [];
  for (let index = 0; index < pointCount; index += 1) {
    const progress = pointCount === 1 ? 1 : index / (pointCount - 1);
    const easedGrowth = 1 - Math.pow(1 - progress, 1.5);
    const targetValue = lerp(startPopulation, finalPopulation, easedGrowth);
    const noiseAmplitude = 0.1;
    const jitter = targetValue * noiseAmplitude * (randomFn() - 0.5) * 2;
    let value = Math.max(0, Math.round(targetValue + jitter));
    if (index === 0) {
      value = startPopulation;
    } else if (index === pointCount - 1) {
      value = finalPopulation;
    }

    const yearsAgo = Math.round(yearsSpan - progress * yearsSpan);
    const currentYear = Number.isFinite(historyContext?.currentYear) ? Math.round(historyContext.currentYear) : null;
    const year = currentYear !== null ? Math.round(currentYear - yearsAgo) : null;

    timeline.push({
      population: value,
      value,
      yearsAgo,
      year
    });
  }

  return applyPopulationHistoryShocks(timeline, events, randomFn, {
    currentYear,
    finalPopulation
  });
}

function generateSettlementHistoryData(tile, details, context) {
  const historySeedParts = [
    details?.name,
    tile?.structureName,
    details?.type,
    details?.classification,
    tile?.structure,
    Number.isFinite(context?.tileX) ? `x${context.tileX}` : null,
    Number.isFinite(context?.tileY) ? `y${context.tileY}` : null,
    Number.isFinite(state?.worldChronology?.year) ? `y${state.worldChronology.year}` : null
  ]
    .map((value) => (value != null ? String(value).trim() : ''))
    .filter((value) => value.length > 0);
  const seedString = historySeedParts.length > 0 ? historySeedParts.join('|') : 'default-settlement-history';
  const historySeed = (stringToSeed(seedString) + 0x3ad71521) >>> 0;
  const rng = mulberry32(historySeed || 1);
  const historyContext = createSettlementHistoryContext(tile, details, context, rng);
  const typeKey = historyContext.type;

  let events = [];
  switch (typeKey) {
    case 'city':
    case 'town':
    case 'village':
    case 'hamlet':
      events = generateHumanSettlementHistory(historyContext, rng);
      break;
    case 'dwarfhold':
    case 'greatdwarfhold':
    case 'hillhold':
      events = generateDwarvenSettlementHistory(historyContext, rng);
      break;
    case 'occupyddwarfhold':
    case 'occupieddwarfhold':
      events = generateDwarvenSettlementHistory(historyContext, rng, { variant: 'occupied' });
      break;
    case 'abandoneddwarfhold':
      events = generateDwarvenSettlementHistory(historyContext, rng, { variant: 'abandoned' });
      break;
    case 'ruineddwarfhold':
      events = generateDwarvenSettlementHistory(historyContext, rng, { variant: 'ruined', fallbackRange: { min: 160, max: 540 } });
      break;
    case 'woodelfgrove':
      events = generateWoodElfSettlementHistory(historyContext, rng);
      break;
    case 'lizardmencity':
      events = generateLizardmenSettlementHistory(historyContext, rng);
      break;
    case 'tower':
      events = generateTowerSettlementHistory(historyContext, rng);
      break;
    case 'evilwizardtower':
      events = generateEvilWizardSettlementHistory(historyContext, rng);
      break;
    case 'mine':
      events = generateMineSettlementHistory(historyContext, rng);
      break;
    case 'cave':
      events = generateCaveSettlementHistory(historyContext, rng);
      break;
    default:
      events = generateGenericSettlementHistory(historyContext, rng);
      break;
  }

    const populationTimeline = (() => {
    const holdTypes = new Set([
      'dwarfhold',
      'greatdwarfhold',
      'hillhold',
      'occupieddwarfhold',
      'occupyddwarfhold',
      'abandoneddwarfhold',
      'ruineddwarfhold'
    ]);
    if (holdTypes.has(typeKey)) {
      return generateDwarfholdPopulationTimeline(historyContext, events, rng);
    }

    const villageTypes = new Set(['village', 'hamlet']);
    if (villageTypes.has(typeKey)) {
      return generateVillagePopulationTimeline(historyContext, events, rng);
    }

    return null;
  })();

  const uniqueMap = new Map();
  events
    .filter((event) => event && typeof event.description === 'string')
    .forEach((event) => {
      const yearsAgo = Number.isFinite(event.yearsAgo) ? Math.max(1, Math.round(event.yearsAgo)) : null;
      const description = event.description.trim();
      if (!description) {
        return;
      }
      const label = typeof event.label === 'string' && event.label.trim().length > 0 ? event.label.trim() : null;
      const key = `${yearsAgo ?? 'present'}|${description.toLowerCase()}`;
      if (!uniqueMap.has(key)) {
        const eventYear =
          Number.isFinite(historyContext.currentYear) && Number.isFinite(yearsAgo)
            ? historyContext.currentYear - yearsAgo
            : null;
        uniqueMap.set(key, { yearsAgo, description, label, eventYear });
      }
    });

  const sortedEntries = Array.from(uniqueMap.values()).sort((a, b) => {
    const aValue = Number.isFinite(a.yearsAgo) ? a.yearsAgo : -Infinity;
    const bValue = Number.isFinite(b.yearsAgo) ? b.yearsAgo : -Infinity;
    return bValue - aValue;
  });

  return {
    entries: sortedEntries,
    populationTimeline
  };
}

function formatPopulationTimelineLabel(point) {
  if (!point) {
    return 'Recorded';
  }
  if (Number.isFinite(point.yearsAgo)) {
    if (point.yearsAgo <= 0) {
      if (Number.isFinite(point.year)) {
        return `Current (${point.year.toLocaleString('en-US')})`;
      }
      return 'Current';
    }
    if (point.yearsAgo === 1) {
      return '1 year ago';
    }
    return `${point.yearsAgo.toLocaleString('en-US')} years ago`;
  }
  if (Number.isFinite(point.year)) {
    return `Year ${point.year.toLocaleString('en-US')}`;
  }
  return 'Recorded';
}

function createNiceTickStep(maxValue, targetTickCount = 5) {
  if (!Number.isFinite(maxValue) || maxValue <= 0) {
    return 1;
  }
  const safeTarget = Math.max(1, targetTickCount);
  const roughStep = maxValue / safeTarget;
  const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
  const residual = roughStep / magnitude;
  if (residual >= 5) {
    return 5 * magnitude;
  }
  if (residual >= 2) {
    return 2 * magnitude;
  }
  return magnitude;
}

function generateAxisTicks(maxValue, targetTickCount = 5, options = {}) {
  const { includeZero = true } = options;
  if (!Number.isFinite(maxValue) || maxValue <= 0) {
    return includeZero ? [0] : [];
  }
  const step = Math.max(createNiceTickStep(maxValue, targetTickCount), 1);
  const tickTotal = Math.max(1, Math.floor(maxValue / step));
  const ticks = [];
  if (includeZero) {
    ticks.push(0);
  }
  for (let index = 1; index <= tickTotal; index += 1) {
    ticks.push(step * index);
  }
  const lastTick = ticks[ticks.length - 1];
  if (!Number.isFinite(lastTick) || Math.abs(lastTick - maxValue) > step * 0.25) {
    ticks.push(maxValue);
  } else {
    ticks[ticks.length - 1] = Math.max(lastTick, maxValue);
  }
  return Array.from(new Set(ticks)).sort((a, b) => a - b);
}

function buildPopulationHistoryChartMarkup(timeline, details, tile) {
  if (!Array.isArray(timeline) || timeline.length < 2) {
    return '';
  }

  const sanitizedPoints = timeline
    .map((point) => ({
      population: Number.isFinite(point?.population)
        ? Math.max(0, Math.round(point.population))
        : Number.isFinite(point?.value)
        ? Math.max(0, Math.round(point.value))
        : null,
      year: Number.isFinite(point?.year) ? Math.round(point.year) : null,
      yearsAgo: Number.isFinite(point?.yearsAgo) ? Math.max(0, Math.round(point.yearsAgo)) : null
    }))
    .filter((point) => point.population !== null);

  if (sanitizedPoints.length < 2) {
    return '';
  }

  const values = sanitizedPoints.map((point) => point.population);
  if (values.every((value) => value === 0)) {
    return '';
  }

  const maxValue = Math.max(...values, 1);
  const chartWidth = 320;
  const chartHeight = 140;

   const maxYearsAgo = sanitizedPoints.reduce(
    (accumulator, point) =>
      Number.isFinite(point.yearsAgo) ? Math.max(accumulator, point.yearsAgo) : accumulator,
    0
  );
  const hasYearsData = maxYearsAgo > 0;

  const yTicks = generateAxisTicks(maxValue, 4);
  const yScaleMax = yTicks.length > 0 ? yTicks[yTicks.length - 1] : maxValue;
  const xTicks = hasYearsData ? generateAxisTicks(maxYearsAgo, 6) : [];
  
  const positions = sanitizedPoints.map((point, index) => {
    const x = hasYearsData && Number.isFinite(point.yearsAgo)
      ? chartWidth - (point.yearsAgo / Math.max(maxYearsAgo, 1)) * chartWidth
      : sanitizedPoints.length === 1
      ? chartWidth
      : (index / (sanitizedPoints.length - 1)) * chartWidth;
    const y = chartHeight - (point.population / Math.max(yScaleMax, 1)) * chartHeight;
    return { x, y, data: point };
  });

  const lineCommands = positions
    .map(({ x, y }, index) => `${index === 0 ? 'M' : 'L'} ${x.toFixed(2)} ${y.toFixed(2)}`)
    .join(' ');
  const areaPath = [
    `M 0 ${chartHeight.toFixed(2)}`,
    ...positions.map(({ x, y }) => `L ${x.toFixed(2)} ${y.toFixed(2)}`),
    `L ${chartWidth.toFixed(2)} ${chartHeight.toFixed(2)}`,
    'Z'
  ].join(' ');

 const horizontalGridLines = yTicks
    .map((tick) => {
      const y = chartHeight - (tick / Math.max(yScaleMax, 1)) * chartHeight;
      return `<line class="structure-details-history-chart__grid-line structure-details-history-chart__grid-line--horizontal" x1="0" y1="${y.toFixed(2)}" x2="${chartWidth.toFixed(2)}" y2="${y.toFixed(2)}" aria-hidden="true"></line>`;
    })
    .join('');

const verticalGridLines = hasYearsData
    ? xTicks
        .map((tick) => {
          const x = chartWidth - (tick / Math.max(maxYearsAgo, 1)) * chartWidth;
          return `<line class="structure-details-history-chart__grid-line structure-details-history-chart__grid-line--vertical" x1="${x.toFixed(2)}" y1="0" x2="${x.toFixed(2)}" y2="${chartHeight.toFixed(2)}" aria-hidden="true"></line>`;
        })
        .join('')
    : '';

  const yTickLabels = yTicks
    .map((tick) => {
      const y = chartHeight - (tick / Math.max(yScaleMax, 1)) * chartHeight;
      const labelY = Math.min(Math.max(y, 6), chartHeight - 6);
      return `<text class="structure-details-history-chart__axis-label structure-details-history-chart__axis-label--y" x="4" y="${labelY.toFixed(2)}" text-anchor="start" aria-hidden="true">${escapeHtml(tick.toLocaleString('en-US'))}</text>`;
    })
    .join('');

  const xTickLabels = hasYearsData
    ? xTicks
        .map((tick) => {
          const x = chartWidth - (tick / Math.max(maxYearsAgo, 1)) * chartWidth;
          const labelX = Math.min(Math.max(x, 12), chartWidth - 12);
          return `<text class="structure-details-history-chart__axis-label structure-details-history-chart__axis-label--x" x="${labelX.toFixed(2)}" y="${(chartHeight - 2).toFixed(2)}" text-anchor="middle" aria-hidden="true">${escapeHtml(tick.toLocaleString('en-US'))}</text>`;
        })
        .join('')
    : '';

  const startPoint = sanitizedPoints[0];
  const endPoint = sanitizedPoints[sanitizedPoints.length - 1];
  const peakValue = Math.max(...values);
  const peakIndex = values.indexOf(peakValue);
  const descriptor = (details?.populationDescriptor || 'residents').trim() || 'residents';
  const peakPoint = sanitizedPoints[Math.max(peakIndex, 0)];
  const descriptorLabel = descriptor;
  const startLabel = formatPopulationTimelineLabel(startPoint);
  const peakLabel = formatPopulationTimelineLabel(peakPoint);
  const currentLabel = formatPopulationTimelineLabel(endPoint);

  const startValueText = startPoint.population.toLocaleString('en-US');
  const peakValueText = peakPoint.population.toLocaleString('en-US');
  const currentValueText = endPoint.population.toLocaleString('en-US');

  const settlementName = details?.name || tile?.structureName || 'the settlement';
  const chartIdSeed = `${settlementName}|${details?.type || 'hold'}|population-history`;
  const chartIdSuffix = ((stringToSeed(chartIdSeed) + 0x4f1b) >>> 0).toString(36);
  const titleId = `population-history-title-${chartIdSuffix}`;
  const descId = `population-history-desc-${chartIdSuffix}`;
  
  const chartPoints = positions.map((point) => ({
    x: Number(point.x.toFixed(2)),
    y: Number(point.y.toFixed(2)),
    population: point.data.population,
    yearsAgo: point.data.yearsAgo,
    label: formatPopulationTimelineLabel(point.data)
  }));
  const chartPointsData = escapeHtml(JSON.stringify(chartPoints));
  
  const summarySegments = [];
  summarySegments.push(
    `Population began near ${startValueText} ${descriptor}${startLabel ? ` (${startLabel})` : ''}.`
  );
  if (peakIndex > 0 && peakIndex < sanitizedPoints.length - 1 && peakPoint.population !== startPoint.population) {
    summarySegments.push(
      `It peaked at ${peakValueText} ${descriptor}${peakLabel ? ` (${peakLabel})` : ''}.`
    );
  }
  summarySegments.push(
    `${endPoint.population >= peakPoint.population ? 'It now stands at' : 'It has since fallen to'} ${currentValueText} ${descriptor}${currentLabel ? ` (${currentLabel})` : ''}.`
  );
  const summaryText = summarySegments.join(' ');

  const peakLabelText =
    peakIndex === sanitizedPoints.length - 1 && peakPoint.population === endPoint.population
      ? 'Current peak'
      : 'Peak';
  const peakHeading = peakLabel ? `${peakLabelText} • ${peakLabel}` : peakLabelText;

  return `
    <section class="structure-details-history-chart">
      <header class="structure-details-history-chart__header">
        <h3 class="structure-details-history-chart__title structure-details-heading">Population Trend</h3>
        <p class="structure-details-history-chart__current">${escapeHtml(currentValueText)} ${escapeHtml(descriptor)}</p>
      </header>
      <figure
        class="structure-details-history-chart__figure"
        data-chart-points="${chartPointsData}"
        data-chart-width="${chartWidth}"
        data-chart-height="${chartHeight}"
        data-chart-descriptor="${escapeHtml(descriptorLabel)}"
        data-chart-has-years="${hasYearsData ? 'true' : 'false'}"
        data-chart-max-years="${hasYearsData ? maxYearsAgo : ''}"
      >
        <svg
          class="structure-details-history-chart__sparkline"
          viewBox="0 0 ${chartWidth} ${chartHeight}"
          role="img"
          aria-labelledby="${titleId} ${descId}"
        >
          <title id="${titleId}">${escapeHtml(`Population trend for ${settlementName}`)}</title>
          <desc id="${descId}">${escapeHtml(summaryText)}</desc>
          <g class="structure-details-history-chart__grid" aria-hidden="true">
            ${horizontalGridLines}${verticalGridLines}
          </g>
          <g class="structure-details-history-chart__axis-labels" aria-hidden="true">
            ${yTickLabels}${xTickLabels}
          </g>
          <path class="structure-details-history-chart__area" d="${areaPath}"></path>
          <path class="structure-details-history-chart__line" d="${lineCommands}"></path>
          <line
            class="structure-details-history-chart__cursor"
            x1="0"
            y1="0"
            x2="0"
            y2="${chartHeight.toFixed(2)}"
            aria-hidden="true"
          ></line>
          <circle
            class="structure-details-history-chart__marker"
            cx="0"
            cy="0"
            r="4"
            aria-hidden="true"
          ></circle>
          <rect
            class="structure-details-history-chart__interaction-layer"
            x="0"
            y="0"
            width="${chartWidth.toFixed(2)}"
            height="${chartHeight.toFixed(2)}"
            fill="transparent"
            tabindex="0"
            aria-label="${escapeHtml(`Explore population data for ${settlementName}`)}"
          ></rect>
        </svg>
        <div class="structure-details-history-chart__tooltip" role="status" aria-hidden="true" hidden></div>
        <figcaption class="structure-details-history-chart__caption">
          <dl class="structure-details-history-chart__stats">
            <div class="structure-details-history-chart__stat">
              <dt>${escapeHtml(startLabel)}</dt>
              <dd>${escapeHtml(startValueText)}</dd>
            </div>
            <div class="structure-details-history-chart__stat">
              <dt>${escapeHtml(peakHeading)}</dt>
              <dd>${escapeHtml(peakValueText)}</dd>
            </div>
            <div class="structure-details-history-chart__stat">
              <dt>${escapeHtml(currentLabel)}</dt>
              <dd>${escapeHtml(currentValueText)}</dd>
            </div>
          </dl>
        </figcaption>
      </figure>
    </section>
  `;
}

function enhancePopulationHistoryCharts(root) {
  if (!root || typeof root.querySelectorAll !== 'function') {
    return;
  }

  const figures = root.querySelectorAll('.structure-details-history-chart__figure[data-chart-points]');
  figures.forEach((figure) => {
    const pointsAttribute = figure.getAttribute('data-chart-points');
    if (!pointsAttribute) {
      return;
    }

    let points;
    try {
      points = JSON.parse(pointsAttribute);
    } catch (error) {
      return;
    }

    if (!Array.isArray(points) || points.length === 0) {
      return;
    }

    const svg = figure.querySelector('.structure-details-history-chart__sparkline');
    const interactionLayer = svg?.querySelector('.structure-details-history-chart__interaction-layer');
    const marker = svg?.querySelector('.structure-details-history-chart__marker');
    const cursorLine = svg?.querySelector('.structure-details-history-chart__cursor');
    const tooltip = figure.querySelector('.structure-details-history-chart__tooltip');
    if (!svg || !interactionLayer || !marker || !cursorLine || !tooltip) {
      return;
    }

    const chartWidth = Number.parseFloat(figure.getAttribute('data-chart-width')) || 0;
    const chartHeight = Number.parseFloat(figure.getAttribute('data-chart-height')) || 0;
    const descriptor = figure.getAttribute('data-chart-descriptor') || '';

    let activeIndex = points.length - 1;
    let hideTimeoutId = null;

    const clearHideTimeout = () => {
      if (hideTimeoutId !== null) {
        clearTimeout(hideTimeoutId);
        hideTimeoutId = null;
      }
    };

    const hideTooltip = () => {
      clearHideTimeout();
      svg.classList.remove('is-active');
      tooltip.hidden = true;
      tooltip.setAttribute('aria-hidden', 'true');
    };

    const showPoint = (index, pointer) => {
      if (!Number.isFinite(chartWidth) || chartWidth <= 0 || !Number.isFinite(chartHeight) || chartHeight <= 0) {
        return;
      }

      const safeIndex = clamp(Number.isFinite(index) ? index : activeIndex, 0, points.length - 1);
      activeIndex = safeIndex;
      const point = points[safeIndex];
      if (!point) {
        return;
      }

      const pointX = Number.isFinite(point.x) ? point.x : 0;
      const pointY = Number.isFinite(point.y) ? point.y : 0;

      marker.setAttribute('cx', pointX.toFixed(2));
      marker.setAttribute('cy', pointY.toFixed(2));
      cursorLine.setAttribute('x1', pointX.toFixed(2));
      cursorLine.setAttribute('x2', pointX.toFixed(2));
      cursorLine.setAttribute('y1', '0');
      cursorLine.setAttribute('y2', chartHeight.toFixed(2));
      svg.classList.add('is-active');

      const figureRect = figure.getBoundingClientRect();
      if (!figureRect || figureRect.width === 0 || figureRect.height === 0) {
        return;
      }

      let tooltipX;
      let tooltipY;
      if (pointer && Number.isFinite(pointer.clientX) && Number.isFinite(pointer.clientY)) {
        tooltipX = clamp(pointer.clientX - figureRect.left, 12, Math.max(12, figureRect.width - 12));
        tooltipY = clamp(pointer.clientY - figureRect.top, 16, Math.max(16, figureRect.height - 16));
      } else {
        tooltipX = clamp((pointX / chartWidth) * figureRect.width, 12, Math.max(12, figureRect.width - 12));
        tooltipY = clamp((pointY / chartHeight) * figureRect.height, 16, Math.max(16, figureRect.height - 16));
      }

      const populationText = Number.isFinite(point.population)
        ? point.population.toLocaleString('en-US')
        : '—';
      const timeLabel = typeof point.label === 'string' ? point.label : '';
      const descriptorText = descriptor ? ` ${descriptor}` : '';
      tooltip.textContent = `${populationText}${descriptorText}${timeLabel ? ` • ${timeLabel}` : ''}`;
      tooltip.hidden = false;
      tooltip.setAttribute('aria-hidden', 'false');
      tooltip.style.left = `${tooltipX}px`;
      tooltip.style.top = `${tooltipY}px`;
    };

    const updateFromPointer = (clientX, clientY) => {
      if (!Number.isFinite(clientX) || !Number.isFinite(clientY)) {
        return;
      }

      const rect = svg.getBoundingClientRect();
      if (!rect || rect.width === 0 || rect.height === 0) {
        return;
      }

      const localX = clamp(clientX - rect.left, 0, rect.width);
      const scaledX = (localX / rect.width) * chartWidth;

      let nearestIndex = 0;
      let minDistance = Math.abs((points[0]?.x || 0) - scaledX);
      for (let index = 1; index < points.length; index += 1) {
        const candidate = points[index];
        const distance = Math.abs((candidate?.x || 0) - scaledX);
        if (distance < minDistance) {
          nearestIndex = index;
          minDistance = distance;
        }
      }

      showPoint(nearestIndex, { clientX, clientY });
    };

    const scheduleHide = (delay = 800) => {
      clearHideTimeout();
      hideTimeoutId = setTimeout(() => {
        hideTooltip();
      }, delay);
    };

    const handlePointerEnter = (event) => {
      clearHideTimeout();
      updateFromPointer(event.clientX, event.clientY);
    };

    const handlePointerMove = (event) => {
      clearHideTimeout();
      updateFromPointer(event.clientX, event.clientY);
    };

    const handlePointerDown = (event) => {
      clearHideTimeout();
      if (typeof interactionLayer.setPointerCapture === 'function') {
        try {
          interactionLayer.setPointerCapture(event.pointerId);
        } catch (error) {
          // Ignore capture errors.
        }
      }
      updateFromPointer(event.clientX, event.clientY);
    };

    const handlePointerUp = (event) => {
      if (typeof interactionLayer.releasePointerCapture === 'function') {
        try {
          interactionLayer.releasePointerCapture(event.pointerId);
        } catch (error) {
          // Ignore release errors.
        }
      }
      if (event.pointerType && event.pointerType !== 'mouse') {
        scheduleHide(1200);
      }
    };

    const handlePointerLeave = () => {
      scheduleHide(400);
    };

    const handlePointerCancel = () => {
      hideTooltip();
    };

    const handleFocus = () => {
      clearHideTimeout();
      showPoint(activeIndex);
    };

    const handleBlur = () => {
      hideTooltip();
    };

    const handleKeyDown = (event) => {
      if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
        event.preventDefault();
        const delta = event.key === 'ArrowLeft' ? -1 : 1;
        const nextIndex = clamp(activeIndex + delta, 0, points.length - 1);
        showPoint(nextIndex);
      }
    };

    interactionLayer.addEventListener('pointerenter', handlePointerEnter);
    interactionLayer.addEventListener('pointermove', handlePointerMove);
    interactionLayer.addEventListener('pointerdown', handlePointerDown);
    interactionLayer.addEventListener('pointerup', handlePointerUp);
    interactionLayer.addEventListener('pointerleave', handlePointerLeave);
    interactionLayer.addEventListener('pointercancel', handlePointerCancel);
    interactionLayer.addEventListener('focus', handleFocus);
    interactionLayer.addEventListener('blur', handleBlur);
    interactionLayer.addEventListener('keydown', handleKeyDown);
  });
}

function buildSettlementHistoryContent(tile, details, context = {}) {
  const historyData = generateSettlementHistoryData(tile, details, context);
  const entries = Array.isArray(historyData?.entries) ? historyData.entries : [];
  const timelineMarkup = buildPopulationHistoryChartMarkup(historyData?.populationTimeline, details, tile);

  const hasEntries = entries.length > 0;
  if (!hasEntries && !timelineMarkup) {
    return getStructureDetailsPlaceholder('No chronicles have been preserved for this settlement yet.');
  }

  const contentParts = [];
  if (timelineMarkup) {
    contentParts.push(timelineMarkup.trim());
  }

  if (hasEntries) {
    const listItems = entries
    .map((entry) => {
      const yearsAgo = Number.isFinite(entry.yearsAgo) ? Math.max(1, Math.round(entry.yearsAgo)) : null;
      const labelText = entry.label
        ? entry.label
        : yearsAgo !== null
        ? `${yearsAgo.toLocaleString('en-US')} years ago`
        : 'In recent years';
      const eventYear = Number.isFinite(entry.eventYear) ? Math.round(entry.eventYear) : null;
      const labelAttributes = eventYear !== null ? ` title="Year ${eventYear.toLocaleString('en-US')}"` : '';
      return `
        <li class="structure-details-history-item">
          <span class="structure-details-history-year"${labelAttributes}>${escapeHtml(labelText)}</span>
          <span class="structure-details-history-description">${escapeHtml(entry.description)}</span>
        </li>
      `;
    })
    .join('');

    contentParts.push(`
      <ol class="structure-details-history-list">
        ${listItems}
      </ol>
    `.trim());
  } else {
    const message = 'No chronicles have been preserved for this settlement yet.';
    contentParts.push(`
      <p class="structure-details-empty structure-details-empty--standalone">${escapeHtml(message)}</p>
    `.trim());
  }

  return `
    <div class="structure-details-column structure-details-column--primary">
      ${contentParts.join('\n')}
    </div>
  `;
}

function setActiveStructureDetailsTab(tabId, options = {}) {
  const { force = false, skipContent = false } = options;
  const resolvedTabId = normalizeStructureDetailsTabId(tabId);
  if (!force && structureDetailsState.activeTab === resolvedTabId && !skipContent) {
    return;
  }

  structureDetailsState.activeTab = resolvedTabId;

  if (Array.isArray(elements.structureDetailsTabs)) {
    elements.structureDetailsTabs.forEach((tab) => {
      if (!tab) {
        return;
      }
      const tabIdValue = normalizeStructureDetailsTabId(tab.getAttribute('data-tab-id'));
      const isActive = tabIdValue === resolvedTabId;
      tab.classList.toggle('is-active', isActive);
      if (isActive) {
        tab.setAttribute('aria-current', 'page');
      } else {
        tab.setAttribute('aria-current', 'false');
      }
    });
  }

  if (!skipContent && elements.structureDetailsContent) {
    const tabContent = structureDetailsState.tabContent?.[resolvedTabId] || '';
    elements.structureDetailsContent.innerHTML = tabContent;
    if (resolvedTabId === 'history') {
      enhancePopulationHistoryCharts(elements.structureDetailsContent);
    }
  }
}

const wizardTowerAmbienceTracks = [
  'sound/ambience/Cavern.ogg',
  'sound/ambience/Good.ogg'
];

function gatherStructureDescriptorInfo(tile) {
  const descriptors = new Set();
  const tokens = new Set();

  const addTokenVariant = (token) => {
    if (!token) {
      return;
    }
    tokens.add(token);
    if (token.length > 3 && token.endsWith('ies')) {
      tokens.add(`${token.slice(0, -3)}y`);
    } else if (token.length > 2 && token.endsWith('es')) {
      tokens.add(token.slice(0, -2));
    } else if (token.length > 1 && token.endsWith('s')) {
      tokens.add(token.slice(0, -1));
    }
  };

  const addValue = (value) => {
    if (!value) {
      return;
    }
    if (Array.isArray(value)) {
      value.forEach((item) => addValue(item));
      return;
    }
    if (typeof value !== 'string') {
      return;
    }
    const trimmed = value.trim();
    if (!trimmed) {
      return;
    }
    const lower = trimmed.toLowerCase();
    const normalized = lower.replace(/[_-]+/g, ' ');
    const candidates = [lower, normalized, normalized.replace(/['']/g, '')];
    candidates.forEach((candidate) => {
      if (!candidate) {
        return;
      }
      descriptors.add(candidate);
      candidate
        .split(/\s+/)
        .map((token) => token.trim())
        .filter(Boolean)
        .forEach((token) => addTokenVariant(token));
      const compact = candidate.replace(/\s+/g, '');
      if (compact) {
        addTokenVariant(compact);
      }
    });
  };

  if (tile) {
    addValue(tile.structure);
    addValue(tile.structureName);
    addValue(tile.areaName);
  }

  const details = tile?.structureDetails || {};
  addValue(details.type);
  addValue(details.displayType);
  addValue(details.classification);
  addValue(details.displayName);
  addValue(details.label);
  addValue(details.tags);

  return { descriptors, tokens };
}

function selectStructureAmbienceTrack(tile) {
  const { descriptors, tokens } = gatherStructureDescriptorInfo(tile);
  if (descriptors.size === 0 && tokens.size === 0) {
    return null;
  }

  const descriptorList = Array.from(descriptors);
  const hasDescriptorKeyword = (keywords) => {
    const keywordList = Array.isArray(keywords) ? keywords : [keywords];
    return descriptorList.some((descriptor) =>
      keywordList.some((keyword) => descriptor.includes(keyword))
    );
  };
  const hasAnyToken = (keywords) => {
    const keywordList = Array.isArray(keywords) ? keywords : [keywords];
    return keywordList.some((keyword) => tokens.has(keyword));
  };
  const hasAllTokens = (keywords) => {
    const keywordList = Array.isArray(keywords) ? keywords : [keywords];
    return keywordList.every((keyword) => tokens.has(keyword));
  };

  const isDwarfhold =
    hasDescriptorKeyword(['dwarfhold', 'dwarven hold']) ||
    hasAnyToken(['dwarfhold', 'hillhold']) ||
    (tokens.has('dwarf') && tokens.has('hold'));
  if (isDwarfhold) {
    return 'sound/ambience/Workshop.ogg';
  }

  const isWoodElfGrove =
    (hasAllTokens(['wood', 'elf']) && hasAnyToken(['grove'])) ||
    hasDescriptorKeyword(['wood elf grove', 'woodelfgrove']);
  if (isWoodElfGrove) {
    return 'sound/ambience/Forest.ogg';
  }

  const isCave = hasAnyToken(['cave', 'cavern']);
  if (isCave) {
    return 'sound/ambience/Cavern.ogg';
  }

  const isWizardTower =
    hasDescriptorKeyword(['evil wizard tower', "evil wizard's tower", 'evil wizards tower']) ||
    hasAllTokens(['evil', 'wizard', 'tower']);
  if (isWizardTower) {
    const randomIndex = Math.floor(Math.random() * wizardTowerAmbienceTracks.length);
    return wizardTowerAmbienceTracks[randomIndex] || null;
  }

  const isMonastery = hasDescriptorKeyword(['monaster']) || hasAnyToken(['monastery', 'monastic']);
  if (isMonastery) {
    return 'sound/ambience/Good.ogg';
  }

  const isHamletOrHillock = hasAnyToken(['hamlet', 'hillock']);
  if (isHamletOrHillock) {
    return 'sound/ambience/Grasslands.ogg';
  }

  const isLizardmenCity =
    hasAnyToken(['lizardmen', 'lizardman', 'lizardfolk']) && hasAnyToken(['city']);
  if (isLizardmenCity) {
    return 'sound/ambience/Rainforest.ogg';
  }

  const isTavern = hasAnyToken(['tavern']);
  if (isTavern) {
    return 'sound/ambience/Tavern.ogg';
  }

  const isCastleOrTown = hasAnyToken(['castle', 'town', 'city']);
  if (isCastleOrTown) {
    return 'sound/ambience/Trade_Depot.ogg';
  }

  return null;
}

function playStructureAmbienceForTile(tile) {
  if (!elements.structureAmbienceAudio) {
    return;
  }
  const track = selectStructureAmbienceTrack(tile);
  if (!track) {
    stopStructureAmbience();
    return;
  }

  const encodedTrack = encodeURI(track);
  const shouldReload = structureAmbienceState.currentTrack !== encodedTrack;
  structureAmbienceState.currentTrack = encodedTrack;

  if (shouldReload) {
    try {
      elements.structureAmbienceAudio.pause();
    } catch (error) {
      /* ignore */
    }
    elements.structureAmbienceAudio.src = encodedTrack;
    elements.structureAmbienceAudio.load();
  }

  if (audioState.effectsMuted || audioState.effectsVolume <= 0) {
    return;
  }

  elements.structureAmbienceAudio.volume = clamp(audioState.effectsVolume, 0, 1);
  try {
    elements.structureAmbienceAudio.currentTime = 0;
  } catch (error) {
    /* ignore reset errors */
  }
  try {
    const playPromise = elements.structureAmbienceAudio.play();
    if (playPromise && typeof playPromise.catch === 'function') {
      playPromise.catch(() => {});
    }
  } catch (error) {
    /* ignore playback errors */
  }
}

function stopStructureAmbience() {
  if (!elements.structureAmbienceAudio) {
    return;
  }
  structureAmbienceState.currentTrack = null;
  try {
    elements.structureAmbienceAudio.pause();
  } catch (error) {
    /* ignore */
  }
  try {
    elements.structureAmbienceAudio.currentTime = 0;
  } catch (error) {
    /* ignore */
  }
}

function updateStructureAmbienceVolume() {
  if (!elements.structureAmbienceAudio) {
    return;
  }
  const finalVolume = audioState.effectsMuted ? 0 : clamp(audioState.effectsVolume, 0, 1);
  elements.structureAmbienceAudio.volume = finalVolume;
  if (finalVolume <= 0) {
    try {
      elements.structureAmbienceAudio.pause();
    } catch (error) {
      /* ignore */
    }
    return;
  }
  if (!structureDetailsState.visible || !structureAmbienceState.currentTrack) {
    return;
  }
  try {
    const playPromise = elements.structureAmbienceAudio.play();
    if (playPromise && typeof playPromise.catch === 'function') {
      playPromise.catch(() => {});
    }
  } catch (error) {
    /* ignore */
  }
}

const structureContextMenuState = {
  visible: false,
  tile: null,
  tileX: null,
  tileY: null
};

const normalizeDwarfholdKey = (value) => {
  if (typeof value !== 'string') {
    return '';
  }
  return value
    .toUpperCase()
    .replace(/[^A-Z0-9]/g, '');
};

const dwarfholdStructureKeys = new Set(
  [
    'DWARFHOLD',
    'GREAT_DWARFHOLD',
    'GREATDWARFHOLD',
    'ABANDONED_DWARFHOLD',
    'DARK_DWARFHOLD',
    'DARKDWARFHOLD',
    'HILLHOLD'
  ].map((key) => normalizeDwarfholdKey(key))
);

function isDwarfholdStructureTile(tile) {
  if (!tile) {
    return false;
  }
  const normalizedStructureKey = normalizeDwarfholdKey(tile.structure);
  if (normalizedStructureKey && dwarfholdStructureKeys.has(normalizedStructureKey)) {
    return true;
  }
  const rawType = tile.structureDetails?.type;
  const normalizedStructureType = normalizeDwarfholdKey(rawType);
  if (normalizedStructureType && dwarfholdStructureKeys.has(normalizedStructureType)) {
    return true;
  }
  if (typeof tile.structureName === 'string') {
    const normalizedName = normalizeDwarfholdKey(tile.structureName);
    for (const key of dwarfholdStructureKeys) {
      if (normalizedName.includes(key)) {
        return true;
      }
    }
  }
  return false;
}

function enrichTileWithDwarfholdDetails(tile, tileX, tileY, world = state.currentWorld) {
  if (!tile) {
    return null;
  }

  const existingDetails = tile.structureDetails;
  if (existingDetails && Object.keys(existingDetails).length > 0) {
    if (tile.structureName || !existingDetails.name) {
      return tile;
    }
    return { ...tile, structureName: existingDetails.name };
  }

  if (!isDwarfholdStructureTile(tile)) {
    return tile;
  }

  const resolvedWorld = world;
  if (!resolvedWorld || !Array.isArray(resolvedWorld.dwarfholds)) {
    return tile;
  }
  if (!Number.isInteger(tileX) || !Number.isInteger(tileY)) {
    return tile;
  }

  const match = resolvedWorld.dwarfholds.find((hold) => hold && hold.x === tileX && hold.y === tileY);
  if (!match) {
    return tile;
  }

  const { x: holdX, y: holdY, ...details } = match;
  const mergedDetails = { ...(tile.structureDetails || {}), ...details };
  const resolvedName = mergedDetails.name || tile.structureName || tile.areaName;

  const enrichedTile = { ...tile, structureDetails: mergedDetails };
  if (resolvedName) {
    enrichedTile.structureName = resolvedName;
  }

  return enrichedTile;
}

function resolveTileForContextMenu(tile, tileX, tileY) {
  const world = state.currentWorld;
  const tiles = world && Array.isArray(world.tiles) ? world.tiles : null;
  const height = tiles ? tiles.length : 0;
  const width = height > 0 && Array.isArray(tiles[0]) ? tiles[0].length : 0;

  let resolvedTile = tile || null;
  if (tiles && width > 0 && Number.isInteger(tileX) && Number.isInteger(tileY)) {
    const worldTile = getWorldTileAt(tiles, width, height, tileX, tileY);
    if (worldTile) {
      resolvedTile = worldTile;
    }
  }

  if (!resolvedTile) {
    return null;
  }

  return enrichTileWithDwarfholdDetails(resolvedTile, tileX, tileY, world);
}

function computeViewScales(wrapperWidth, wrapperHeight, worldWidth, worldHeight) {
  if (!worldWidth || !worldHeight || !wrapperWidth || !wrapperHeight) {
    return { contain: 1, cover: 1 };
  }

  const scaleX = wrapperWidth / worldWidth;
  const scaleY = wrapperHeight / worldHeight;
  const safeScaleX = Number.isFinite(scaleX) && scaleX > 0 ? scaleX : 1;
  const safeScaleY = Number.isFinite(scaleY) && scaleY > 0 ? scaleY : 1;
  const contain = Math.min(safeScaleX, safeScaleY);
  const cover = Math.max(safeScaleX, safeScaleY);
  return { contain, cover };
}

function applyViewTransform() {
  if (!elements.canvas) {
    return;
  }
  elements.canvas.style.transform = `translate(${viewState.translateX}px, ${viewState.translateY}px) scale(${viewState.scale})`;
}

function hideMapTooltip() {
  if (!elements.mapTooltip) {
    return;
  }
  elements.mapTooltip.classList.remove('visible');
  elements.mapTooltip.setAttribute('aria-hidden', 'true');
}

function hideStructureContextMenu() {
  structureContextMenuState.visible = false;
  structureContextMenuState.tile = null;
  structureContextMenuState.tileX = null;
  structureContextMenuState.tileY = null;

  if (!elements.structureContextMenu) {
    return;
  }

  elements.structureContextMenu.classList.remove('visible');
  elements.structureContextMenu.setAttribute('aria-hidden', 'true');
  elements.structureContextMenu.style.left = '';
  elements.structureContextMenu.style.top = '';
}

function updateStructureContextMenuActions(tile) {
  const beginButton = elements.structureContextMenuBegin;
  if (beginButton) {
    beginButton.disabled = false;
    beginButton.setAttribute('aria-disabled', 'false');
  }

  const moreInfoButton = elements.structureContextMenuMoreInfo;
  if (!moreInfoButton) {
    return;
  }

  const hasStructureDetails = Boolean(
    tile && (tile.structureName || (tile.structureDetails && tile.structureDetails.name))
  );
  if (hasStructureDetails) {
    moreInfoButton.disabled = false;
    moreInfoButton.setAttribute('aria-disabled', 'false');
  } else {
    moreInfoButton.disabled = true;
    moreInfoButton.setAttribute('aria-disabled', 'true');
  }
}

function showStructureContextMenu(resolved) {
  if (!resolved || !elements.structureContextMenu) {
    hideStructureContextMenu();
    return;
  }

  const { pointerX, pointerY, rect, tile, tileX, tileY } = resolved;
  if (!Number.isFinite(pointerX) || !Number.isFinite(pointerY)) {
    hideStructureContextMenu();
    return;
  }

  const resolvedTileX = Number.isFinite(tileX) ? tileX : null;
  const resolvedTileY = Number.isFinite(tileY) ? tileY : null;
  const resolvedTile = resolveTileForContextMenu(tile, resolvedTileX, resolvedTileY) || tile || null;

  structureContextMenuState.tile = resolvedTile;
  structureContextMenuState.tileX = resolvedTileX;
  structureContextMenuState.tileY = resolvedTileY;

  updateStructureContextMenuActions(resolvedTile);

  const menu = elements.structureContextMenu;
  const margin = 16;
  const boundsRect = rect || (elements.canvasWrapper ? elements.canvasWrapper.getBoundingClientRect() : null);
  const menuWidth = menu.offsetWidth || 0;
  const menuHeight = menu.offsetHeight || 0;
  const fallbackWidth =
    typeof window !== 'undefined' && Number.isFinite(window.innerWidth)
      ? window.innerWidth
      : menuWidth + margin * 2;
  const fallbackHeight =
    typeof window !== 'undefined' && Number.isFinite(window.innerHeight)
      ? window.innerHeight
      : menuHeight + margin * 2;
  const containerWidth = boundsRect && Number.isFinite(boundsRect.width) ? boundsRect.width : fallbackWidth;
  const containerHeight =
    boundsRect && Number.isFinite(boundsRect.height) ? boundsRect.height : fallbackHeight;

  let left = pointerX + margin;
  if (left + menuWidth > containerWidth - margin) {
    left = pointerX - menuWidth - margin;
  }
  if (left < margin) {
    left = Math.max(margin, containerWidth - menuWidth - margin);
  }

  let top = pointerY + margin;
  if (top + menuHeight > containerHeight - margin) {
    top = pointerY - menuHeight - margin;
  }
  if (top < margin) {
    top = Math.max(margin, containerHeight - menuHeight - margin);
  }

  menu.style.left = `${Math.round(left)}px`;
  menu.style.top = `${Math.round(top)}px`;
  menu.classList.add('visible');
  menu.setAttribute('aria-hidden', 'false');
  structureContextMenuState.visible = true;

  const focusTarget = elements.structureContextMenuBegin;
  if (focusTarget && typeof focusTarget.focus === 'function') {
    const focusAction = () => {
      if (structureContextMenuState.visible) {
        focusTarget.focus();
      }
    };
    if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
      window.requestAnimationFrame(focusAction);
    } else {
      focusAction();
    }
  }
}

function formatPercentageDisplay(value) {
  if (!Number.isFinite(value)) {
    return '0';
  }
  const rounded = Math.round(value * 100) / 100;
  return rounded.toLocaleString('en-US', {
    minimumFractionDigits: 0,
    maximumFractionDigits: 2
  });
}

function formatGradientPercentage(value) {
  if (!Number.isFinite(value)) {
    return '0';
  }
  const rounded = Math.round(value * 100) / 100;
  return Number(rounded.toFixed(2)).toString();
}

function buildPopulationBreakdownSection(resolvedName, breakdown) {
  if (!Array.isArray(breakdown) || breakdown.length === 0) {
    return '';
  }

  const resolvedEntries = breakdown
    .filter((entry) => Number.isFinite(entry?.percentage) && entry.percentage > 0)
    .map((entry) => {
      const rawPercentage = Number(entry.percentage);
      const safePercentage = Number.isFinite(rawPercentage) ? Math.max(0, rawPercentage) : 0;
      const roundedPercentage = Math.round(safePercentage * 100) / 100;
      return {
        key: typeof entry.key === 'string' && entry.key ? entry.key : null,
        label: entry.label || entry.key || 'Unknown',
        percentage: roundedPercentage,
        color: entry.color || '#999999',
        population:
          Number.isFinite(entry.population) && entry.population > 0
            ? Math.max(0, Math.round(entry.population))
            : null
      };
    });

  const priorityEntries = [];
  const majorEntries = [];
  let otherPercentage = 0;
  let otherPopulation = 0;
  let otherPopulationKnown = true;

  resolvedEntries.forEach((entry) => {
    if (entry.key === 'wizards') {
      priorityEntries.push(entry);
      return;
    }

    if (entry.percentage < 0.5) {
      otherPercentage += entry.percentage;
      if (entry.population === null) {
        otherPopulationKnown = false;
      } else if (otherPopulationKnown) {
        otherPopulation += entry.population;
      }
    } else {
      majorEntries.push(entry);
    }
  });

  const combinedEntries = [...priorityEntries, ...majorEntries];

  if (otherPercentage > 0) {
    const roundedOtherPercentage = Math.round(otherPercentage * 100) / 100;
    combinedEntries.push({
      label: 'Other',
      percentage: roundedOtherPercentage,
      color: '#666666',
      population: otherPopulationKnown ? otherPopulation : null
    });
  }

  const displayEntries = combinedEntries.length > 0 ? combinedEntries : resolvedEntries;

  if (displayEntries.length === 0) {
    return '';
  }

  let cumulative = 0;
  const stops = displayEntries.map((entry, index) => {
    const start = Math.min(100, Math.max(0, Math.round(cumulative * 100) / 100));
    cumulative = Math.round((cumulative + entry.percentage) * 100) / 100;
    const end =
      index === displayEntries.length - 1
        ? 100
        : Math.min(100, Math.max(0, Math.round(cumulative * 100) / 100));
    return `${entry.color} ${formatGradientPercentage(start)}% ${formatGradientPercentage(end)}%`;
  });

  if (stops.length === 0) {
    return '';
  }

  const pieStyle = `background: conic-gradient(${stops.join(', ')});`;
  const ariaLabelParts = ['Population breakdown'];
  if (resolvedName) {
    ariaLabelParts.push(`for ${resolvedName}`);
  }
  const ariaLabel = ariaLabelParts.join(' ');

  const legendItems = displayEntries
    .map((entry) => {
      const valueParts = [`${formatPercentageDisplay(entry.percentage)}%`];
      if (entry.population !== null) {
        valueParts.push(`(${entry.population.toLocaleString('en-US')})`);
      }
      return `
        <li>
          <span class="legend-swatch" style="background:${escapeHtml(entry.color)}"></span>
          <span class="legend-label">${escapeHtml(entry.label)}</span>
          <span class="legend-value">${escapeHtml(valueParts.join(' '))}</span>
        </li>
      `;
    })
    .join('');

  return `
    <div class="tooltip-subtitle">Population Breakdown</div>
    <div class="tooltip-chart">
      <div
        class="tooltip-chart-pie"
        role="img"
        aria-label="${escapeHtml(ariaLabel)}"
        style="${escapeHtml(pieStyle)}"
      ></div>
      <ul class="tooltip-chart-legend">${legendItems}</ul>
    </div>
  `;
}

function getFactionForTile(tile) {
  if (!tile || tile.factionId === null || tile.factionId === undefined) {
    return null;
  }
  const factionIndex = Number(tile.factionId);
  if (!Number.isFinite(factionIndex)) {
    return null;
  }
  const world = state.currentWorld;
  if (!world || !Array.isArray(world.factions)) {
    return null;
  }
  return world.factions[factionIndex] || null;
}

function getDominantCulturalInfluence(tile) {
  if (!tile || !tile.culturalInfluence) {
    return null;
  }
  const { key, label, color, strength, breakdown } = tile.culturalInfluence;
  if (!key) {
    return null;
  }
  const resolvedLabel =
    typeof label === 'string' && label.trim() ? label.trim() : formatCultureLabel(key);
  const resolvedColor = resolveCultureColor(color, key);
  const resolvedStrength = clamp(Number(strength) || 0, 0, 1);
  return {
    key,
    label: resolvedLabel,
    color: resolvedColor,
    strength: resolvedStrength,
    breakdown: Array.isArray(breakdown) ? breakdown : []
  };
}

function summarizeTileResources(tile) {
  if (!tile) {
    return [];
  }

  const catalog = {
    forest: ['Hardwood timber', 'Game animals', 'Medicinal herbs'],
    jungle: ['Rare hardwoods', 'Exotic fruits', 'Alchemical resins'],
    mountain: ['Metallic ores', 'Quarried stone', 'Crystal seams'],
    desert: ['Trade spices', 'Glass sands', 'Hidden oasis wells'],
    badlands: ['Scrap metals', 'Hardy grazing', 'Quartz outcrops'],
    tundra: ['Fur-bearing fauna', 'Permafrost relics', 'Glacial ice'],
    grassland: ['Grain harvests', 'Pasture livestock', 'Wildflower dyes'],
    marsh: ['Peat bogs', 'Reed thickets', 'Bog iron deposits'],
    ocean: ['Rich fisheries', 'Pearl beds', 'Kelp forests'],
    lake: ['Freshwater catches', 'Boat timber', 'Shoreline clay']
  };

  const resources = new Set();
  const biomeResources = catalog[tile.biomeType];
  if (Array.isArray(biomeResources)) {
    biomeResources.forEach((entry) => {
      if (typeof entry === 'string' && entry.trim()) {
        resources.add(entry.trim());
      }
    });
  }

  const coastProximity = clamp(Number(tile.coastProximity) || 0, 0, 1);
  const marshProximity = clamp(Number(tile.marshProximity) || 0, 0, 1);
  const desertProximity = clamp(Number(tile.desertProximity) || 0, 0, 1);
  const volcanoProximity = clamp(Number(tile.volcanoProximity) || 0, 0, 1);
  const canopyDensity = clamp(Number(tile.forestCanopyDensity) || 0, 0, 1);
  const temperature = clamp(Number(tile.temperature) || 0, 0, 1);

  if (coastProximity >= 0.65 || tile.biomeType === 'ocean' || tile.biomeType === 'lake') {
    resources.add('Coastal fisheries');
  }
  if (marshProximity >= 0.55 && tile.biomeType !== 'marsh') {
    resources.add('Peat and bog iron');
  }
  if (desertProximity >= 0.55 && tile.biomeType !== 'desert') {
    resources.add('Trade caravans');
  }
  if (volcanoProximity >= 0.45) {
    resources.add('Volcanic glass & obsidian');
  }
  if (canopyDensity >= 0.65) {
    resources.add('Dense lumber stands');
  }
  if (temperature <= 0.25 && tile.biomeType !== 'tundra') {
    resources.add('Fur-bearing game');
  }

  return Array.from(resources).slice(0, 5);
}

function describeTileClimate(tile) {
  if (!tile) {
    return null;
  }

  const temperature = clamp(Number(tile.temperature) || 0, 0, 1);
  const moisture = clamp(Number(tile.moisture) || 0, 0, 1);

  const temperatureBands = [
    { threshold: 0.18, label: 'Polar chill' },
    { threshold: 0.32, label: 'Cold climate' },
    { threshold: 0.48, label: 'Cool climate' },
    { threshold: 0.68, label: 'Temperate climate' },
    { threshold: 0.85, label: 'Warm climate' },
    { threshold: Infinity, label: 'Tropical heat' }
  ];

  const moistureBands = [
    { threshold: 0.18, label: 'parched air' },
    { threshold: 0.32, label: 'dry winds' },
    { threshold: 0.52, label: 'balanced rainfall' },
    { threshold: 0.7, label: 'humid air' },
    { threshold: 0.85, label: 'wet seasons' },
    { threshold: Infinity, label: 'waterlogged ground' }
  ];

  const resolveBandLabel = (bands, value) => {
    for (let i = 0; i < bands.length; i += 1) {
      if (value <= bands[i].threshold) {
        return bands[i].label;
      }
    }
    return null;
  };

  const temperatureLabel = resolveBandLabel(temperatureBands, temperature);
  const moistureLabel = resolveBandLabel(moistureBands, moisture);

  if (!temperatureLabel && !moistureLabel) {
    return null;
  }

  const qualifiers = [];
  const coastProximity = clamp(Number(tile.coastProximity) || 0, 0, 1);
  const marshProximity = clamp(Number(tile.marshProximity) || 0, 0, 1);
  const volcanoProximity = clamp(Number(tile.volcanoProximity) || 0, 0, 1);
  const desertProximity = clamp(Number(tile.desertProximity) || 0, 0, 1);

  if (coastProximity >= 0.65) {
    qualifiers.push('coastal breezes');
  }
  if (desertProximity >= 0.55 && moisture < 0.4) {
    qualifiers.push('dry trade winds');
  }
  if (marshProximity >= 0.6) {
    qualifiers.push('lowland mists');
  }
  if (volcanoProximity >= 0.45) {
    qualifiers.push('volcanic warmth');
  }

  const climateParts = [];
  if (temperatureLabel) {
    climateParts.push(temperatureLabel);
  }
  if (moistureLabel) {
    climateParts.push(`with ${moistureLabel}`);
  }

  let description = climateParts.join(' ');
  if (qualifiers.length > 0) {
    description += ` (${formatListWithConjunction(qualifiers)})`;
  }

  return description;
}

function derivePopulationGroupsFromCulture(tile) {
  if (!tile || !tile.culturalInfluence || !Array.isArray(tile.culturalInfluence.breakdown)) {
    return { major: null, minor: null };
  }

  const breakdown = tile.culturalInfluence.breakdown
    .map((entry) => {
      if (!entry) {
        return null;
      }
      const share = clamp(Number(entry.share) || 0, 0, 1);
      if (share <= 0) {
        return null;
      }
      const label =
        typeof entry.label === 'string' && entry.label.trim()
          ? entry.label.trim()
          : formatCultureLabel(entry.key);
      return { label, share };
    })
    .filter(Boolean)
    .sort((a, b) => b.share - a.share);

  if (breakdown.length === 0) {
    return { major: null, minor: null };
  }

  const majors = [];
  const minors = [];

  breakdown.forEach((entry, index) => {
    const percentage = Math.round(entry.share * 100);
    const display = percentage >= 5 ? `${entry.label} (${percentage}%)` : entry.label;
    if (index === 0 || entry.share >= 0.22 || (majors.length < 2 && entry.share >= 0.16)) {
      majors.push(display);
    } else if (entry.share >= 0.08 || minors.length < 2) {
      minors.push(display);
    }
  });

  if (majors.length === 0 && minors.length > 0) {
    majors.push(minors.shift());
  }

  return {
    major: majors.length > 0 ? formatListWithConjunction(majors) : null,
    minor: minors.length > 0 ? formatListWithConjunction(minors) : null
  };
}

function buildStructureTooltipContent(tile) {
  if (!tile) {
    return null;
  }

  const details = tile.structureDetails;

  const buildAmbientTooltip = (ambientStructure) => {
    if (!ambientStructure || !ambientStructure.label) {
      return null;
    }
    const sections = [`<div class="tooltip-title">${escapeHtml(ambientStructure.label)}</div>`];
    const entries = [];
    const cultureLabel = ambientStructure.cultureLabel || tile.culturalInfluence?.label || null;
    const influenceDescription = tile.culturalInfluence
      ? describeInfluenceStrength(tile.culturalInfluence.strength)
      : null;
    if (cultureLabel) {
      const value = influenceDescription ? `${cultureLabel} — ${influenceDescription}` : cultureLabel;
      entries.push({ label: 'Cultural Tie', value });
    }
    const areaName = tile.areaName;
    if (areaName) {
      entries.push({ label: 'Region', value: areaName });
    }
    const biomeType = tile.biomeType;
    if (biomeType) {
      const definition = biomeTypeDefinitions[biomeType] || null;
      let biomeLabel = definition && definition.label ? definition.label : null;
      if (!biomeLabel && typeof biomeType === 'string' && biomeType.length > 0) {
        biomeLabel = biomeType.charAt(0).toUpperCase() + biomeType.slice(1);
      }
      if (biomeLabel) {
        entries.push({ label: 'Biome', value: biomeLabel });
      }
    }
    const climateDescription = describeTileClimate(tile);
    if (climateDescription) {
      entries.push({ label: 'Climate', value: climateDescription });
    }
    const resourceSummary = summarizeTileResources(tile);
    if (resourceSummary.length > 0) {
      const formattedResources = formatListWithConjunction(resourceSummary);
      if (formattedResources) {
        entries.push({ label: 'Resources', value: formattedResources });
      }
    }
    const populationGroups = derivePopulationGroupsFromCulture(tile);
    if (populationGroups.major) {
      entries.push({ label: 'Major Population Groups', value: populationGroups.major });
    }
    if (populationGroups.minor) {
      entries.push({ label: 'Minor Population Groups', value: populationGroups.minor });
    }
    if (entries.length > 0) {
      const listItems = entries
        .map(
          ({ label, value }) =>
            `<li><span class="tooltip-term">${escapeHtml(label)}</span><span class="tooltip-value">${escapeHtml(
              value
            )}</span></li>`
        )
        .join('');
      sections.push(`<ul class="tooltip-list">${listItems}</ul>`);
    }
    return sections.join('');
  };

  if (!tile.structureName) {
    const ambientStructure = tile.ambientStructure;
    const areaName = tile.areaName;
    const biomeType = tile.biomeType;
    const ambientContent = buildAmbientTooltip(ambientStructure);
    if (ambientContent) {
      return ambientContent;
    }
    if (!biomeType && !areaName) {
      return null;
    }
    const definition = biomeType ? biomeTypeDefinitions[biomeType] : null;
    let biomeLabel = definition && definition.label ? definition.label : null;
    if (!biomeLabel && typeof biomeType === 'string' && biomeType.length > 0) {
      biomeLabel = biomeType.charAt(0).toUpperCase() + biomeType.slice(1);
    }
    const fallbackTitle = biomeLabel ? `Unnamed ${biomeLabel}` : 'Unnamed Region';
    const resolvedTitle = areaName || fallbackTitle;
    if (!resolvedTitle) {
      return null;
    }
    const sections = [`<div class="tooltip-title">${escapeHtml(resolvedTitle)}</div>`];
    const entries = [];
    if (biomeLabel) {
      entries.push({ label: 'Biome', value: biomeLabel });
    }

    const climateDescription = describeTileClimate(tile);
    if (climateDescription) {
      entries.push({ label: 'Climate', value: climateDescription });
    }

    const resourceSummary = summarizeTileResources(tile);
    if (resourceSummary.length > 0) {
      const formattedResources = formatListWithConjunction(resourceSummary);
      if (formattedResources) {
        entries.push({ label: 'Resources', value: formattedResources });
      }
    }

    const populationGroups = derivePopulationGroupsFromCulture(tile);
    if (populationGroups.major) {
      entries.push({ label: 'Major Population Groups', value: populationGroups.major });
    }
    if (populationGroups.minor) {
      entries.push({ label: 'Minor Population Groups', value: populationGroups.minor });
    }

    if (entries.length > 0) {
      const listItems = entries
        .map(
          ({ label, value }) =>
            `<li><span class="tooltip-term">${escapeHtml(label)}</span><span class="tooltip-value">${escapeHtml(
              value
            )}</span></li>`
        )
        .join('');
      sections.push(`<ul class="tooltip-list">${listItems}</ul>`);
    }

    return sections.join('');
  }

  if (details?.isAmbientStructure) {
    const ambientContent = buildAmbientTooltip(details.ambientStructure);
    if (ambientContent) {
      return ambientContent;
    }
  }

  const isSettlement =
    details && (details.isSettlement || (details.type && settlementDetailTypes.has(details.type)));
  if (isSettlement) {
    const sections = [];
    const entries = [];
    const resolvedName = details.name || tile.structureName;
    sections.push(`<div class="tooltip-title">${escapeHtml(resolvedName)}</div>`);

    const faction = getFactionForTile(tile);
    if (faction && faction.name) {
      entries.push({ label: 'Realm', value: faction.name });
    }

    const dominantCulture = getDominantCulturalInfluence(tile);
    if (dominantCulture) {
      const influenceDescription = describeInfluenceStrength(dominantCulture.strength);
      const value = influenceDescription
        ? `${dominantCulture.label} — ${influenceDescription}`
        : dominantCulture.label;
      entries.push({ label: 'Cultural Influence', value });
    }

    if (details.classification) {
      entries.push({ label: 'Classification', value: details.classification });
    }

    if (Number.isFinite(details.population)) {
      const populationValue = Math.max(0, Math.round(details.population));
      const formattedPopulation = populationValue.toLocaleString('en-US');
      const populationLabel = details.populationLabel || 'Population';
      const populationDescriptor = details.populationDescriptor || null;
      const populationDisplay = populationDescriptor
        ? `${formattedPopulation} ${populationDescriptor}`
        : formattedPopulation;
      entries.push({ label: populationLabel, value: populationDisplay });
    }

    if (details.ruler) {
      const rulerTitle = details.ruler.title ? `${details.ruler.title} ` : '';
      const rulerName = details.ruler.name || '';
      const combined = `${rulerTitle}${rulerName}`.trim();
      if (combined) {
        const rulerLabel = details.ruler.label || 'Ruler';
        entries.push({ label: rulerLabel, value: combined });
      }
    }

    if (Number.isFinite(details.foundedYearsAgo)) {
      const foundedValue = Math.max(1, Math.round(details.foundedYearsAgo));
      entries.push({ label: 'Founded', value: `${foundedValue} years ago` });
    }

    const prominentGroup = details.prominentGroup || details.prominentClan;
    if (prominentGroup) {
      const prominentLabel = details.prominentGroupLabel || (details.prominentClan ? 'Prominent Clan' : 'Prominent Group');
      entries.push({ label: prominentLabel, value: prominentGroup });
    }

    if (details.wizardTradition) {
      const traditionLabel = details.wizardTraditionLabel || 'Arcane Tradition';
      entries.push({ label: traditionLabel, value: details.wizardTradition });
    }

    if (Array.isArray(details.majorClans) && details.majorClans.length > 0) {
      const formattedClans = formatListWithConjunction(details.majorClans);
      if (formattedClans) {
        const majorClansLabel = details.majorClansLabel || 'Major Clans';
        entries.push({ label: majorClansLabel, value: formattedClans });
      }
    }

    if (Array.isArray(details.majorGuilds) && details.majorGuilds.length > 0) {
      const uniqueGuilds = Array.from(
        new Set(details.majorGuilds.filter((guild) => typeof guild === 'string' && guild.trim()))
      );
      if (uniqueGuilds.length > 0) {
        const guildsLabel = details.majorGuildsLabel || 'Major Guilds';
        entries.push({ label: guildsLabel, value: uniqueGuilds.join(', ') });
      }
    }

    if (Array.isArray(details.majorExports) && details.majorExports.length > 0) {
      const uniqueExports = Array.from(
        new Set(details.majorExports.filter((item) => typeof item === 'string' && item.trim()))
      );
      if (uniqueExports.length > 0) {
        const exportsLabel = details.majorExportsLabel || 'Major Exports';
        entries.push({ label: exportsLabel, value: uniqueExports.join(', ') });
      }
    }

    if (entries.length > 0) {
      const listItems = entries
        .map(
          ({ label, value }) =>
            `<li><span class="tooltip-term">${escapeHtml(label)}</span><span class="tooltip-value">${escapeHtml(
              value
            )}</span></li>`
        )
        .join('');
      sections.push(`<ul class="tooltip-list">${listItems}</ul>`);
    }

    const breakdownSection = buildPopulationBreakdownSection(resolvedName, details.populationBreakdown);

    if (breakdownSection) {
      sections.push(breakdownSection);
    }

    if (details.hallmark) {
      const hallmarkLabel = details.hallmarkLabel;
      const noteContent = escapeHtml(details.hallmark);
      if (hallmarkLabel) {
        sections.push(`
          <div class="tooltip-subtitle">${escapeHtml(hallmarkLabel)}</div>
          <p class="tooltip-note">${noteContent}</p>
        `);
      } else {
        sections.push(`<p class="tooltip-note">${noteContent}</p>`);
      }
    }

    return sections.join('');
  }

  const fallbackTitle = `<div class="tooltip-title">${escapeHtml(tile.structureName)}</div>`;
  const sections = [fallbackTitle];
  const entries = [];
  const faction = getFactionForTile(tile);
  if (faction && faction.name) {
    entries.push({ label: 'Realm', value: faction.name });
  }

  const dominantCulture = getDominantCulturalInfluence(tile);
  if (dominantCulture) {
    const influenceDescription = describeInfluenceStrength(dominantCulture.strength);
    const value = influenceDescription
      ? `${dominantCulture.label} — ${influenceDescription}`
      : dominantCulture.label;
    entries.push({ label: 'Cultural Influence', value });
  }

  if (details) {
    if (details.displayType) {
      entries.push({ label: 'Type', value: details.displayType });
    }
    if (details.hosts) {
      entries.push({ label: 'Hosts', value: details.hosts });
    }
    if (details.campFocus) {
      entries.push({ label: 'Focus', value: details.campFocus });
    }
    if (details.supplies) {
      entries.push({ label: 'Provisions', value: details.supplies });
    }
    if (details.services) {
      entries.push({ label: 'Services', value: details.services });
    }
    if (details.tribe) {
      entries.push({ label: 'Tribe', value: details.tribe });
    }
    if (details.threatLevel) {
      entries.push({ label: 'Threat Level', value: details.threatLevel });
    }
    if (details.inhabitants) {
      entries.push({ label: 'Inhabitants', value: details.inhabitants });
    }
    if (details.warLeader) {
      entries.push({ label: 'Warlord', value: details.warLeader });
    }
    if (details.guardians) {
      entries.push({ label: 'Guardians', value: details.guardians });
    }
    if (details.depth) {
      entries.push({ label: 'Depth', value: details.depth });
    }
    if (details.order) {
      entries.push({ label: 'Order', value: details.order });
    }
    if (details.devotion) {
      entries.push({ label: 'Devotion', value: details.devotion });
    }
    if (details.caretaker) {
      entries.push({ label: 'Caretaker', value: details.caretaker });
    }
    if (details.innkeeper) {
      entries.push({ label: 'Innkeeper', value: details.innkeeper });
    }
    if (details.specialty) {
      entries.push({ label: 'House Specialty', value: details.specialty });
    }
    if (details.reputation) {
      entries.push({ label: 'Reputation', value: details.reputation });
    }
    if (details.amenities) {
      entries.push({ label: 'Amenities', value: details.amenities });
    }
    if (details.rooms) {
      entries.push({ label: 'Rooms', value: details.rooms });
    }
    if (details.rates) {
      entries.push({ label: 'Rates', value: details.rates });
    }
    if (details.notableGuests) {
      entries.push({ label: 'Notable Patrons', value: details.notableGuests });
    }
    if (details.rulingHouse) {
      entries.push({ label: 'Ruling House', value: details.rulingHouse });
    }
    if (details.banner) {
      entries.push({ label: 'Banner', value: details.banner });
    }
    if (Number.isFinite(details.garrison)) {
      entries.push({ label: 'Garrison', value: Math.max(0, Math.round(details.garrison)).toLocaleString('en-US') });
    }
    if (details.patronSaint) {
      entries.push({ label: 'Patron Saint', value: details.patronSaint });
    }
    if (details.description) {
      sections.push(`<p class="tooltip-note">${escapeHtml(details.description)}</p>`);
    }
  }

  if (entries.length > 0) {
    const listItems = entries
      .map(
        ({ label, value }) =>
          `<li><span class="tooltip-term">${escapeHtml(label)}</span><span class="tooltip-value">${escapeHtml(
            value
          )}</span></li>`
      )
      .join('');
    sections.push(`<ul class="tooltip-list">${listItems}</ul>`);
  }

  return sections.join('');
}

function computeLocalViewBounds(tileX, tileY, width, height, radius) {
  const clampedRadius = Math.max(0, Math.floor(radius));
  const startX = Math.max(0, tileX - clampedRadius);
  const endX = Math.min(width - 1, tileX + clampedRadius);
  const startY = Math.max(0, tileY - clampedRadius);
  const endY = Math.min(height - 1, tileY + clampedRadius);
  return {
    startX,
    startY,
    endX,
    endY,
    width: endX - startX + 1,
    height: endY - startY + 1
  };
}

function resolveLocalSubtitle(tile) {
  if (!tile) {
    return 'Local terrain preview';
  }
  const subtitleParts = [];
  const details = tile.structureDetails;
  if (details) {
    if (details.displayType) {
      subtitleParts.push(details.displayType);
    }
    if (details.classification && !subtitleParts.includes(details.classification)) {
      subtitleParts.push(details.classification);
    }
  }
  if (subtitleParts.length === 0 && tile.biomeType) {
    const definition = biomeTypeDefinitions[tile.biomeType];
    if (definition && definition.label) {
      subtitleParts.push(definition.label);
    } else {
      subtitleParts.push(tile.biomeType.charAt(0).toUpperCase() + tile.biomeType.slice(1));
    }
  }
  return subtitleParts.length > 0 ? subtitleParts.join(' • ') : 'Local terrain preview';
}

function renderDwarfholdScreen() {
  const view = state.dwarfholdView;
  const customMap = view && view.active ? view.map : null;

  if (elements.dwarfholdScreen) {
    if (view && view.active) {
      elements.dwarfholdScreen.setAttribute('aria-hidden', 'false');
    } else {
      elements.dwarfholdScreen.setAttribute('aria-hidden', 'true');
    }
  }

  if (!customMap) {
    if (elements.dwarfholdTitle) {
      elements.dwarfholdTitle.textContent = 'Dwarven Hold Interior';
    }
    if (elements.dwarfholdSubtitle) {
      elements.dwarfholdSubtitle.textContent = '';
    }
    if (elements.dwarfholdDescription) {
      elements.dwarfholdDescription.textContent = '';
    }
    if (elements.dwarfholdCoordinates) {
      elements.dwarfholdCoordinates.textContent = '';
    }
    if (elements.dwarfholdFeatures) {
      elements.dwarfholdFeatures.innerHTML = '';
    }
    if (elements.dwarfholdLegend) {
      elements.dwarfholdLegend.innerHTML = '';
    }
    if (elements.dwarfholdCanvas) {
      const canvas = elements.dwarfholdCanvas;
      const ctx = canvas.getContext('2d');
      canvas.setAttribute('aria-hidden', 'true');
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width || 0, canvas.height || 0);
      }
    }
    return;
  }

  const structure = view.structure;
  const resolvedTitle =
    customMap.title ||
    (structure?.structureName || structure?.areaName || structure?.structureDetails?.displayType || 'Dwarven Hold Interior');
  if (elements.dwarfholdTitle) {
    elements.dwarfholdTitle.textContent = resolvedTitle;
  }

  const resolvedSubtitle =
    customMap.subtitle ||
    (structure?.structureDetails?.displayType
      ? `${structure.structureDetails.displayType} interior`
      : 'Subterranean stronghold overview');
  if (elements.dwarfholdSubtitle) {
    elements.dwarfholdSubtitle.textContent = resolvedSubtitle;
  }

  if (elements.dwarfholdDescription) {
    elements.dwarfholdDescription.textContent = customMap.description || '';
  }

  if (elements.dwarfholdCoordinates) {
    if (Number.isFinite(view.tileX) && Number.isFinite(view.tileY)) {
      const baseLabel = `World Tile ${view.tileX + 1}, ${view.tileY + 1}`;
      const sizeLabel =
        Number.isFinite(customMap.width) && Number.isFinite(customMap.height)
          ? ` — ${customMap.width}×${customMap.height} tiles`
          : '';
      elements.dwarfholdCoordinates.textContent = `${baseLabel}${sizeLabel}`;
    } else {
      elements.dwarfholdCoordinates.textContent = '';
    }
  }

  if (elements.dwarfholdFeatures) {
    elements.dwarfholdFeatures.innerHTML = '';
    const featureList = Array.isArray(customMap.features) ? customMap.features : [];
    if (featureList.length === 0) {
      const emptyItem = document.createElement('li');
      emptyItem.className = 'dwarfhold-feature-item dwarfhold-feature-item--empty';
      emptyItem.textContent = 'No notable features recorded.';
      elements.dwarfholdFeatures.appendChild(emptyItem);
    } else {
      featureList.forEach((feature) => {
        const item = document.createElement('li');
        item.className = 'dwarfhold-feature-item';
        item.textContent = feature;
        elements.dwarfholdFeatures.appendChild(item);
      });
    }
  }

  if (elements.dwarfholdLegend) {
    elements.dwarfholdLegend.innerHTML = '';
    const rawEntries = customMap.legend && typeof customMap.legend === 'object' ? customMap.legend : {};
    const legendEntries = Object.entries(rawEntries).sort((a, b) => {
      if (a[0] === 'rock') {
        return b[0] === 'rock' ? 0 : 1;
      }
      if (b[0] === 'rock') {
        return -1;
      }
      const labelA = typeof a[1]?.label === 'string' ? a[1].label : a[0];
      const labelB = typeof b[1]?.label === 'string' ? b[1].label : b[0];
      return labelA.localeCompare(labelB, undefined, { sensitivity: 'base' });
    });

    legendEntries.forEach(([type, definition]) => {
      if (!definition) {
        return;
      }
      const item = document.createElement('li');
      item.className = 'dwarfhold-legend-item';

      const swatch = document.createElement('span');
      swatch.className = 'dwarfhold-legend-swatch';
      const sprite = definition.sprite && typeof definition.sprite === 'object' ? definition.sprite : null;
      const spriteSheet = sprite?.sheet ? state.tileSheets?.[sprite.sheet] : null;
      const spriteSheetUrl = spriteSheet?.image?.src || spriteSheet?.path || null;
      if (sprite && spriteSheet && spriteSheetUrl) {
        const tileSize = Number.isFinite(sprite.size)
          ? sprite.size
          : Number.isFinite(spriteSheet.tileSize)
            ? spriteSheet.tileSize
            : 32;
        const spriteCol = Number.isFinite(sprite.col) ? sprite.col : 0;
        const spriteRow = Number.isFinite(sprite.row) ? sprite.row : 0;
        const spriteSx = Number.isFinite(sprite.sx) ? sprite.sx : spriteCol * tileSize;
        const spriteSy = Number.isFinite(sprite.sy) ? sprite.sy : spriteRow * tileSize;
        swatch.style.backgroundColor = definition.color || '#1f2937';
        swatch.style.backgroundImage = `url(${spriteSheetUrl})`;
        swatch.style.backgroundRepeat = 'no-repeat';
        swatch.style.backgroundPosition = `${-spriteSx}px ${-spriteSy}px`;
        if (spriteSheet.image && spriteSheet.image.width && spriteSheet.image.height) {
          swatch.style.backgroundSize = `${spriteSheet.image.width}px ${spriteSheet.image.height}px`;
        } else {
          swatch.style.backgroundSize = 'auto';
        }
        swatch.style.borderColor = definition.borderColor || 'rgba(255, 255, 255, 0.18)';
        swatch.style.imageRendering = 'pixelated';
      } else {
        swatch.style.backgroundColor = definition.color || '#1f2937';
        swatch.style.backgroundImage = 'none';
        swatch.style.backgroundSize = '';
        swatch.style.borderColor = definition.borderColor || 'rgba(255, 255, 255, 0.18)';
        if (definition.texture === 'speckled' && definition.accent) {
          swatch.style.backgroundImage = `radial-gradient(${definition.accent} 18%, transparent 20%)`;
          swatch.style.backgroundSize = '12px 12px';
        }
      }

      const text = document.createElement('div');
      text.className = 'dwarfhold-legend-text';

      const label = document.createElement('p');
      label.className = 'dwarfhold-legend-label';
      label.textContent = definition.label || type;
      text.appendChild(label);

      const descriptionText = definition.description || definition.examples || null;
      if (descriptionText) {
        const description = document.createElement('p');
        description.className = 'dwarfhold-legend-description';
        description.textContent = descriptionText;
        text.appendChild(description);
      }

      item.appendChild(swatch);
      item.appendChild(text);
      elements.dwarfholdLegend.appendChild(item);
    });
  }

  const canvas = elements.dwarfholdCanvas;
  if (canvas) {
    const context = canvas.getContext('2d');
    const tiles = Array.isArray(customMap.tiles) ? customMap.tiles : null;
    const mapHeight = tiles ? tiles.length : 0;
    const mapWidth = mapHeight > 0 && Array.isArray(tiles[0]) ? tiles[0].length : 0;

    if (!context || !tiles || mapWidth === 0 || mapHeight === 0) {
      canvas.setAttribute('aria-hidden', 'true');
      if (context) {
        context.clearRect(0, 0, canvas.width || 0, canvas.height || 0);
      }
      return;
    }

    const baseTileSize = Number.isFinite(dwarfholdScreenConfig.baseTileSize)
      ? dwarfholdScreenConfig.baseTileSize
      : 28;
    const minTileSize = Number.isFinite(dwarfholdScreenConfig.minTileSize)
      ? dwarfholdScreenConfig.minTileSize
      : 4;
    const fallbackMaxSize = Number.isFinite(dwarfholdScreenConfig.maxCanvasSize)
      ? Math.max(1, dwarfholdScreenConfig.maxCanvasSize)
      : 960;
    const viewportPadding = Number.isFinite(dwarfholdScreenConfig.viewportPadding)
      ? Math.max(0, dwarfholdScreenConfig.viewportPadding)
      : 0;

    const parentElement = canvas.parentElement;
    const parentRect =
      parentElement && typeof parentElement.getBoundingClientRect === 'function'
        ? parentElement.getBoundingClientRect()
        : null;
    const viewportWidth =
      typeof window !== 'undefined' && Number.isFinite(window.innerWidth) ? window.innerWidth : fallbackMaxSize;
    const viewportHeight =
      typeof window !== 'undefined' && Number.isFinite(window.innerHeight) ? window.innerHeight : fallbackMaxSize;

    const resolveAvailableDimension = (rectValue, clientValue, viewportValue) => {
      const raw =
        Number.isFinite(rectValue) && rectValue > 0
          ? rectValue
          : Number.isFinite(clientValue) && clientValue > 0
          ? clientValue
          : viewportValue;
      const padded = Math.max(1, Math.floor(raw - viewportPadding * 2));
      return Math.max(1, Math.min(fallbackMaxSize, padded));
    };

    const availableWidth = resolveAvailableDimension(
      parentRect?.width,
      parentElement?.clientWidth,
      viewportWidth
    );
    const availableHeight = resolveAvailableDimension(
      parentRect?.height,
      parentElement?.clientHeight,
      viewportHeight
    );

    const maxTileSizeFromWidth = Math.max(1, Math.floor(availableWidth / mapWidth));
    const maxTileSizeFromHeight = Math.max(1, Math.floor(availableHeight / mapHeight));

    let tilePixelSize = Math.min(baseTileSize, maxTileSizeFromWidth, maxTileSizeFromHeight);

    if (!Number.isFinite(tilePixelSize) || tilePixelSize <= 0) {
      tilePixelSize = minTileSize;
    }

    if (tilePixelSize < minTileSize) {
      tilePixelSize = Math.max(1, Math.min(maxTileSizeFromWidth, maxTileSizeFromHeight));
    }

    if (!Number.isFinite(tilePixelSize) || tilePixelSize <= 0) {
      tilePixelSize = 1;
    }

    let destWidth = Math.max(1, Math.round(mapWidth * tilePixelSize));
    let destHeight = Math.max(1, Math.round(mapHeight * tilePixelSize));

    if (destWidth > availableWidth || destHeight > availableHeight) {
      const fitTileSize = Math.max(1, Math.min(maxTileSizeFromWidth, maxTileSizeFromHeight));
      tilePixelSize = fitTileSize;
      destWidth = Math.max(1, Math.round(mapWidth * tilePixelSize));
      destHeight = Math.max(1, Math.round(mapHeight * tilePixelSize));
    }

    canvas.width = destWidth;
    canvas.height = destHeight;
    canvas.style.maxWidth = '100%';
    canvas.style.maxHeight = '100%';
    canvas.style.width = `${destWidth}px`;
    canvas.style.height = `${destHeight}px`;
    canvas.setAttribute(
      'aria-label',
      `Interior map for ${customMap.title || 'the dwarfhold'} covering ${mapWidth} by ${mapHeight} tiles.`
    );
    canvas.setAttribute('aria-hidden', 'false');

    context.imageSmoothingEnabled = false;
    context.clearRect(0, 0, destWidth, destHeight);
    context.fillStyle = '#05060b';
    context.fillRect(0, 0, destWidth, destHeight);

    const palette = customMap.legend || {};
    const drawInteriorSprite = (spriteDefinition, destX, destY, destSize) => {
      if (!spriteDefinition || typeof spriteDefinition !== 'object') {
        return false;
      }
      const sheetKey = spriteDefinition.sheet;
      if (!sheetKey) {
        return false;
      }
      const sheet = state.tileSheets?.[sheetKey];
      const baseTileSize = Number.isFinite(spriteDefinition.size)
        ? spriteDefinition.size
        : Number.isFinite(sheet?.tileSize)
          ? sheet.tileSize
          : null;
      if (!sheet || !sheet.image || !Number.isFinite(baseTileSize) || baseTileSize <= 0) {
        return false;
      }
      const spriteCol = Number.isFinite(spriteDefinition.col) ? spriteDefinition.col : 0;
      const spriteRow = Number.isFinite(spriteDefinition.row) ? spriteDefinition.row : 0;
      const spriteSx = Number.isFinite(spriteDefinition.sx) ? spriteDefinition.sx : spriteCol * baseTileSize;
      const spriteSy = Number.isFinite(spriteDefinition.sy) ? spriteDefinition.sy : spriteRow * baseTileSize;
      const spriteSw = Number.isFinite(spriteDefinition.sw) ? spriteDefinition.sw : baseTileSize;
      const spriteSh = Number.isFinite(spriteDefinition.sh) ? spriteDefinition.sh : baseTileSize;
      const scale = Number.isFinite(spriteDefinition.scale) ? spriteDefinition.scale : 1;
      const scaleY = Number.isFinite(spriteDefinition.scaleY) ? spriteDefinition.scaleY : scale;
      const width = Math.max(1, destSize * (scale || 1));
      const height = Math.max(1, destSize * (scaleY || 1));
      const offsetX = Number.isFinite(spriteDefinition.offsetX)
        ? spriteDefinition.offsetX * destSize
        : (destSize - width) / 2;
      const offsetY = Number.isFinite(spriteDefinition.offsetY)
        ? spriteDefinition.offsetY * destSize
        : (destSize - height) / 2;
      context.drawImage(
        sheet.image,
        spriteSx,
        spriteSy,
        spriteSw,
        spriteSh,
        destX + offsetX,
        destY + offsetY,
        width,
        height
      );
      return true;
    };

    for (let y = 0; y < mapHeight; y += 1) {
      const row = Array.isArray(tiles[y]) ? tiles[y] : null;
      if (!row) {
        continue;
      }
      for (let x = 0; x < mapWidth; x += 1) {
        const cell = row[x];
        if (cell === null || cell === undefined) {
          continue;
        }

        const type = typeof cell === 'string' ? cell : typeof cell?.type === 'string' ? cell.type : 'rock';
        if (type === 'void') {
          continue;
        }
        const definition = palette[type] || palette.rock || { color: '#1f2937' };
        const cellSprite = cell && typeof cell === 'object' && typeof cell.sprite === 'object' ? cell.sprite : null;
        const definitionSprite = definition.sprite && typeof definition.sprite === 'object' ? definition.sprite : null;
        const destX = x * tilePixelSize;
        const destY = y * tilePixelSize;
        let drewSprite = false;
        if (cellSprite) {
          drewSprite = drawInteriorSprite(cellSprite, destX, destY, tilePixelSize);
        }
        if (!drewSprite && definitionSprite) {
          drewSprite = drawInteriorSprite(definitionSprite, destX, destY, tilePixelSize);
        }

        if (!drewSprite) {
          context.fillStyle = definition.color || '#1f2937';
          context.fillRect(destX, destY, tilePixelSize, tilePixelSize);

          if (definition.texture === 'speckled') {
            context.save();
            context.fillStyle = definition.accent || 'rgba(255, 255, 255, 0.08)';
            const dot = Math.max(1, Math.round(tilePixelSize * 0.18));
            for (let offsetY = dot; offsetY < tilePixelSize; offsetY += dot * 2) {
              for (let offsetX = dot; offsetX < tilePixelSize; offsetX += dot * 2) {
                context.fillRect(destX + offsetX - dot / 2, destY + offsetY - dot / 2, dot, dot);
              }
            }
            context.restore();
          }

          if (definition.borderColor) {
            context.save();
            context.strokeStyle = definition.borderColor;
            context.lineWidth = Math.max(1, Math.round(tilePixelSize * 0.08));
            context.strokeRect(
              destX + context.lineWidth / 2,
              destY + context.lineWidth / 2,
              tilePixelSize - context.lineWidth,
              tilePixelSize - context.lineWidth
            );
            context.restore();
          }
        } else if (definition.borderColor && definition.applyBorderOnSprite) {
          context.save();
          context.strokeStyle = definition.borderColor;
          context.lineWidth = Math.max(1, Math.round(tilePixelSize * 0.08));
          context.strokeRect(
            destX + context.lineWidth / 2,
            destY + context.lineWidth / 2,
            tilePixelSize - context.lineWidth,
            tilePixelSize - context.lineWidth
          );
          context.restore();
        }

        const overlaySprites =
          cell && typeof cell === 'object'
            ? Array.isArray(cell.overlays)
              ? cell.overlays
              : cell.overlay && typeof cell.overlay === 'object'
                ? [cell.overlay]
                : []
            : [];
        overlaySprites.forEach((overlaySprite) => {
          drawInteriorSprite(overlaySprite, destX, destY, tilePixelSize);
        });
      }
    }

    if (Array.isArray(customMap.markers)) {
      customMap.markers.forEach((marker) => {
        if (!Number.isFinite(marker?.x) || !Number.isFinite(marker?.y)) {
          return;
        }
        const centerX = (marker.x + 0.5) * tilePixelSize;
        const centerY = (marker.y + 0.5) * tilePixelSize;
        const radius = Math.max(2, tilePixelSize * (Number(marker.radius) || 0.32));
        context.save();
        if (marker.shadowColor) {
          context.fillStyle = marker.shadowColor;
          context.globalAlpha = 0.35;
          context.beginPath();
          context.arc(centerX, centerY, radius * 1.45, 0, Math.PI * 2);
          context.fill();
        }
        context.globalAlpha = 1;
        context.fillStyle = marker.color || '#facc15';
        context.beginPath();
        context.arc(centerX, centerY, radius, 0, Math.PI * 2);
        context.fill();
        if (marker.stroke) {
          context.strokeStyle = marker.stroke;
          context.lineWidth = Math.max(1, tilePixelSize * 0.12);
          context.stroke();
        }
        context.restore();
      });
    }

    context.save();
    context.strokeStyle = 'rgba(15, 23, 42, 0.45)';
    context.lineWidth = 1;
    for (let x = 1; x < mapWidth; x += 1) {
      const px = Math.round(x * tilePixelSize) + 0.5;
      context.beginPath();
      context.moveTo(px, 0);
      context.lineTo(px, destHeight);
      context.stroke();
    }
    for (let y = 1; y < mapHeight; y += 1) {
      const py = Math.round(y * tilePixelSize) + 0.5;
      context.beginPath();
      context.moveTo(0, py);
      context.lineTo(destWidth, py);
      context.stroke();
    }
    context.restore();
  }
}

function openDwarfholdScreen() {
  if (elements.gameContainer) {
    elements.gameContainer.classList.add('hidden');
    elements.gameContainer.setAttribute('aria-hidden', 'true');
  }
  if (elements.localMapPanel) {
    elements.localMapPanel.classList.add('hidden');
    elements.localMapPanel.setAttribute('aria-hidden', 'true');
  }
  if (elements.dwarfholdScreen) {
    elements.dwarfholdScreen.classList.remove('hidden');
    elements.dwarfholdScreen.setAttribute('aria-hidden', 'false');
  }
  renderDwarfholdScreen();
  if (elements.dwarfholdExit) {
    const focusTarget = elements.dwarfholdExit;
    const focusElement = () => {
      if (typeof focusTarget.focus === 'function') {
        focusTarget.focus();
      }
    };
    if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
      window.requestAnimationFrame(focusElement);
    } else {
      focusElement();
    }
  }
}

function closeDwarfholdScreen(options = {}) {
  const { returnFocus = false } = options;
  if (elements.dwarfholdScreen) {
    elements.dwarfholdScreen.classList.add('hidden');
    elements.dwarfholdScreen.setAttribute('aria-hidden', 'true');
  }
  if (elements.dwarfholdCanvas) {
    elements.dwarfholdCanvas.setAttribute('aria-hidden', 'true');
  }
  if (elements.gameContainer) {
    elements.gameContainer.classList.remove('hidden');
    elements.gameContainer.setAttribute('aria-hidden', 'false');
  }
  if (returnFocus && elements.canvasWrapper) {
    elements.canvasWrapper.focus();
  }
}

function clampLocalMapZoom(value) {
  const minZoom = Number.isFinite(localViewConfig.minZoom) ? localViewConfig.minZoom : 0.5;
  const maxZoom = Number.isFinite(localViewConfig.maxZoom) ? localViewConfig.maxZoom : 3;
  if (!Number.isFinite(value)) {
    return localViewConfig.defaultZoom || 1;
  }
  return clamp(value, minZoom, maxZoom);
}

function drawLocalCustomOverlay(ctx, overlayKey, localX, localY, bounds, tileSize) {
  if (overlayKey === TOWN_ROAD_OVERLAY_KEY) {
    const worldX = bounds.startX + localX;
    const worldY = bounds.startY + localY;
    const mask = computeRoadNeighborMask(worldX, worldY, overlayKey);
    const selection = selectRoadTileSprite(mask);
    if (selection && selection.definition) {
      drawRoadSprite(
        ctx,
        selection.definition,
        localX,
        localY,
        selection.rotation || 0,
        tileSize
      );
      return true;
    }
  }
  return drawCustomOverlay(ctx, overlayKey, localX, localY, null, tileSize);
}

function drawLocalWorldPatch(ctx, options = {}) {
  const {
    world,
    bounds,
    tileWidth,
    tileHeight,
    tilePixelWidth,
    tilePixelHeight
  } = options;
  if (!ctx || !world || !bounds) {
    return;
  }
  const tiles = Array.isArray(world.tiles) ? world.tiles : null;
  if (!tiles) {
    return;
  }
  const waterTileKey = world.waterTileKey || null;
  const grassTileKey = world.grassTileKey || null;
  const tileSize = Math.min(tilePixelWidth, tilePixelHeight);

  for (let localY = 0; localY < tileHeight; localY += 1) {
    const worldY = bounds.startY + localY;
    const row = Array.isArray(tiles[worldY]) ? tiles[worldY] : null;
    if (!row) {
      continue;
    }
    for (let localX = 0; localX < tileWidth; localX += 1) {
      const worldX = bounds.startX + localX;
      const cell = row[worldX];
      if (!cell) {
        continue;
      }
      const pixelX = localX * tilePixelWidth;
      const pixelY = localY * tilePixelHeight;

      const baseDefinition = tileLookup.get(cell.base) || tileLookup.get('GRASS');
      if (!baseDefinition) {
        continue;
      }
      const baseSheet = state.tileSheets[baseDefinition.sheet];
      if (!baseSheet || !baseSheet.image) {
        continue;
      }
      ctx.drawImage(
        baseSheet.image,
        baseDefinition.sx,
        baseDefinition.sy,
        baseDefinition.size,
        baseDefinition.size,
        pixelX,
        pixelY,
        tilePixelWidth,
        tilePixelHeight
      );

      if (cell.hillOverlay && cell.hillOverlay !== cell.overlay) {
        const hillDefinition = tileLookup.get(cell.hillOverlay);
        if (hillDefinition) {
          const hillSheet = state.tileSheets[hillDefinition.sheet];
          if (hillSheet && hillSheet.image) {
            ctx.drawImage(
              hillSheet.image,
              hillDefinition.sx,
              hillDefinition.sy,
              hillDefinition.size,
              hillDefinition.size,
              pixelX,
              pixelY,
              tilePixelWidth,
              tilePixelHeight
            );
          }
        }
      }

      if (cell.overlay) {
        const overlayDefinition = tileLookup.get(cell.overlay);
        if (!overlayDefinition) {
          drawLocalCustomOverlay(ctx, cell.overlay, localX, localY, bounds, tileSize);
        } else {
          const overlaySheet = state.tileSheets[overlayDefinition.sheet];
          if (overlaySheet && overlaySheet.image) {
            ctx.drawImage(
              overlaySheet.image,
              overlayDefinition.sx,
              overlayDefinition.sy,
              overlayDefinition.size,
              overlayDefinition.size,
              pixelX,
              pixelY,
              tilePixelWidth,
              tilePixelHeight
            );
          }
        }
      }

      applyCoastalShading(ctx, cell, localX, localY, waterTileKey, grassTileKey, tileSize);
      applyDesertMountainTint(ctx, cell, localX, localY, tileSize);
      applyVolcanoShading(ctx, cell, localX, localY, tileSize);
      applyMountainShading(ctx, cell, localX, localY, tileSize);

      if (cell.river) {
        drawRiverSegment(ctx, cell.river, localX, localY, tileSize);
      }

      if (cell.structure) {
        const structureDefinition = tileLookup.get(cell.structure);
        if (structureDefinition) {
          if (typeof structureDefinition.draw === 'function') {
            structureDefinition.draw(ctx, {
              x: localX,
              y: localY,
              pixelX,
              pixelY,
              size: tileSize,
              cell,
              world
            });
          } else {
            const structureSheet = state.tileSheets[structureDefinition.sheet];
            if (structureSheet && structureSheet.image) {
              const spriteSize = structureDefinition.size || drawSize;
              const maxSpriteSize = spriteSize * (localViewConfig.structureScaleCap || 1);
              const allowedSize = Math.min(tileSize, maxSpriteSize, spriteSize);
              const scale = allowedSize / spriteSize;
              const destWidth = spriteSize * scale;
              const destHeight = spriteSize * scale;
              const offsetX = pixelX + (tilePixelWidth - destWidth) / 2;
              const offsetY = pixelY + (tilePixelHeight - destHeight) / 2;
              ctx.drawImage(
                structureSheet.image,
                structureDefinition.sx,
                structureDefinition.sy,
                structureDefinition.size,
                structureDefinition.size,
                offsetX,
                offsetY,
                destWidth,
                destHeight
              );
            }
          }
        }
      }
    }
  }
}

function refreshLocalMapPreview() {
  if (!elements.localMapPanel || !elements.localMapCanvas) {
    return;
  }
  const world = state.currentWorld;
  const localView = state.localView;
  const worldHasTiles = Array.isArray(world?.tiles) && world.tiles.length > 0;

  if (state.dwarfholdView && state.dwarfholdView.active) {
    elements.localMapPanel.classList.add('hidden');
    elements.localMapPanel.setAttribute('aria-hidden', 'true');
    elements.localMapCanvas.setAttribute('aria-hidden', 'true');
    renderDwarfholdScreen();
    return;
  }

  if (
    !localView ||
    !localView.active ||
    localView.centerX === null ||
    localView.centerY === null ||
    !localView.bounds
  ) {
    elements.localMapPanel.classList.add('hidden');
    elements.localMapPanel.setAttribute('aria-hidden', 'true');
    if (elements.localMapCanvas) {
      elements.localMapCanvas.setAttribute('aria-hidden', 'true');
    }
    if (elements.localMapTitle) {
      elements.localMapTitle.textContent = 'Local View';
    }
    if (elements.localMapSubtitle) {
      elements.localMapSubtitle.textContent = 'Select a site to examine the surrounding terrain.';
    }
    if (elements.localMapDetails) {
      elements.localMapDetails.textContent = localMapDefaultMessage;
    }
    if (elements.localMapCoordinates) {
      elements.localMapCoordinates.textContent = '';
    }
    return;
  }

  const focusTile =
    worldHasTiles && Array.isArray(world.tiles[localView.centerY])
      ? world.tiles[localView.centerY][localView.centerX] || null
      : null;

  const zoomSource = (localView.zoom ?? localViewConfig.defaultZoom) || 1;
  const zoom = clampLocalMapZoom(zoomSource);
  if (localView.zoom !== zoom) {
    localView.zoom = zoom;
  }

  if (localView.mode === 'worldHighRes' && localView.highResolution) {
    const patch = localView.highResolution;
    const canvas = elements.localMapCanvas;
    const context = canvas ? canvas.getContext('2d') : null;
    if (!canvas || !context) {
      return;
    }

    elements.localMapPanel.classList.remove('hidden');
    elements.localMapPanel.setAttribute('aria-hidden', 'false');

    if (elements.localMapTitle) {
      elements.localMapTitle.textContent = focusTile
        ? focusTile.structureName || focusTile.areaName || 'Local View'
        : 'Local View';
    }

    if (elements.localMapSubtitle) {
      elements.localMapSubtitle.textContent = 'High-resolution terrain sample';
    }

    if (elements.localMapCoordinates) {
      const sourceLabel = `${patch.worldWidth}×${patch.worldHeight}`;
      elements.localMapCoordinates.textContent = `World Tile ${localView.centerX + 1}, ${localView.centerY + 1} — ${
        patch.width
      }×${patch.height} tiles (sampled from ${sourceLabel})`;
    }

    if (elements.localMapDetails) {
      const tooltipContent = buildStructureTooltipContent(focusTile);
      if (tooltipContent) {
        elements.localMapDetails.innerHTML = tooltipContent;
      } else {
        elements.localMapDetails.textContent = localMapDefaultMessage;
      }
    }

    const maxSize = localViewConfig.maxCanvasSize;
    const maxTileSize = Number.isFinite(localViewConfig.highResolutionMaxTileSize)
      ? Math.max(4, Math.floor(localViewConfig.highResolutionMaxTileSize))
      : 24;
    let tilePixelSize = maxTileSize;
    const minTileSize = Number.isFinite(localViewConfig.highResolutionMinScale)
      ? Math.max(2, Math.floor(localViewConfig.highResolutionMinScale))
      : 2;
    while (
      (patch.width * tilePixelSize > maxSize || patch.height * tilePixelSize > maxSize) &&
      tilePixelSize > minTileSize
    ) {
      tilePixelSize -= 1;
    }
    if (patch.width * tilePixelSize > maxSize || patch.height * tilePixelSize > maxSize) {
      const fallbackSize = Math.floor(maxSize / Math.max(patch.width, patch.height));
      tilePixelSize = Math.max(minTileSize, fallbackSize);
    }
    tilePixelSize = Math.max(minTileSize, tilePixelSize);

    const absoluteMinTileSize = Math.max(2, Math.floor(minTileSize * 0.5));
    const minZoomedSize = Math.max(absoluteMinTileSize, Math.floor(minTileSize * Math.min(zoom, 1)));
    let zoomedTileSize = tilePixelSize * zoom;
    zoomedTileSize = Math.max(minZoomedSize, zoomedTileSize);
    const maxAllowedTileSize = Math.min(
      maxSize / Math.max(1, patch.width),
      maxSize / Math.max(1, patch.height)
    );
    if (Number.isFinite(maxAllowedTileSize) && maxAllowedTileSize > 0 && zoomedTileSize > maxAllowedTileSize) {
      zoomedTileSize = Math.max(minZoomedSize, maxAllowedTileSize);
    }
    tilePixelSize = Math.max(absoluteMinTileSize, zoomedTileSize);

    const destWidth = Math.max(1, patch.width * tilePixelSize);
    const destHeight = Math.max(1, patch.height * tilePixelSize);
    canvas.width = destWidth;
    canvas.height = destHeight;
    canvas.style.width = '100%';
    canvas.style.height = 'auto';
    canvas.setAttribute(
      'aria-label',
      `High-resolution local preview covering ${patch.width} by ${patch.height} tiles around world tile ${
        localView.centerX + 1
      }, ${localView.centerY + 1}.`
    );
    canvas.setAttribute('aria-hidden', 'false');

    context.imageSmoothingEnabled = false;
    context.clearRect(0, 0, destWidth, destHeight);
    context.fillStyle = '#05060b';
    context.fillRect(0, 0, destWidth, destHeight);

    drawHighResolutionLocalPatch(context, patch, tilePixelSize, {
      highlightX: patch.centerX,
      highlightY: patch.centerY
    });

    return;
  }

  if (localView.mode === 'dwarfhold' && localView.customMap) {
    const customMap = localView.customMap;
    const tiles = Array.isArray(customMap?.tiles) ? customMap.tiles : null;
    const mapHeight = tiles ? tiles.length : 0;
    const mapWidth = mapHeight > 0 && Array.isArray(tiles[0]) ? tiles[0].length : 0;
    const canvas = elements.localMapCanvas;
    const context = canvas ? canvas.getContext('2d') : null;
    if (!tiles || mapWidth === 0 || mapHeight === 0 || !canvas || !context) {
      return;
    }

    elements.localMapPanel.classList.remove('hidden');
    elements.localMapPanel.setAttribute('aria-hidden', 'false');

    if (elements.localMapTitle) {
      elements.localMapTitle.textContent =
        customMap.title || focusTile?.structureName || focusTile?.areaName || 'Dwarven Hold Interior';
    }

    if (elements.localMapSubtitle) {
      const subtitle =
        customMap.subtitle ||
        (focusTile?.structureDetails?.displayType
          ? `${focusTile.structureDetails.displayType} interior`
          : 'Subterranean quarters of the hold');
      elements.localMapSubtitle.textContent = subtitle;
    }

    if (elements.localMapCoordinates) {
      elements.localMapCoordinates.textContent = `World Tile ${localView.centerX + 1}, ${localView.centerY + 1} — ${
        mapWidth
      }×${mapHeight} tiles`;
    }

    if (elements.localMapDetails) {
      const sections = [];
      if (customMap.description) {
        sections.push(`<p class="tooltip-note">${escapeHtml(customMap.description)}</p>`);
      }
      if (Array.isArray(customMap.features) && customMap.features.length > 0) {
        const list = customMap.features
          .map((feature) => `<li>${escapeHtml(feature)}</li>`)
          .join('');
        sections.push(`<ul class="tooltip-list">${list}</ul>`);
      }
      if (customMap.legend && typeof customMap.legend === 'object') {
        const legendEntries = Object.entries(customMap.legend)
          .filter(([type, definition]) => type !== 'rock' && definition && definition.label)
          .map(([type, definition]) => {
            const description = definition.description || definition.examples || type;
            return `<li><span class="tooltip-term">${escapeHtml(definition.label)}</span><span class="tooltip-value">${escapeHtml(description)}</span></li>`;
          });
        if (legendEntries.length > 0) {
          sections.push(`<ul class="tooltip-list">${legendEntries.join('')}</ul>`);
        }
      }
      if (sections.length > 0) {
        elements.localMapDetails.innerHTML = sections.join('');
      } else {
        elements.localMapDetails.textContent = localMapDefaultMessage;
      }
    }

    const maxSize = localViewConfig.maxCanvasSize;
    let tilePixelSize = 24;
    while ((mapWidth * tilePixelSize > maxSize || mapHeight * tilePixelSize > maxSize) && tilePixelSize > 8) {
      tilePixelSize -= 2;
    }
    if (mapWidth * tilePixelSize > maxSize || mapHeight * tilePixelSize > maxSize) {
      const fallbackSize = Math.floor(maxSize / Math.max(mapWidth, mapHeight));
      if (Number.isFinite(fallbackSize) && fallbackSize > 0) {
        tilePixelSize = Math.max(6, Math.min(tilePixelSize, fallbackSize));
      }
    }
    if (!Number.isFinite(tilePixelSize) || tilePixelSize < 6) {
      tilePixelSize = 6;
    }

    const absoluteMinTileSize = Math.max(4, Math.floor(6 * 0.5));
    const minZoomedSize = Math.max(absoluteMinTileSize, Math.floor(6 * Math.min(zoom, 1)));
    let zoomedTileSize = tilePixelSize * zoom;
    zoomedTileSize = Math.max(minZoomedSize, zoomedTileSize);
    const maxAllowedTileSize = Math.min(maxSize / Math.max(1, mapWidth), maxSize / Math.max(1, mapHeight));
    if (Number.isFinite(maxAllowedTileSize) && maxAllowedTileSize > 0 && zoomedTileSize > maxAllowedTileSize) {
      zoomedTileSize = Math.max(minZoomedSize, maxAllowedTileSize);
    }
    tilePixelSize = Math.max(absoluteMinTileSize, zoomedTileSize);

    const destWidth = Math.max(1, mapWidth * tilePixelSize);
    const destHeight = Math.max(1, mapHeight * tilePixelSize);
    canvas.width = destWidth;
    canvas.height = destHeight;
    canvas.style.width = '100%';
    canvas.style.height = 'auto';
    canvas.setAttribute(
      'aria-label',
      `Procedural dwarfhold interior covering ${mapWidth} by ${mapHeight} tiles at world tile ${
        localView.centerX + 1
      }, ${localView.centerY + 1}.`
    );
    canvas.setAttribute('aria-hidden', 'false');

    context.imageSmoothingEnabled = false;
    context.clearRect(0, 0, destWidth, destHeight);
    context.fillStyle = '#05060b';
    context.fillRect(0, 0, destWidth, destHeight);

    const palette = customMap.legend || {};
    for (let y = 0; y < mapHeight; y += 1) {
      const row = Array.isArray(tiles[y]) ? tiles[y] : null;
      if (!row) {
        continue;
      }
      for (let x = 0; x < mapWidth; x += 1) {
        const cell = row[x];
        const type = typeof cell === 'string' ? cell : typeof cell?.type === 'string' ? cell.type : 'rock';
        const definition = palette[type] || palette.rock || { color: '#1f2937' };
        context.fillStyle = definition.color || '#1f2937';
        context.fillRect(x * tilePixelSize, y * tilePixelSize, tilePixelSize, tilePixelSize);

        if (definition.texture === 'speckled') {
          context.save();
          context.fillStyle = definition.accent || 'rgba(255, 255, 255, 0.08)';
          const dot = Math.max(1, Math.round(tilePixelSize * 0.18));
          for (let offsetY = dot; offsetY < tilePixelSize; offsetY += dot * 2) {
            for (let offsetX = dot; offsetX < tilePixelSize; offsetX += dot * 2) {
              context.fillRect(x * tilePixelSize + offsetX - dot / 2, y * tilePixelSize + offsetY - dot / 2, dot, dot);
            }
          }
          context.restore();
        }

        if (definition.borderColor) {
          context.save();
          context.strokeStyle = definition.borderColor;
          context.lineWidth = Math.max(1, Math.round(tilePixelSize * 0.08));
          context.strokeRect(
            x * tilePixelSize + context.lineWidth / 2,
            y * tilePixelSize + context.lineWidth / 2,
            tilePixelSize - context.lineWidth,
            tilePixelSize - context.lineWidth
          );
          context.restore();
        }
      }
    }

    if (Array.isArray(customMap.markers)) {
      customMap.markers.forEach((marker) => {
        if (!Number.isFinite(marker?.x) || !Number.isFinite(marker?.y)) {
          return;
        }
        const centerX = (marker.x + 0.5) * tilePixelSize;
        const centerY = (marker.y + 0.5) * tilePixelSize;
        const radius = Math.max(2, tilePixelSize * (Number(marker.radius) || 0.32));
        context.save();
        if (marker.shadowColor) {
          context.fillStyle = marker.shadowColor;
          context.globalAlpha = 0.35;
          context.beginPath();
          context.arc(centerX, centerY, radius * 1.45, 0, Math.PI * 2);
          context.fill();
        }
        context.globalAlpha = 1;
        context.fillStyle = marker.color || '#facc15';
        context.beginPath();
        context.arc(centerX, centerY, radius, 0, Math.PI * 2);
        context.fill();
        if (marker.stroke) {
          context.strokeStyle = marker.stroke;
          context.lineWidth = Math.max(1, tilePixelSize * 0.12);
          context.stroke();
        }
        context.restore();
      });
    }

    context.save();
    context.strokeStyle = 'rgba(15, 23, 42, 0.45)';
    context.lineWidth = 1;
    for (let x = 1; x < mapWidth; x += 1) {
      const px = Math.round(x * tilePixelSize) + 0.5;
      context.beginPath();
      context.moveTo(px, 0);
      context.lineTo(px, destHeight);
      context.stroke();
    }
    for (let y = 1; y < mapHeight; y += 1) {
      const py = Math.round(y * tilePixelSize) + 0.5;
      context.beginPath();
      context.moveTo(0, py);
      context.lineTo(destWidth, py);
      context.stroke();
    }
    context.restore();

    return;
  }

  if (!worldHasTiles) {
    return;
  }

  const tiles = world.tiles;
  const bounds = localView.bounds;
  const tileWidth = Math.max(1, bounds.width);
  const tileHeight = Math.max(1, bounds.height);

  elements.localMapPanel.classList.remove('hidden');
  elements.localMapPanel.setAttribute('aria-hidden', 'false');

  if (elements.localMapTitle) {
    elements.localMapTitle.textContent = focusTile
      ? focusTile.structureName || focusTile.areaName || 'Local View'
      : 'Local View';
  }

  if (elements.localMapSubtitle) {
    elements.localMapSubtitle.textContent = resolveLocalSubtitle(focusTile);
  }

  if (elements.localMapCoordinates) {
    elements.localMapCoordinates.textContent = `World Tile ${localView.centerX + 1}, ${localView.centerY + 1} — ${
      tileWidth
    }×${tileHeight} tiles`;
  }

  if (elements.localMapDetails) {
    const tooltipContent = buildStructureTooltipContent(focusTile);
    if (tooltipContent) {
      elements.localMapDetails.innerHTML = tooltipContent;
    } else {
      elements.localMapDetails.textContent = localMapDefaultMessage;
    }
  }

  const canvas = elements.localMapCanvas;
  const context = canvas ? canvas.getContext('2d') : null;
  if (!canvas || !context) {
    return;
  }

  const sourceWidth = tileWidth * drawSize;
  const sourceHeight = tileHeight * drawSize;
  const maxSize = localViewConfig.maxCanvasSize;
  const absoluteMinScale = Number.isFinite(localViewConfig.absoluteMinScale)
    ? Math.max(0.1, localViewConfig.absoluteMinScale)
    : 0.5;
  const desiredScale = localViewConfig.baseScale * zoom;
  let scale = Number.isFinite(desiredScale) && desiredScale > 0 ? desiredScale : localViewConfig.baseScale;
  const minScale = Math.max(
    absoluteMinScale,
    Number.isFinite(localViewConfig.minScale) ? localViewConfig.minScale * Math.min(zoom, 1) : absoluteMinScale
  );
  const maxScaleByWidth = maxSize / Math.max(1, sourceWidth);
  const maxScaleByHeight = maxSize / Math.max(1, sourceHeight);
  const maxAllowedScale = Math.min(maxScaleByWidth, maxScaleByHeight);
  if (Number.isFinite(maxAllowedScale) && maxAllowedScale > 0) {
    scale = Math.min(scale, maxAllowedScale);
    if (maxAllowedScale < minScale) {
      scale = Math.max(absoluteMinScale, maxAllowedScale);
    } else if (scale < minScale) {
      scale = minScale;
    }
  } else if (scale < minScale) {
    scale = minScale;
  }
  if (!Number.isFinite(scale) || scale <= 0) {
    scale = absoluteMinScale;
  }

  const destWidth = Math.max(1, Math.round(sourceWidth * scale));
  const destHeight = Math.max(1, Math.round(sourceHeight * scale));
  canvas.width = destWidth;
  canvas.height = destHeight;
  canvas.style.width = '100%';
  canvas.style.height = 'auto';
  canvas.setAttribute(
    'aria-label',
    `Local preview covering ${tileWidth} by ${tileHeight} tiles around world tile ${localView.centerX + 1}, ${
      localView.centerY + 1
    } at approximately ${zoom.toFixed(2)}× zoom.`
  );
  canvas.setAttribute('aria-hidden', 'false');

  context.imageSmoothingEnabled = false;
  context.clearRect(0, 0, destWidth, destHeight);
  context.fillStyle = '#05060b';
  context.fillRect(0, 0, destWidth, destHeight);

  const tilePixelWidth = destWidth / tileWidth;
  const tilePixelHeight = destHeight / tileHeight;

  drawLocalWorldPatch(context, {
    world,
    bounds,
    tileWidth,
    tileHeight,
    tilePixelWidth,
    tilePixelHeight
  });

  context.save();
  context.strokeStyle = 'rgba(12, 14, 22, 0.6)';
  context.lineWidth = 1;
  for (let x = 1; x < tileWidth; x += 1) {
    const px = Math.round(x * tilePixelWidth) + 0.5;
    context.beginPath();
    context.moveTo(px, 0);
    context.lineTo(px, destHeight);
    context.stroke();
  }
  for (let y = 1; y < tileHeight; y += 1) {
    const py = Math.round(y * tilePixelHeight) + 0.5;
    context.beginPath();
    context.moveTo(0, py);
    context.lineTo(destWidth, py);
    context.stroke();
  }
  context.restore();

  const highlightX = (localView.centerX - bounds.startX) * tilePixelWidth;
  const highlightY = (localView.centerY - bounds.startY) * tilePixelHeight;
  context.save();
  const minTileSize = Math.max(1, Math.min(tilePixelWidth, tilePixelHeight));
  const lineWidth = Math.max(2, Math.round(minTileSize * 0.12));
  context.lineWidth = lineWidth;
  context.strokeStyle = 'rgba(240, 198, 116, 0.9)';
  context.fillStyle = 'rgba(240, 198, 116, 0.12)';
  context.fillRect(highlightX, highlightY, tilePixelWidth, tilePixelHeight);
  context.strokeRect(
    highlightX + lineWidth / 2,
    highlightY + lineWidth / 2,
    tilePixelWidth - lineWidth,
    tilePixelHeight - lineWidth
  );
  context.restore();
}

function setLocalMapZoom(value, options = {}) {
  const { suppressRedraw = false } = options;
  const clampedZoom = clampLocalMapZoom(value);
  if (!state.localView) {
    return clampedZoom;
  }
  if (state.localView.zoom === clampedZoom) {
    return clampedZoom;
  }
  state.localView.zoom = clampedZoom;
  if (!suppressRedraw) {
    refreshLocalMapPreview();
  }
  return clampedZoom;
}

function adjustLocalMapZoom(direction) {
  if (!state.localView) {
    return;
  }
  const step = Number.isFinite(localViewConfig.zoomStep) ? localViewConfig.zoomStep : 0.2;
  const currentZoomSource = (state.localView.zoom ?? localViewConfig.defaultZoom) || 1;
  const current = clampLocalMapZoom(currentZoomSource);
  let next = current;
  if (direction === 'in') {
    next = current + step;
  } else if (direction === 'out') {
    next = current - step;
  } else if (typeof direction === 'number' && Number.isFinite(direction)) {
    next = current + direction;
  }
  setLocalMapZoom(next);
}

function resetLocalMapZoom() {
  setLocalMapZoom(localViewConfig.defaultZoom || 1);
}

function hideLocalView(options = {}) {
  const { suppressRedraw = false, returnFocus = false } = options;
  state.localView.active = false;
  state.localView.centerX = null;
  state.localView.centerY = null;
  state.localView.bounds = null;
  state.localView.mode = 'world';
  state.localView.customMap = null;
  state.localView.structure = null;
  state.localView.highResolution = null;
  state.localView.zoom = localViewConfig.defaultZoom || 1;
  state.dwarfholdView.active = false;
  state.dwarfholdView.map = null;
  state.dwarfholdView.tileX = null;
  state.dwarfholdView.tileY = null;
  state.dwarfholdView.structure = null;
  if (elements.localMapPanel) {
    elements.localMapPanel.classList.add('hidden');
    elements.localMapPanel.setAttribute('aria-hidden', 'true');
  }
  if (elements.localMapCanvas) {
    elements.localMapCanvas.setAttribute('aria-hidden', 'true');
    elements.localMapCanvas.setAttribute('aria-label', 'Local map preview');
  }
  if (elements.localMapTitle) {
    elements.localMapTitle.textContent = 'Local View';
  }
  if (elements.localMapSubtitle) {
    elements.localMapSubtitle.textContent = 'Select a site to examine the surrounding terrain.';
  }
  if (elements.localMapDetails) {
    elements.localMapDetails.textContent = localMapDefaultMessage;
  }
  if (elements.localMapCoordinates) {
    elements.localMapCoordinates.textContent = '';
  }
  renderDwarfholdScreen();
  closeDwarfholdScreen({ returnFocus });
  if (!suppressRedraw && state.currentWorld) {
    drawWorld(state.currentWorld, { preserveView: true });
  }
}

function cloneTileForHighResolution(tile) {
  if (!tile || typeof tile !== 'object') {
    return tile || null;
  }

  const clone = { ...tile };
  if (tile.river && typeof tile.river === 'object') {
    clone.river = { ...tile.river };
  }
  if (tile.road && typeof tile.road === 'object') {
    clone.road = { ...tile.road };
  }
  if (tile.structureDetails && typeof tile.structureDetails === 'object') {
    clone.structureDetails = { ...tile.structureDetails };
  }
  if (tile.ambientStructure && typeof tile.ambientStructure === 'object') {
    clone.ambientStructure = { ...tile.ambientStructure };
  } else {
    clone.ambientStructure = null;
  }
  if (Array.isArray(tile.features)) {
    clone.features = tile.features.slice();
  }
  return clone;
}

function hashString32(value) {
  if (typeof value !== 'string') {
    value = JSON.stringify(value);
  }
  let hash = 0x811c9dc5;
  for (let i = 0; i < value.length; i += 1) {
    hash ^= value.charCodeAt(i);
    hash = Math.imul(hash, 0x01000193);
    hash >>>= 0;
  }
  return hash >>> 0;
}

function createDeterministicNoiseSampler(seedValue) {
  const baseSeed = hashString32(seedValue || 'local');
  return (x, y, channel = 0) => {
    let state = baseSeed;
    state ^= Math.imul(0x45d9f3b, x + 0x9e3779b9);
    state ^= Math.imul(0x632be5ab, y + 0x9e3779b9);
    state ^= Math.imul(0x27d4eb2d, channel + 0x9e3779b9);
    state = Math.imul(state ^ (state >>> 15), 1 | state);
    state ^= state + Math.imul(state ^ (state >>> 7), 61 | state);
    state ^= state >>> 14;
    return (state >>> 0) / 4294967296;
  };
}

function getWorldTileAt(tiles, width, height, x, y) {
  if (!Array.isArray(tiles) || width <= 0 || height <= 0) {
    return null;
  }
  if (x < 0 || y < 0 || x >= width || y >= height) {
    return null;
  }
  const row = tiles[y];
  if (!Array.isArray(row) || x >= row.length) {
    return null;
  }
  return row[x] || null;
}

function buildNeighborDetails(tiles, width, height, x, y, waterTileKey) {
  const result = {};
  const offsets = [
    { key: 'north', dx: 0, dy: -1 },
    { key: 'south', dx: 0, dy: 1 },
    { key: 'west', dx: -1, dy: 0 },
    { key: 'east', dx: 1, dy: 0 },
    { key: 'northWest', dx: -1, dy: -1 },
    { key: 'northEast', dx: 1, dy: -1 },
    { key: 'southWest', dx: -1, dy: 1 },
    { key: 'southEast', dx: 1, dy: 1 }
  ];

  for (let i = 0; i < offsets.length; i += 1) {
    const { key, dx, dy } = offsets[i];
    const tile = getWorldTileAt(tiles, width, height, x + dx, y + dy);
    if (!tile) {
      result[key] = null;
      continue;
    }
    const overlayKey = typeof tile.overlay === 'string' ? tile.overlay : null;
    const hillOverlayKey = typeof tile.hillOverlay === 'string' ? tile.hillOverlay : null;
    const baseKey = typeof tile.base === 'string' ? tile.base : null;
    const overlayIsMountain = overlayKey ? isMountainOverlayKey(overlayKey) : false;
    const hillIsMountain = hillOverlayKey ? isMountainOverlayKey(hillOverlayKey) : false;
    result[key] = {
      overlayKey,
      hillOverlayKey,
      hasForestOverlay: overlayKey ? isTreeOverlayKey(overlayKey) : false,
      hasHillOverlay: hillOverlayKey ? hillOverlayKeySet.has(hillOverlayKey) : false,
      hasMountainOverlay: overlayIsMountain || hillIsMountain,
      mountainOverlayKey: overlayIsMountain ? overlayKey : hillIsMountain ? hillOverlayKey : null,
      baseKey,
      isWater: Boolean(waterTileKey) && baseKey === waterTileKey
    };
  }

  return result;
}

function computeRiverSubtileVariation(river, subdivisions, worldX, worldY, sampleNoise) {
  if (!river || subdivisions <= 1) {
    return null;
  }
  const mask = Number.isFinite(river.mask) ? river.mask : 0;
  if (mask === 0) {
    return null;
  }
  const baseWidth = subdivisions > 3 ? 2 : 1;
  const centerBase = subdivisions / 2;

  const computeRange = (channel) => {
    const offsetNoise = sampleNoise(worldX, worldY, channel);
    const offset = Math.round((offsetNoise - 0.5) * Math.min(1, Math.floor(subdivisions / 3)));
    const start = clamp(
      Math.round(centerBase - baseWidth / 2) + offset,
      0,
      Math.max(0, subdivisions - baseWidth)
    );
    return { start, end: Math.min(subdivisions - 1, start + baseWidth - 1) };
  };

  return {
    mask,
    vertical: computeRange(21),
    horizontal: computeRange(22)
  };
}

function applyRiverSubtileVariation(subTile, variation, subX, subY) {
  if (!subTile || !variation || !subTile.river) {
    return;
  }
  const { NORTH, SOUTH, EAST, WEST } = ROAD_DIRECTION_BITS;
  const mask = variation.mask;
  let keep = false;

  if (mask & (NORTH | SOUTH)) {
    const vertical = variation.vertical;
    if (vertical && subX >= vertical.start && subX <= vertical.end) {
      keep = true;
    }
  }

  if (mask & (EAST | WEST)) {
    const horizontal = variation.horizontal;
    if (horizontal && subY >= horizontal.start && subY <= horizontal.end) {
      keep = true;
    }
  }

  if (!keep) {
    subTile.river = null;
  }
}

function applySurfaceNoiseVariation(subTile, noiseAt, baseKeys = {}) {
  if (!subTile || typeof subTile.base !== 'string') {
    if (subTile && Object.prototype.hasOwnProperty.call(subTile, 'surfaceVariation')) {
      delete subTile.surfaceVariation;
    }
    return;
  }

  const { snowTileKey = null, sandTileKey = null, badlandsTileKey = null } = baseKeys;
  const baseKey = subTile.base;
  let channel = null;
  let strength = 0;

  if (snowTileKey && baseKey === snowTileKey) {
    channel = 180;
    strength = 0.75;
  } else if (sandTileKey && baseKey === sandTileKey) {
    channel = 182;
    strength = 0.85;
  } else if (badlandsTileKey && baseKey === badlandsTileKey) {
    channel = 184;
    strength = 0.8;
  }

  if (channel === null) {
    if (Object.prototype.hasOwnProperty.call(subTile, 'surfaceVariation')) {
      delete subTile.surfaceVariation;
    }
    return;
  }

  const baseNoise = noiseAt(channel) * 2 - 1;
  const detailNoise = noiseAt(channel + 1) * 2 - 1;
  const variation = clamp((baseNoise * 0.65 + detailNoise * 0.35) * strength, -1, 1);
  subTile.surfaceVariation = variation;
}

function applyHillOverlayVariation(subTile, baseTile, neighbors, subdivisions, subX, subY, noiseAt) {
  if (!subTile || !baseTile) {
    return;
  }
  const hillOverlayKey = typeof baseTile.hillOverlay === 'string' ? baseTile.hillOverlay : null;
  if (!hillOverlayKey || !hillOverlayKeySet.has(hillOverlayKey)) {
    return;
  }

  const normalizedX = (subX + 0.5) / subdivisions;
  const normalizedY = (subY + 0.5) / subdivisions;
  const edgeThreshold = 0.32;
  let keepHill = true;

  if (normalizedY < edgeThreshold && !(neighbors.north && neighbors.north.hasHillOverlay)) {
    keepHill = keepHill && noiseAt(40) > 0.25 + normalizedY * 0.6;
  }
  if (normalizedY > 1 - edgeThreshold && !(neighbors.south && neighbors.south.hasHillOverlay)) {
    keepHill = keepHill && noiseAt(41) > 0.25 + (1 - normalizedY) * 0.6;
  }
  if (normalizedX < edgeThreshold && !(neighbors.west && neighbors.west.hasHillOverlay)) {
    keepHill = keepHill && noiseAt(42) > 0.25 + normalizedX * 0.6;
  }
  if (normalizedX > 1 - edgeThreshold && !(neighbors.east && neighbors.east.hasHillOverlay)) {
    keepHill = keepHill && noiseAt(43) > 0.25 + (1 - normalizedX) * 0.6;
  }

  const interiorNoise = noiseAt(44);
  if (keepHill && interiorNoise < 0.1) {
    keepHill = false;
  }

  subTile.hillOverlay = keepHill ? hillOverlayKey : null;
}

function applyMountainVariation(subTile, baseTile, neighbors, subdivisions, subX, subY, noiseAt) {
  if (!subTile || !baseTile) {
    return;
  }

  const overlayKey = typeof baseTile.overlay === 'string' ? baseTile.overlay : null;
  const hillOverlayKey = typeof baseTile.hillOverlay === 'string' ? baseTile.hillOverlay : null;
  const overlayIsMountain = overlayKey ? isMountainOverlayKey(overlayKey) : false;
  const hillIsMountain = hillOverlayKey ? isMountainOverlayKey(hillOverlayKey) : false;
  const hasMountain = overlayIsMountain || hillIsMountain;

  const updateRuggedness = (value) => {
    const existing = Number.isFinite(subTile.mountainRuggedness)
      ? subTile.mountainRuggedness
      : 0;
    const clamped = clamp(value, 0, 1);
    subTile.mountainRuggedness = clamp(existing * 0.4 + clamped * 0.6, 0, 1);
  };

  if (!hasMountain) {
    if (Number.isFinite(subTile.mountainRuggedness)) {
      subTile.mountainRuggedness = clamp(subTile.mountainRuggedness * 0.35, 0, 1);
    } else {
      subTile.mountainRuggedness = 0;
    }
    return;
  }

  const mountainOverlayKey = overlayIsMountain ? overlayKey : hillOverlayKey;
  const useHillSlot = !overlayIsMountain && hillIsMountain;

  if (!mountainOverlayKey) {
    return;
  }

  if (isVolcanoOverlayKey(mountainOverlayKey) || mountainOverlayKey.includes('PEAK')) {
    if (useHillSlot) {
      subTile.hillOverlay = mountainOverlayKey;
    } else {
      subTile.overlay = mountainOverlayKey;
    }
    updateRuggedness(0.7 + (noiseAt(111) - 0.5) * 0.3);
    return;
  }

  const normalizedX = (subX + 0.5) / subdivisions;
  const normalizedY = (subY + 0.5) / subdivisions;
  const edgeThreshold = 0.32;

  const hasNeighborMountain = (key) => Boolean(neighbors[key] && neighbors[key].hasMountainOverlay);

  let keep = true;

  if (normalizedY < edgeThreshold && !hasNeighborMountain('north')) {
    keep = keep && noiseAt(100) > 0.24 + normalizedY * 0.7;
  }
  if (keep && normalizedY > 1 - edgeThreshold && !hasNeighborMountain('south')) {
    keep = noiseAt(101) > 0.24 + (1 - normalizedY) * 0.7;
  }
  if (keep && normalizedX < edgeThreshold && !hasNeighborMountain('west')) {
    keep = noiseAt(102) > 0.24 + normalizedX * 0.7;
  }
  if (keep && normalizedX > 1 - edgeThreshold && !hasNeighborMountain('east')) {
    keep = noiseAt(103) > 0.24 + (1 - normalizedX) * 0.7;
  }

  if (
    keep &&
    normalizedX < edgeThreshold &&
    normalizedY < edgeThreshold &&
    !hasNeighborMountain('northWest')
  ) {
    keep = noiseAt(104) > 0.2 + (normalizedX + normalizedY) * 0.42;
  }
  if (
    keep &&
    normalizedX > 1 - edgeThreshold &&
    normalizedY < edgeThreshold &&
    !hasNeighborMountain('northEast')
  ) {
    keep = noiseAt(105) > 0.2 + (1 - normalizedX + normalizedY) * 0.42;
  }
  if (
    keep &&
    normalizedX < edgeThreshold &&
    normalizedY > 1 - edgeThreshold &&
    !hasNeighborMountain('southWest')
  ) {
    keep = noiseAt(106) > 0.2 + (normalizedX + (1 - normalizedY)) * 0.42;
  }
  if (
    keep &&
    normalizedX > 1 - edgeThreshold &&
    normalizedY > 1 - edgeThreshold &&
    !hasNeighborMountain('southEast')
  ) {
    keep = noiseAt(107) > 0.2 + (2 - normalizedX - normalizedY) * 0.42;
  }

  if (keep) {
    const edgeDistance = Math.min(
      Math.min(normalizedX, 1 - normalizedX),
      Math.min(normalizedY, 1 - normalizedY)
    );
    const erosionThreshold = 0.08 + (0.4 - edgeDistance) * 0.22;
    if (noiseAt(108) < erosionThreshold) {
      keep = false;
    }
  }

  if (!keep) {
    if (useHillSlot) {
      subTile.hillOverlay = null;
    } else {
      subTile.overlay = null;
    }
    if (Number.isFinite(subTile.mountainRuggedness)) {
      subTile.mountainRuggedness = clamp(subTile.mountainRuggedness * 0.5, 0, 1);
    } else {
      subTile.mountainRuggedness = 0;
    }
    return;
  }

  if (useHillSlot) {
    subTile.hillOverlay = mountainOverlayKey;
  } else {
    subTile.overlay = mountainOverlayKey;
  }

  const ruggednessBase = 0.38 + noiseAt(109) * 0.45;
  const detailVariance = (noiseAt(110) - 0.5) * 0.2;
  updateRuggedness(ruggednessBase + detailVariance);
}

function applySnowVariation(
  subTile,
  baseTile,
  neighbors,
  subdivisions,
  subX,
  subY,
  noiseAt,
  { snowTileKey, waterTileKey = null, defaultLandKey = null } = {}
) {
  if (!subTile || !baseTile || !snowTileKey || subdivisions <= 1) {
    return;
  }

  const baseKey = typeof baseTile.base === 'string' ? baseTile.base : null;
  const subTileBase = typeof subTile.base === 'string' ? subTile.base : null;
  const normalizedX = (subX + 0.5) / subdivisions;
  const normalizedY = (subY + 0.5) / subdivisions;
  const edgeThreshold = 0.32;

  const isValidReplacementBase = (base) =>
    typeof base === 'string' &&
    base.length > 0 &&
    base !== snowTileKey &&
    (!waterTileKey || base !== waterTileKey);

  const neighborOrder = [
    'north',
    'south',
    'west',
    'east',
    'northWest',
    'northEast',
    'southWest',
    'southEast'
  ];

  const hasNonSnowNeighbor = neighborOrder.some((key) => {
    const neighbor = neighbors[key];
    return neighbor && isValidReplacementBase(neighbor.baseKey);
  });

  const hasSnowNeighbor = neighborOrder.some((key) => {
    const neighbor = neighbors[key];
    return neighbor && neighbor.baseKey === snowTileKey;
  });

  const removeSurfaceVariation = () => {
    if (Object.prototype.hasOwnProperty.call(subTile, 'surfaceVariation')) {
      delete subTile.surfaceVariation;
    }
  };

  const selectNeighborBase = () => {
    for (let i = 0; i < neighborOrder.length; i += 1) {
      const neighbor = neighbors[neighborOrder[i]];
      if (neighbor && isValidReplacementBase(neighbor.baseKey)) {
        return neighbor.baseKey;
      }
    }
    if (isValidReplacementBase(defaultLandKey)) {
      return defaultLandKey;
    }
    return null;
  };

  if (baseKey === snowTileKey) {
    if (!hasNonSnowNeighbor) {
      return;
    }

    const candidateScores = new Map();
    const addCandidate = (base, score) => {
      if (!isValidReplacementBase(base)) {
        return;
      }
      const existing = candidateScores.get(base);
      if (!existing || score > existing) {
        candidateScores.set(base, score);
      }
    };

    const directions = [
      {
        key: 'north',
        nearEdge: normalizedY < edgeThreshold,
        proximity: normalizedY,
        channel: 140
      },
      {
        key: 'south',
        nearEdge: normalizedY > 1 - edgeThreshold,
        proximity: 1 - normalizedY,
        channel: 141
      },
      {
        key: 'west',
        nearEdge: normalizedX < edgeThreshold,
        proximity: normalizedX,
        channel: 142
      },
      {
        key: 'east',
        nearEdge: normalizedX > 1 - edgeThreshold,
        proximity: 1 - normalizedX,
        channel: 143
      }
    ];

    for (let i = 0; i < directions.length; i += 1) {
      const { key, nearEdge, proximity, channel } = directions[i];
      if (!nearEdge) {
        continue;
      }
      const neighbor = neighbors[key];
      if (!neighbor || !isValidReplacementBase(neighbor.baseKey)) {
        continue;
      }
      const threshold = 0.45 + proximity * 0.45;
      const roll = noiseAt(channel);
      if (roll > threshold) {
        addCandidate(neighbor.baseKey, roll);
      }
    }

    const corners = [
      {
        key: 'northWest',
        nearEdge: normalizedX < edgeThreshold && normalizedY < edgeThreshold,
        distance: normalizedX + normalizedY,
        channel: 144
      },
      {
        key: 'northEast',
        nearEdge: normalizedX > 1 - edgeThreshold && normalizedY < edgeThreshold,
        distance: 1 - normalizedX + normalizedY,
        channel: 145
      },
      {
        key: 'southWest',
        nearEdge: normalizedX < edgeThreshold && normalizedY > 1 - edgeThreshold,
        distance: normalizedX + (1 - normalizedY),
        channel: 146
      },
      {
        key: 'southEast',
        nearEdge: normalizedX > 1 - edgeThreshold && normalizedY > 1 - edgeThreshold,
        distance: 2 - normalizedX - normalizedY,
        channel: 147
      }
    ];

    for (let i = 0; i < corners.length; i += 1) {
      const { key, nearEdge, distance, channel } = corners[i];
      if (!nearEdge) {
        continue;
      }
      const neighbor = neighbors[key];
      if (!neighbor || !isValidReplacementBase(neighbor.baseKey)) {
        continue;
      }
      const threshold = 0.42 + distance * 0.25;
      const roll = noiseAt(channel);
      if (roll > threshold) {
        addCandidate(neighbor.baseKey, roll);
      }
    }

    if (candidateScores.size > 0) {
      let selectedBase = null;
      let bestScore = -Infinity;
      candidateScores.forEach((score, base) => {
        if (score > bestScore) {
          bestScore = score;
          selectedBase = base;
        }
      });
      if (selectedBase && selectedBase !== subTileBase) {
        subTile.base = selectedBase;
        removeSurfaceVariation();
      }
      return;
    }

    const edgeDistance = Math.min(
      Math.min(normalizedX, 1 - normalizedX),
      Math.min(normalizedY, 1 - normalizedY)
    );

    if (edgeDistance < 0.38) {
      const erosionThreshold = 0.14 + (0.38 - edgeDistance) * 0.3;
      if (noiseAt(148) < erosionThreshold) {
        const fallbackBase = selectNeighborBase();
        if (fallbackBase && fallbackBase !== subTileBase) {
          subTile.base = fallbackBase;
          removeSurfaceVariation();
        }
      }
    }
    return;
  }

  if (!hasSnowNeighbor) {
    return;
  }

  if (waterTileKey && subTileBase === waterTileKey) {
    return;
  }

  if (subTileBase === snowTileKey) {
    return;
  }

  let adoptSnow = false;
  const snowDirections = [
    {
      key: 'north',
      nearEdge: normalizedY < edgeThreshold,
      proximity: normalizedY,
      channel: 150
    },
    {
      key: 'south',
      nearEdge: normalizedY > 1 - edgeThreshold,
      proximity: 1 - normalizedY,
      channel: 151
    },
    {
      key: 'west',
      nearEdge: normalizedX < edgeThreshold,
      proximity: normalizedX,
      channel: 152
    },
    {
      key: 'east',
      nearEdge: normalizedX > 1 - edgeThreshold,
      proximity: 1 - normalizedX,
      channel: 153
    }
  ];

  for (let i = 0; i < snowDirections.length && !adoptSnow; i += 1) {
    const { key, nearEdge, proximity, channel } = snowDirections[i];
    if (!nearEdge || !(neighbors[key] && neighbors[key].baseKey === snowTileKey)) {
      continue;
    }
    const threshold = 0.68 - proximity * 0.35;
    if (noiseAt(channel) > threshold) {
      adoptSnow = true;
    }
  }

  const snowCorners = [
    {
      key: 'northWest',
      nearEdge: normalizedX < edgeThreshold && normalizedY < edgeThreshold,
      distance: normalizedX + normalizedY,
      channel: 154
    },
    {
      key: 'northEast',
      nearEdge: normalizedX > 1 - edgeThreshold && normalizedY < edgeThreshold,
      distance: 1 - normalizedX + normalizedY,
      channel: 155
    },
    {
      key: 'southWest',
      nearEdge: normalizedX < edgeThreshold && normalizedY > 1 - edgeThreshold,
      distance: normalizedX + (1 - normalizedY),
      channel: 156
    },
    {
      key: 'southEast',
      nearEdge: normalizedX > 1 - edgeThreshold && normalizedY > 1 - edgeThreshold,
      distance: 2 - normalizedX - normalizedY,
      channel: 157
    }
  ];

  for (let i = 0; i < snowCorners.length && !adoptSnow; i += 1) {
    const { key, nearEdge, distance, channel } = snowCorners[i];
    if (!nearEdge || !(neighbors[key] && neighbors[key].baseKey === snowTileKey)) {
      continue;
    }
    const threshold = 0.7 - distance * 0.2;
    if (noiseAt(channel) > threshold) {
      adoptSnow = true;
    }
  }

  if (!adoptSnow) {
    const edgeDistance = Math.min(
      Math.min(normalizedX, 1 - normalizedX),
      Math.min(normalizedY, 1 - normalizedY)
    );
    if (edgeDistance < 0.35) {
      const bonus = Math.max(0, 0.35 - edgeDistance);
      if (noiseAt(158) > 0.72 - bonus * 0.5) {
        adoptSnow = true;
      }
    }
  }

  if (adoptSnow) {
    subTile.base = snowTileKey;
    removeSurfaceVariation();
  }
}

function applyForestVariation(subTile, baseTile, neighbors, subdivisions, subX, subY, noiseAt, waterTileKey) {
  if (!subTile || !baseTile) {
    return;
  }
  const overlayKey = typeof baseTile.overlay === 'string' ? baseTile.overlay : null;
  const hasForestOverlay = overlayKey ? isTreeOverlayKey(overlayKey) : false;
  const normalizedX = (subX + 0.5) / subdivisions;
  const normalizedY = (subY + 0.5) / subdivisions;
  const edgeThreshold = 0.3;

  if (hasForestOverlay) {
    let keepOverlay = subTile.base !== waterTileKey;
    if (keepOverlay && normalizedY < edgeThreshold && !(neighbors.north && neighbors.north.hasForestOverlay)) {
      keepOverlay = noiseAt(31) > 0.28 + normalizedY * 0.65;
    }
    if (keepOverlay && normalizedY > 1 - edgeThreshold && !(neighbors.south && neighbors.south.hasForestOverlay)) {
      keepOverlay = noiseAt(32) > 0.28 + (1 - normalizedY) * 0.65;
    }
    if (keepOverlay && normalizedX < edgeThreshold && !(neighbors.west && neighbors.west.hasForestOverlay)) {
      keepOverlay = noiseAt(33) > 0.28 + normalizedX * 0.65;
    }
    if (keepOverlay && normalizedX > 1 - edgeThreshold && !(neighbors.east && neighbors.east.hasForestOverlay)) {
      keepOverlay = noiseAt(34) > 0.28 + (1 - normalizedX) * 0.65;
    }
    if (
      keepOverlay &&
      normalizedX < edgeThreshold &&
      normalizedY < edgeThreshold &&
      !(neighbors.northWest && neighbors.northWest.hasForestOverlay)
    ) {
      keepOverlay = noiseAt(35) > 0.25 + (normalizedX + normalizedY) * 0.35;
    }
    if (
      keepOverlay &&
      normalizedX > 1 - edgeThreshold &&
      normalizedY < edgeThreshold &&
      !(neighbors.northEast && neighbors.northEast.hasForestOverlay)
    ) {
      keepOverlay = noiseAt(36) > 0.25 + (1 - normalizedX + normalizedY) * 0.35;
    }
    if (
      keepOverlay &&
      normalizedX < edgeThreshold &&
      normalizedY > 1 - edgeThreshold &&
      !(neighbors.southWest && neighbors.southWest.hasForestOverlay)
    ) {
      keepOverlay = noiseAt(37) > 0.25 + (normalizedX + (1 - normalizedY)) * 0.35;
    }
    if (
      keepOverlay &&
      normalizedX > 1 - edgeThreshold &&
      normalizedY > 1 - edgeThreshold &&
      !(neighbors.southEast && neighbors.southEast.hasForestOverlay)
    ) {
      keepOverlay = noiseAt(38) > 0.25 + (2 - normalizedX - normalizedY) * 0.35;
    }

    if (keepOverlay && noiseAt(39) < 0.08) {
      keepOverlay = false;
    }

    if (!keepOverlay) {
      subTile.overlay = null;
      if (Number.isFinite(subTile.forestCanopyDensity)) {
        subTile.forestCanopyDensity = Math.min(subTile.forestCanopyDensity, 0.2);
      }
    } else {
      subTile.overlay = overlayKey;
      if (Number.isFinite(subTile.forestCanopyDensity)) {
        subTile.forestCanopyDensity = clamp(subTile.forestCanopyDensity + (noiseAt(47) - 0.5) * 0.12, 0, 1);
      } else {
        subTile.forestCanopyDensity = 0.6;
      }
    }
    return;
  }

  if (subTile.base === waterTileKey) {
    const subOverlayKey = typeof subTile.overlay === 'string' ? subTile.overlay : null;
    if (!subOverlayKey || !icebergOverlayKeySet.has(subOverlayKey)) {
      subTile.overlay = null;
    }
    if (Number.isFinite(subTile.forestCanopyDensity)) {
      subTile.forestCanopyDensity = Math.min(subTile.forestCanopyDensity, 0.15);
    }
    return;
  }

  if (subTile.overlay) {
    return;
  }

  const candidateOverlays = [];
  if (normalizedY < edgeThreshold && neighbors.north && neighbors.north.hasForestOverlay) {
    candidateOverlays.push(neighbors.north.overlayKey);
  }
  if (normalizedY > 1 - edgeThreshold && neighbors.south && neighbors.south.hasForestOverlay) {
    candidateOverlays.push(neighbors.south.overlayKey);
  }
  if (normalizedX < edgeThreshold && neighbors.west && neighbors.west.hasForestOverlay) {
    candidateOverlays.push(neighbors.west.overlayKey);
  }
  if (normalizedX > 1 - edgeThreshold && neighbors.east && neighbors.east.hasForestOverlay) {
    candidateOverlays.push(neighbors.east.overlayKey);
  }

  if (candidateOverlays.length === 0) {
    if (Number.isFinite(subTile.forestCanopyDensity)) {
      subTile.forestCanopyDensity = clamp(subTile.forestCanopyDensity * 0.9, 0, 1);
    }
    return;
  }

  const addChance = noiseAt(48);
  if (addChance > 0.78) {
    const index = Math.floor(noiseAt(49) * candidateOverlays.length) % candidateOverlays.length;
    const selected = candidateOverlays[index];
    if (selected) {
      subTile.overlay = selected;
      subTile.forestCanopyDensity = 0.55 + (addChance - 0.78) * 0.3;
    }
  }
}

function applyCoastlineVariation(
  subTile,
  baseTile,
  neighbors,
  subdivisions,
  subX,
  subY,
  noiseAt,
  { waterTileKey, defaultLandKey }
) {
  if (!subTile || !baseTile || !waterTileKey || subdivisions <= 1) {
    return;
  }
  if (baseTile.structure || baseTile.structureDetails || baseTile.river) {
    if (Number.isFinite(subTile.coastProximity)) {
      subTile.coastProximity = clamp(subTile.coastProximity + (noiseAt(55) - 0.5) * 0.1, 0, 1);
    }
    return;
  }

  const baseKey = typeof baseTile.base === 'string' ? baseTile.base : null;
  const isWater = baseKey === waterTileKey;
  const existingOverlayKey = typeof subTile.overlay === 'string' ? subTile.overlay : null;
  const preserveWaterOverlay = existingOverlayKey && icebergOverlayKeySet.has(existingOverlayKey);
  const normalizedX = (subX + 0.5) / subdivisions;
  const normalizedY = (subY + 0.5) / subdivisions;
  const edgeThreshold = 0.34;

  const directions = [
    { key: 'north', proximity: normalizedY, nearEdge: normalizedY < edgeThreshold },
    { key: 'south', proximity: 1 - normalizedY, nearEdge: normalizedY > 1 - edgeThreshold },
    { key: 'west', proximity: normalizedX, nearEdge: normalizedX < edgeThreshold },
    { key: 'east', proximity: 1 - normalizedX, nearEdge: normalizedX > 1 - edgeThreshold }
  ];

  let converted = false;

  if (isWater) {
    for (let i = 0; i < directions.length; i += 1) {
      const { key, proximity, nearEdge } = directions[i];
      if (!nearEdge) {
        continue;
      }
      const neighbor = neighbors[key];
      if (!neighbor || !neighbor.baseKey || neighbor.baseKey === waterTileKey) {
        continue;
      }
      const threshold = 0.35 + proximity * 0.5;
      if (noiseAt(60 + i) > threshold) {
        subTile.base = neighbor.baseKey || defaultLandKey;
        subTile.overlay = null;
        subTile.hillOverlay = null;
        subTile.waterDepth = 0;
        subTile.coastProximity = Math.max(Number.isFinite(subTile.coastProximity) ? subTile.coastProximity : 0.6, 0.75);
        converted = true;
        break;
      }
    }
  }

  if (!converted && !isWater) {
    for (let i = 0; i < directions.length; i += 1) {
      const { key, proximity, nearEdge } = directions[i];
      if (!nearEdge) {
        continue;
      }
      const neighbor = neighbors[key];
      if (!neighbor || !neighbor.isWater) {
        continue;
      }
      const threshold = 0.62 - proximity * 0.35;
      if (noiseAt(70 + i) > threshold) {
        subTile.base = waterTileKey;
        subTile.overlay = preserveWaterOverlay ? existingOverlayKey : null;
        subTile.hillOverlay = null;
        subTile.forestCanopyDensity = Number.isFinite(subTile.forestCanopyDensity)
          ? Math.min(subTile.forestCanopyDensity, 0.18)
          : subTile.forestCanopyDensity;
        subTile.coastProximity = Math.max(Number.isFinite(subTile.coastProximity) ? subTile.coastProximity : 0.7, 0.85);
        subTile.waterDepth = clamp(noiseAt(80 + i) * 0.45, 0, 0.6);
        converted = true;
        break;
      }
    }
  }

  if (!converted) {
    if (Number.isFinite(subTile.coastProximity)) {
      subTile.coastProximity = clamp(subTile.coastProximity + (noiseAt(90) - 0.5) * 0.12, 0, 1);
    }
    if (Number.isFinite(subTile.waterDepth)) {
      subTile.waterDepth = clamp(subTile.waterDepth + (noiseAt(91) - 0.5) * 0.15, 0, 1);
    }
  }
}

function generateHighResolutionLocalPatch(world, tileX, tileY) {
  if (!world || !Array.isArray(world.tiles) || world.tiles.length === 0) {
    return null;
  }

  const sourceTiles = world.tiles;
  const sourceHeight = sourceTiles.length;
  const sourceWidth = Array.isArray(sourceTiles[0]) ? sourceTiles[0].length : 0;
  if (!sourceWidth || !sourceHeight) {
    return null;
  }

  const subdivisions = Number.isFinite(localViewConfig.highResolutionTileSubdivisions)
    ? Math.max(1, Math.floor(localViewConfig.highResolutionTileSubdivisions))
    : 1;
  const paddingTiles = Number.isFinite(localViewConfig.highResolutionExtraPadding)
    ? Math.max(0, Math.floor(localViewConfig.highResolutionExtraPadding))
    : 0;

  const baseRadius = Math.max(1, localViewConfig.radius);
  const startX = clamp(tileX - baseRadius - paddingTiles, 0, sourceWidth - 1);
  const endX = clamp(tileX + baseRadius + paddingTiles, 0, sourceWidth - 1);
  const startY = clamp(tileY - baseRadius - paddingTiles, 0, sourceHeight - 1);
  const endY = clamp(tileY + baseRadius + paddingTiles, 0, sourceHeight - 1);

  const areaWidth = Math.max(1, endX - startX + 1);
  const areaHeight = Math.max(1, endY - startY + 1);
  const patchWidth = areaWidth * subdivisions;
  const patchHeight = areaHeight * subdivisions;

  const patchTiles = new Array(patchHeight);
  for (let y = 0; y < patchHeight; y += 1) {
    patchTiles[y] = new Array(patchWidth);
  }

  const seedString =
    (typeof world.seedString === 'string' && world.seedString) ||
    (typeof state.settings?.seedString === 'string' ? state.settings.seedString : 'local');
  const noiseSampler = createDeterministicNoiseSampler(
    `${seedString}:${startX},${startY}:${patchWidth}x${patchHeight}`
  );
  const waterTileKey = world.waterTileKey || resolveTileName('WATER');
  const defaultLandKey = world.grassTileKey || resolveTileName('GRASS');
  const snowTileKey = typeof world.snowTileKey === 'string' ? world.snowTileKey : null;
  const sandTileKey = typeof world.sandTileKey === 'string' ? world.sandTileKey : null;
  const badlandsTileKey =
    typeof world.badlandsTileKey === 'string' ? world.badlandsTileKey : null;
  const surfaceNoiseKeys = { snowTileKey, sandTileKey, badlandsTileKey };
  const icebergOverlayKeys = Object.keys(icebergTileCoords || {}).filter((key) =>
    tileLookup.has(key)
  );

  for (let coarseY = 0; coarseY < areaHeight; coarseY += 1) {
    const sourceRow = sourceTiles[startY + coarseY];
    for (let coarseX = 0; coarseX < areaWidth; coarseX += 1) {
      const baseTile = Array.isArray(sourceRow) ? sourceRow[startX + coarseX] || null : null;
      if (!baseTile) {
        for (let subY = 0; subY < subdivisions; subY += 1) {
          const targetRow = patchTiles[coarseY * subdivisions + subY];
          if (!Array.isArray(targetRow)) {
            continue;
          }
          for (let subX = 0; subX < subdivisions; subX += 1) {
            targetRow[coarseX * subdivisions + subX] = null;
          }
        }
        continue;
      }

      if (subdivisions <= 1) {
        const targetRow = patchTiles[coarseY];
        if (Array.isArray(targetRow)) {
          targetRow[coarseX] = cloneTileForHighResolution(baseTile);
        }
        continue;
      }

      const worldX = startX + coarseX;
      const worldY = startY + coarseY;
      const neighbors = buildNeighborDetails(sourceTiles, sourceWidth, sourceHeight, worldX, worldY, waterTileKey);
      const riverVariation = baseTile.river
        ? computeRiverSubtileVariation(baseTile.river, subdivisions, worldX, worldY, noiseSampler)
        : null;

      for (let subY = 0; subY < subdivisions; subY += 1) {
        const targetRow = patchTiles[coarseY * subdivisions + subY];
        if (!Array.isArray(targetRow)) {
          continue;
        }
        for (let subX = 0; subX < subdivisions; subX += 1) {
          const subTile = cloneTileForHighResolution(baseTile);
          const globalSubX = worldX * subdivisions + subX;
          const globalSubY = worldY * subdivisions + subY;
          const noiseAt = (channel) => noiseSampler(globalSubX, globalSubY, channel);

          applyCoastlineVariation(
            subTile,
            baseTile,
            neighbors,
            subdivisions,
            subX,
            subY,
            noiseAt,
            { waterTileKey, defaultLandKey }
          );
          applyHillOverlayVariation(subTile, baseTile, neighbors, subdivisions, subX, subY, noiseAt);
          applyMountainVariation(subTile, baseTile, neighbors, subdivisions, subX, subY, noiseAt);
          applySnowVariation(
            subTile,
            baseTile,
            neighbors,
            subdivisions,
            subX,
            subY,
            noiseAt,
            { snowTileKey, waterTileKey, defaultLandKey }
          );
          applyForestVariation(subTile, baseTile, neighbors, subdivisions, subX, subY, noiseAt, waterTileKey);
          applyRiverSubtileVariation(subTile, riverVariation, subX, subY);
          applySurfaceNoiseVariation(subTile, noiseAt, surfaceNoiseKeys);

          targetRow[coarseX * subdivisions + subX] = subTile;
        }
      }
    }
  }

  if (waterTileKey && icebergOverlayKeys.length > 0) {
    const localSeedInput = `${seedString}:${startX},${startY}:${areaWidth}x${areaHeight}:icebergs`;
    const localSeedNumber = stringToSeed(localSeedInput);
    const shuffleSeed = (localSeedNumber + 0x5ad1f32b) >>> 0;
    const rng = mulberry32(shuffleSeed || 1);
    const variantSeed = (localSeedNumber + 0x3d0e12f7) >>> 0;

    const icebergParentTiles = new Map();

    for (let y = 0; y < patchHeight; y += 1) {
      const row = patchTiles[y];
      if (!Array.isArray(row)) {
        continue;
      }
      for (let x = 0; x < patchWidth; x += 1) {
        const cell = row[x];
        if (!cell || cell.base !== waterTileKey) {
          continue;
        }

        const parentTileX = Math.floor(x / subdivisions);
        const parentTileY = Math.floor(y / subdivisions);
        const parentKey = `${parentTileX},${parentTileY}`;
        let parentEntry = icebergParentTiles.get(parentKey);

        const overlayKey = typeof cell.overlay === 'string' ? cell.overlay : null;
        const hasIceberg = overlayKey && icebergOverlayKeySet.has(overlayKey);
        const blocked = overlayKey && !hasIceberg;

        if (hasIceberg) {
          if (!parentEntry) {
            parentEntry = {
              candidates: [],
              originalOverlayKeys: new Set(),
              originalOverlays: []
            };
            icebergParentTiles.set(parentKey, parentEntry);
          }
          if (overlayKey && !parentEntry.originalOverlayKeys.has(overlayKey)) {
            parentEntry.originalOverlayKeys.add(overlayKey);
            parentEntry.originalOverlays.push(overlayKey);
          }
          cell.overlay = null;
        }

        parentEntry = icebergParentTiles.get(parentKey);
        if (!parentEntry || blocked || cell.structure || cell.river) {
          continue;
        }

        const subX = x - parentTileX * subdivisions;
        const subY = y - parentTileY * subdivisions;
        const globalSubX = (startX + parentTileX) * subdivisions + subX;
        const globalSubY = (startY + parentTileY) * subdivisions + subY;

        parentEntry.candidates.push({
          x,
          y,
          globalSubX,
          globalSubY
        });
      }
    }

    icebergParentTiles.forEach((entry) => {
      if (!entry || entry.originalOverlays.length === 0 || entry.candidates.length === 0) {
        return;
      }

      const shuffledCandidates = entry.candidates.slice();
      for (let i = shuffledCandidates.length - 1; i > 0; i -= 1) {
        const j = Math.floor(rng() * (i + 1));
        const temp = shuffledCandidates[i];
        shuffledCandidates[i] = shuffledCandidates[j];
        shuffledCandidates[j] = temp;
      }

      const placements = Math.min(entry.originalOverlays.length, shuffledCandidates.length);
      for (let i = 0; i < placements; i += 1) {
        const candidate = shuffledCandidates[i];
        if (!candidate) {
          continue;
        }
        const variantNoise = hashCoords(candidate.globalSubX, candidate.globalSubY, variantSeed);
        const variantIndex = Math.min(
          icebergOverlayKeys.length - 1,
          Math.floor(variantNoise * icebergOverlayKeys.length)
        );
        let overlayKey = entry.originalOverlays[i] || null;
        if (!overlayKey) {
          overlayKey = icebergOverlayKeys[Math.max(0, variantIndex)];
        }
        const cell = patchTiles[candidate.y][candidate.x];
        if (cell) {
          cell.overlay = overlayKey || icebergOverlayKeys[Math.max(0, variantIndex)];
        }
      }
    });
  }

  const centerX = clamp(
    (tileX - startX) * subdivisions + Math.floor(subdivisions / 2),
    0,
    Math.max(0, patchWidth - 1)
  );
  const centerY = clamp(
    (tileY - startY) * subdivisions + Math.floor(subdivisions / 2),
    0,
    Math.max(0, patchHeight - 1)
  );

  return {
    tiles: patchTiles,
    width: patchWidth,
    height: patchHeight,
    centerX,
    centerY,
    worldOriginX: startX,
    worldOriginY: startY,
    worldWidth: areaWidth,
    worldHeight: areaHeight,
    scaleX: subdivisions,
    scaleY: subdivisions,
    metadata: {
      seaLevel: world.seaLevel,
      waterTileKey: world.waterTileKey || resolveTileName('WATER'),
      grassTileKey: world.grassTileKey || resolveTileName('GRASS'),
      snowTileKey: snowTileKey || null,
      sandTileKey: sandTileKey || null,
      badlandsTileKey: badlandsTileKey || null,
      factions: Array.isArray(world.factions) ? world.factions : [],
      seedString:
        (typeof world.seedString === 'string' && world.seedString) ||
        (typeof state.settings?.seedString === 'string' ? state.settings.seedString : null)
    }
  };
}

function drawHighResolutionLocalPatch(ctx, patch, tileSize, options = {}) {
  if (!ctx || !patch || !Array.isArray(patch.tiles)) {
    return;
  }

  const { highlightX = null, highlightY = null } = options;
  const tiles = patch.tiles;
  const width = patch.width;
  const height = patch.height;
  const metadata = patch.metadata || {};
  const waterTileKey = metadata.waterTileKey || resolveTileName('WATER');
  const grassTileKey = metadata.grassTileKey || resolveTileName('GRASS');
  const snowTileKey = metadata.snowTileKey || null;
  const sandTileKey = metadata.sandTileKey || null;
  const badlandsTileKey = metadata.badlandsTileKey || null;
  const surfaceNoiseKeys = { snowTileKey, sandTileKey, badlandsTileKey };
  const patchWorld = {
    tiles,
    width,
    height,
    seaLevel: metadata.seaLevel,
    factions: metadata.factions || []
  };

  for (let y = 0; y < height; y += 1) {
    const row = tiles[y];
    if (!Array.isArray(row)) {
      continue;
    }
    for (let x = 0; x < width; x += 1) {
      const cell = row[x];
      if (!cell) {
        ctx.fillStyle = '#05060b';
        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
        continue;
      }

      const baseKey = typeof cell.base === 'string' && cell.base ? cell.base : 'GRASS';
      const baseDefinition = tileLookup.get(baseKey) || tileLookup.get('GRASS');
      if (baseDefinition) {
        const baseSheet = state.tileSheets[baseDefinition.sheet];
        if (baseSheet && baseSheet.image) {
          ctx.drawImage(
            baseSheet.image,
            baseDefinition.sx,
            baseDefinition.sy,
            baseDefinition.size,
            baseDefinition.size,
            x * tileSize,
            y * tileSize,
            tileSize,
            tileSize
          );
        }
      }

      applySurfaceNoiseShading(ctx, cell, x, y, tileSize, surfaceNoiseKeys);
      applyCoastalShading(ctx, cell, x, y, waterTileKey, grassTileKey, tileSize);
      applyVolcanoShading(ctx, cell, x, y, tileSize);

      if (cell.hillOverlay && cell.hillOverlay !== cell.overlay) {
        const hillDefinition = tileLookup.get(cell.hillOverlay);
        if (hillDefinition) {
          const hillSheet = state.tileSheets[hillDefinition.sheet];
          if (hillSheet && hillSheet.image) {
            ctx.drawImage(
              hillSheet.image,
              hillDefinition.sx,
              hillDefinition.sy,
              hillDefinition.size,
              hillDefinition.size,
              x * tileSize,
              y * tileSize,
              tileSize,
              tileSize
            );
          }
        }
      }

      if (cell.overlay) {
        const overlayDefinition = tileLookup.get(cell.overlay);
        if (!overlayDefinition) {
          drawCustomOverlay(ctx, cell.overlay, x, y, tiles, tileSize);
        } else {
          const overlaySheet = state.tileSheets[overlayDefinition.sheet];
          if (overlaySheet && overlaySheet.image) {
            ctx.drawImage(
              overlaySheet.image,
              overlayDefinition.sx,
              overlayDefinition.sy,
              overlayDefinition.size,
              overlayDefinition.size,
              x * tileSize,
              y * tileSize,
              tileSize,
              tileSize
            );
          }
        }
      }

      applyBadlandsHillTint(ctx, cell, x, y, tileSize);
      applyDesertMountainTint(ctx, cell, x, y, tileSize);
      applyMountainShading(ctx, cell, x, y, tileSize);

      if (cell.river) {
        drawRiverSegment(ctx, cell.river, x, y, tileSize);
      }

      if (cell.structure) {
        const structureDefinition = tileLookup.get(cell.structure);
        if (structureDefinition) {
          if (typeof structureDefinition.draw === 'function') {
            structureDefinition.draw(ctx, {
              x,
              y,
              pixelX: x * tileSize,
              pixelY: y * tileSize,
              size: tileSize,
              cell,
              world: patchWorld
            });
          } else {
            const structureSheet = state.tileSheets[structureDefinition.sheet];
            if (structureSheet && structureSheet.image) {
              ctx.drawImage(
                structureSheet.image,
                structureDefinition.sx,
                structureDefinition.sy,
                structureDefinition.size,
                structureDefinition.size,
                x * tileSize,
                y * tileSize,
                tileSize,
                tileSize
              );
            }
          }
        }
      }
    }
  }

  ctx.save();
  ctx.strokeStyle = 'rgba(15, 23, 42, 0.32)';
  ctx.lineWidth = 1;
  for (let x = 1; x < width; x += 1) {
    const px = Math.round(x * tileSize) + 0.5;
    ctx.beginPath();
    ctx.moveTo(px, 0);
    ctx.lineTo(px, height * tileSize);
    ctx.stroke();
  }
  for (let y = 1; y < height; y += 1) {
    const py = Math.round(y * tileSize) + 0.5;
    ctx.beginPath();
    ctx.moveTo(0, py);
    ctx.lineTo(width * tileSize, py);
    ctx.stroke();
  }
  ctx.restore();

  if (Number.isFinite(highlightX) && Number.isFinite(highlightY)) {
    const highlightPixelX = highlightX * tileSize;
    const highlightPixelY = highlightY * tileSize;
    const lineWidth = Math.max(2, Math.round(tileSize * 0.12));
    ctx.save();
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = 'rgba(240, 198, 116, 0.9)';
    ctx.fillStyle = 'rgba(240, 198, 116, 0.12)';
    ctx.fillRect(highlightPixelX, highlightPixelY, tileSize, tileSize);
    ctx.strokeRect(
      highlightPixelX + lineWidth / 2,
      highlightPixelY + lineWidth / 2,
      tileSize - lineWidth,
      tileSize - lineWidth
    );
    ctx.restore();
  }
}

function showLocalViewAt(tileX, tileY) {
  const world = state.currentWorld;
  if (!world || !Array.isArray(world.tiles) || world.tiles.length === 0) {
    return;
  }
  const height = world.tiles.length;
  const width = Array.isArray(world.tiles[0]) ? world.tiles[0].length : 0;
  if (width === 0) {
    return;
  }
  const clampedX = clamp(tileX, 0, width - 1);
  const clampedY = clamp(tileY, 0, height - 1);
  const bounds = computeLocalViewBounds(clampedX, clampedY, width, height, localViewConfig.radius);
  state.localView.active = true;
  state.localView.centerX = clampedX;
  state.localView.centerY = clampedY;
  state.localView.bounds = bounds;
  const highResolutionPatch = generateHighResolutionLocalPatch(world, clampedX, clampedY);
  if (highResolutionPatch) {
    state.localView.mode = 'worldHighRes';
    state.localView.highResolution = highResolutionPatch;
  } else {
    state.localView.mode = 'world';
    state.localView.highResolution = null;
  }
  state.localView.customMap = null;
  state.localView.structure = null;
  drawWorld(world, { preserveView: true });
}

async function showDwarfholdInterior(tile, tileX, tileY) {
  const world = state.currentWorld;
  if (!world || !Array.isArray(world.tiles) || world.tiles.length === 0) {
    return;
  }
  const height = world.tiles.length;
  const width = Array.isArray(world.tiles[0]) ? world.tiles[0].length : 0;
  if (width === 0) {
    return;
  }

  const clampedX = clamp(Number(tileX) || 0, 0, width - 1);
  const clampedY = clamp(Number(tileY) || 0, 0, height - 1);
  const bounds = computeLocalViewBounds(clampedX, clampedY, width, height, localViewConfig.radius);

  const seedCandidates = [
    typeof state.settings?.seedString === 'string' ? state.settings.seedString : null,
    typeof state.settings?.lastSeedString === 'string' ? state.settings.lastSeedString : null,
    typeof state.worldName === 'string' && state.worldName ? state.worldName : null
  ];
  const resolvedSeed = seedCandidates.find((value) => value && value.length > 0) || 'dwarfhold';

  try {
    const generateDwarfholdMap = await loadDwarfholdGenerator();
    const structurePopulation = Number.isFinite(tile?.structureDetails?.population)
      ? tile.structureDetails.population
      : null;
    const structurePopulationMax = Number.isFinite(tile?.structureDetails?.populationMax)
      ? tile.structureDetails.populationMax
      : null;
    const customMap = generateDwarfholdMap({
      structureKey: typeof tile?.structure === 'string' ? tile.structure : null,
      structureName:
        typeof tile?.structureName === 'string' && tile.structureName
          ? tile.structureName
          : typeof tile?.areaName === 'string' && tile.areaName
          ? tile.areaName
          : null,
      faction: tile?.structureDetails?.owner || tile?.factionId || null,
      tileX: clampedX,
      tileY: clampedY,
      worldSeed: resolvedSeed,
      population: structurePopulation,
      populationMax: structurePopulationMax
    });

    state.localView.active = true;
    state.localView.centerX = clampedX;
    state.localView.centerY = clampedY;
    state.localView.bounds = bounds;
    state.localView.mode = 'dwarfhold';
    state.localView.customMap = customMap;
    state.localView.structure = tile || null;
    state.localView.highResolution = null;

    state.dwarfholdView.active = true;
    state.dwarfholdView.map = customMap;
    state.dwarfholdView.tileX = clampedX;
    state.dwarfholdView.tileY = clampedY;
    state.dwarfholdView.structure = tile || null;

    drawWorld(world, { preserveView: true });
    openDwarfholdScreen();
  } catch (error) {
    console.error('Failed to load dwarfhold interior map.', error);
  }
}

function closeDwarfholdInterior(options = {}) {
  const { returnFocus = false, suppressRedraw = false } = options;
  hideLocalView({ suppressRedraw, returnFocus });
}

function drawLocalSelectionOverlay(ctx) {
  if (!ctx || !state.localView || !state.localView.active || !state.localView.bounds) {
    return;
  }
  const bounds = state.localView.bounds;
  const widthTiles = Math.max(1, bounds.endX - bounds.startX + 1);
  const heightTiles = Math.max(1, bounds.endY - bounds.startY + 1);
  const pixelX = bounds.startX * drawSize;
  const pixelY = bounds.startY * drawSize;
  const pixelWidth = widthTiles * drawSize;
  const pixelHeight = heightTiles * drawSize;
  const lineWidth = Math.max(2, Math.round(drawSize * 0.18));
  ctx.save();
  ctx.fillStyle = 'rgba(240, 198, 116, 0.12)';
  ctx.fillRect(pixelX, pixelY, pixelWidth, pixelHeight);
  ctx.strokeStyle = 'rgba(240, 198, 116, 0.85)';
  ctx.lineWidth = lineWidth;
  const dash = Math.max(4, Math.round(drawSize * 0.6));
  ctx.setLineDash([dash, dash]);
  ctx.strokeRect(
    pixelX + lineWidth / 2,
    pixelY + lineWidth / 2,
    Math.max(0, pixelWidth - lineWidth),
    Math.max(0, pixelHeight - lineWidth)
  );
  ctx.restore();
}

function formatStructureDetailLabel(value) {
  if (value === null || value === undefined) {
    return null;
  }
  const stringValue = String(value)
    .replace(/[_-]+/g, ' ')
    .replace(/([a-z])([A-Z])/g, '$1 $2')
    .trim();
  if (!stringValue) {
    return null;
  }
  return stringValue
    .split(' ')
    .map((part) => (part ? part.charAt(0).toUpperCase() + part.slice(1) : part))
    .join(' ');
}

function buildBreakdownPanelSection(resolvedName, breakdown, options = {}) {
  if (!Array.isArray(breakdown) || breakdown.length === 0) {
    return '';
  }

  const heading = typeof options.heading === 'string' && options.heading.trim()
    ? options.heading.trim()
    : 'Breakdown';
  const ariaLabelPrefix = typeof options.ariaLabelPrefix === 'string' && options.ariaLabelPrefix.trim()
    ? options.ariaLabelPrefix.trim()
    : heading;
  const combineSmallEntries = options.combineSmallEntries !== false;
  const smallEntryThreshold = Number.isFinite(options.smallEntryThreshold)
    ? Math.max(0, options.smallEntryThreshold)
    : 0.5;
  const priorityKeys = Array.isArray(options.priorityKeys) ? options.priorityKeys : [];
  const otherLabel = typeof options.otherLabel === 'string' && options.otherLabel.trim()
    ? options.otherLabel.trim()
    : 'Other';
  const otherColor = typeof options.otherColor === 'string' && options.otherColor.trim()
    ? options.otherColor.trim()
    : '#666666';

  const resolvedEntries = breakdown
    .map((entry, index) => {
      if (!entry || !Number.isFinite(entry.percentage) || entry.percentage <= 0) {
        return null;
      }
      const rawPercentage = Number(entry.percentage);
      const safePercentage = Number.isFinite(rawPercentage) ? Math.max(0, rawPercentage) : 0;
      const roundedPercentage = Math.round(safePercentage * 100) / 100;
      const resolvedLabel = entry.label || entry.key || `Entry ${index + 1}`;
      const key = typeof entry.key === 'string' && entry.key ? entry.key : null;
      const color = entry.color || '#999999';
      const population = Number.isFinite(entry.population) && entry.population > 0
        ? Math.max(0, Math.round(entry.population))
        : null;
      return {
        key,
        label: resolvedLabel,
        percentage: roundedPercentage,
        color,
        population
      };
    })
    .filter(Boolean);

  if (resolvedEntries.length === 0) {
    return '';
  }

  let displayEntries = resolvedEntries.slice();

  if (combineSmallEntries) {
    const priorityEntries = [];
    const majorEntries = [];
    let otherPercentage = 0;
    let otherPopulation = 0;
    let otherPopulationKnown = true;

    resolvedEntries.forEach((entry) => {
      if (entry.key && priorityKeys.includes(entry.key)) {
        priorityEntries.push(entry);
        return;
      }

      if (entry.percentage < smallEntryThreshold) {
        otherPercentage += entry.percentage;
        if (entry.population === null) {
          otherPopulationKnown = false;
        } else if (otherPopulationKnown) {
          otherPopulation += entry.population;
        }
      } else {
        majorEntries.push(entry);
      }
    });

    const combinedEntries = [...priorityEntries, ...majorEntries];

    if (otherPercentage > 0) {
      const roundedOtherPercentage = Math.round(otherPercentage * 100) / 100;
      combinedEntries.push({
        key: 'other',
        label: otherLabel,
        percentage: roundedOtherPercentage,
        color: otherColor,
        population: otherPopulationKnown ? otherPopulation : null
      });
    }

    displayEntries = combinedEntries.length > 0 ? combinedEntries : resolvedEntries;
  }

  if (displayEntries.length === 0) {
    return '';
  }

  let cumulative = 0;
  const stops = displayEntries.map((entry, index) => {
    const start = Math.min(100, Math.max(0, Math.round(cumulative * 100) / 100));
    cumulative = Math.round((cumulative + entry.percentage) * 100) / 100;
    const end =
      index === displayEntries.length - 1
        ? 100
        : Math.min(100, Math.max(0, Math.round(cumulative * 100) / 100));
    return `${entry.color} ${formatGradientPercentage(start)}% ${formatGradientPercentage(end)}%`;
  });

  if (stops.length === 0) {
    return '';
  }

  const pieStyle = `background: conic-gradient(${stops.join(', ')});`;
  const ariaLabelParts = [ariaLabelPrefix];
  if (resolvedName) {
    ariaLabelParts.push(`for ${resolvedName}`);
  }
  const ariaLabel = ariaLabelParts.join(' ');

  const legendItems = displayEntries
    .map((entry) => {
      const valueParts = [`${formatPercentageDisplay(entry.percentage)}%`];
      if (entry.population !== null) {
        valueParts.push(`(${entry.population.toLocaleString('en-US')})`);
      }
      return `
        <li>
          <span class="structure-details-legend-swatch" style="background:${escapeHtml(entry.color)}"></span>
          <span class="structure-details-legend-label">${escapeHtml(entry.label)}</span>
          <span class="structure-details-legend-value">${escapeHtml(valueParts.join(' '))}</span>
        </li>
      `;
    })
    .join('');

  return `
    <section class="structure-details-section structure-details-section--chart">
      <h3 class="structure-details-heading">${escapeHtml(heading)}</h3>
      <div class="structure-details-chart">
        <div
          class="structure-details-chart-pie"
          role="img"
          aria-label="${escapeHtml(ariaLabel)}"
          style="${escapeHtml(pieStyle)}"
        ></div>
        <ul class="structure-details-chart-legend">${legendItems}</ul>
      </div>
    </section>
  `;
}

function buildPopulationBreakdownPanelSection(resolvedName, breakdown) {
  return buildBreakdownPanelSection(resolvedName, breakdown, {
    heading: 'Population Breakdown',
    ariaLabelPrefix: 'Population breakdown',
    combineSmallEntries: true,
    smallEntryThreshold: 0.5,
    priorityKeys: ['wizards'],
    otherLabel: 'Other',
    otherColor: '#666666'
  });
}

function buildClanBreakdownPanelSection(resolvedName, breakdown, label) {
  if (!Array.isArray(breakdown) || breakdown.length === 0) {
    return '';
  }

  const heading = label && label.trim() ? label.trim() : 'Major Clans';

  return buildBreakdownPanelSection(resolvedName, breakdown, {
    heading,
    ariaLabelPrefix: 'Clan breakdown',
    combineSmallEntries: false
  });
}

function buildGuildBreakdownPanelSection(resolvedName, breakdown, label) {
  if (!Array.isArray(breakdown) || breakdown.length === 0) {
    return '';
  }

  const heading = label && label.trim() ? label.trim() : 'Major Guilds';

  return buildBreakdownPanelSection(resolvedName, breakdown, {
    heading,
    ariaLabelPrefix: 'Guild breakdown',
    combineSmallEntries: false
  });
}

function hashStringToNumber(value) {
  if (value === null || value === undefined) {
    return 0;
  }
  const stringValue = String(value);
  if (!stringValue) {
    return 0;
  }
  let hash = 0;
  for (let index = 0; index < stringValue.length; index += 1) {
    const charCode = stringValue.charCodeAt(index);
    hash = (hash << 5) - hash + charCode;
    hash |= 0; // eslint-disable-line no-bitwise
  }
  return hash;
}

function sanitizeLabelKey(label) {
  if (typeof label !== 'string') {
    return '';
  }
  const trimmed = label.trim().toLowerCase();
  if (!trimmed) {
    return '';
  }
  return trimmed.replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
}

function generateLabelColor(label, index = 0, seed = '') {
  const baseSeed = `${seed}|${label}|${index}`;
  const hash = Math.abs(hashStringToNumber(baseSeed));
  const hue = ((hash % 360) + 360) % 360;
  const saturation = 44 + (hash % 28);
  const lightness = 42 + (Math.floor(hash / 360) % 16);
  const clampedSaturation = Math.max(35, Math.min(80, saturation));
  const clampedLightness = Math.max(32, Math.min(70, lightness));
  return `hsl(${hue}, ${clampedSaturation}%, ${clampedLightness}%)`;
}

function generateLabelBreakdown(labels, random, options = {}) {
  if (!Array.isArray(labels) || labels.length === 0) {
    return [];
  }

  const filteredLabels = labels
    .map((label) => (typeof label === 'string' ? label.trim() : ''))
    .filter(Boolean);

  if (filteredLabels.length === 0) {
    return [];
  }

  const uniqueLabels = Array.from(new Set(filteredLabels));
  if (uniqueLabels.length === 0) {
    return [];
  }

  const randomFn = typeof random === 'function' ? random : Math.random;
  const keyPrefix = typeof options.keyPrefix === 'string' && options.keyPrefix.trim()
    ? options.keyPrefix.trim()
    : 'entry';
  const colorSeed = typeof options.colorSeed === 'string' ? options.colorSeed : '';

  const percentageDecimals = 2;
  const percentageScale = 10 ** percentageDecimals;
  const totalUnits = 100 * percentageScale;

  const weightEntries = uniqueLabels.map((label, index) => {
    const normalizedIndex = index + 1;
    const baseSeed = `${label}|${colorSeed}|${normalizedIndex}`;
    const hash = Math.abs(hashStringToNumber(baseSeed));
    const baseWeight = (hash % 1000) / 1000;
    const noise = 0.35 + randomFn() * 0.65;
    const weight = Math.max(0.1, baseWeight + noise);
    return {
      label,
      index,
      weight
    };
  });

  const totalWeight = weightEntries.reduce((sum, entry) => sum + entry.weight, 0) || 1;

  const scaledEntries = weightEntries.map((entry) => {
    const share = entry.weight / totalWeight;
    const rawPercentage = share * 100;
    const scaledRaw = rawPercentage * percentageScale;
    const baseUnit = Math.floor(scaledRaw);
    const fraction = Math.max(0, Math.min(1, scaledRaw - baseUnit));
    return {
      entry,
      baseUnit,
      fraction
    };
  });

  let remainderUnits = totalUnits - scaledEntries.reduce((sum, item) => sum + item.baseUnit, 0);

  const fractionalOrder = scaledEntries
    .map((item, index) => ({ index, fraction: item.fraction }))
    .sort((a, b) => b.fraction - a.fraction);

  let incrementIndex = 0;
  while (remainderUnits > 0 && fractionalOrder.length > 0) {
    const target = fractionalOrder[incrementIndex % fractionalOrder.length];
    scaledEntries[target.index].baseUnit += 1;
    remainderUnits -= 1;
    incrementIndex += 1;
  }

  const ascending = fractionalOrder.slice().reverse();
  let decrementIndex = 0;
  while (remainderUnits < 0 && ascending.length > 0) {
    const target = ascending[decrementIndex % ascending.length];
    if (scaledEntries[target.index].baseUnit > 0) {
      scaledEntries[target.index].baseUnit -= 1;
      remainderUnits += 1;
    }
    decrementIndex += 1;
  }

  if (remainderUnits !== 0 && scaledEntries.length > 0) {
    const lastIndex = scaledEntries.length - 1;
    const adjusted = Math.max(
      0,
      Math.min(totalUnits, scaledEntries[lastIndex].baseUnit + remainderUnits)
    );
    remainderUnits -= adjusted - scaledEntries[lastIndex].baseUnit;
    scaledEntries[lastIndex].baseUnit = adjusted;
  }

  const usedKeys = new Set();

  return scaledEntries.map(({ entry, baseUnit }) => {
    const percentage = Math.min(100, Math.max(0, baseUnit / percentageScale));
    let baseKey = sanitizeLabelKey(entry.label);
    if (!baseKey) {
      baseKey = `${keyPrefix}-${entry.index + 1}`;
    }
    let key = baseKey;
    let suffix = 2;
    while (usedKeys.has(key)) {
      key = `${baseKey}-${suffix}`;
      suffix += 1;
    }
    usedKeys.add(key);

    return {
      key,
      label: entry.label,
      percentage,
      color: generateLabelColor(entry.label, entry.index, colorSeed || keyPrefix)
    };
  });
}

function buildRulerPortraitTheme(seed) {
  const hash = hashStringToNumber(seed || '');
  const baseHue = ((hash % 360) + 360) % 360;
  const highlightHue = (baseHue + 24) % 360;
  const accentHue = (baseHue + 160) % 360;
  return {
    background: `linear-gradient(155deg, hsl(${baseHue}, 38%, 26%), hsl(${highlightHue}, 46%, 34%))`,
    accent: `hsl(${accentHue}, 68%, 72%)`,
    border: `hsl(${baseHue}, 46%, 18%)`,
    glow: `hsla(${accentHue}, 70%, 60%, 0.35)`
  };
}

function getRulerInitials(name, fallbackLabel) {
  const source = typeof name === 'string' && name.trim() ? name.trim() : fallbackLabel || '';
  if (!source) {
    return '?';
  }
  const parts = source
    .split(/[\s-]+/)
    .filter(Boolean)
    .slice(0, 3);
  if (parts.length === 0) {
    return '?';
  }
  return parts
    .map((part) => part.charAt(0).toUpperCase())
    .join('');
}

function buildRulerPortraitPanelSection(resolvedName, details) {
  if (!details || !details.isSettlement) {
    return '';
  }

  const ruler = details.ruler;
  if (!ruler || (!ruler.name && !ruler.title && !ruler.label)) {
    return '';
  }

  const title = typeof ruler.title === 'string' ? ruler.title.trim() : '';
  const name = typeof ruler.name === 'string' ? ruler.name.trim() : '';
  const label =
    typeof ruler.label === 'string' && ruler.label.trim() ? ruler.label.trim() : title || 'Ruler';
  const displayName = [title, name].filter(Boolean).join(' ').trim();
  const settlementDescriptor = resolvedName ? `of ${resolvedName}` : '';
  const roleText = settlementDescriptor ? `${label} ${settlementDescriptor}` : label;
  const epithet = typeof ruler.epithet === 'string' && ruler.epithet.trim() ? ruler.epithet.trim() : '';
  const motto = typeof ruler.motto === 'string' && ruler.motto.trim() ? ruler.motto.trim() : '';
  const secondaryLine = motto || epithet;
  const seedParts = [
    resolvedName,
    name,
    title,
    label,
    details.banner,
    details.rulingHouse,
    details.prominentGroup
  ]
    .filter((value) => typeof value === 'string' && value.trim())
    .join('|');
  const theme = buildRulerPortraitTheme(seedParts);
  const initials = getRulerInitials(name, displayName || label);
  const figureLabelParts = [];
  if (displayName) {
    figureLabelParts.push(displayName);
  }
  if (roleText && roleText !== displayName) {
    figureLabelParts.push(roleText);
  }
  if (secondaryLine) {
    figureLabelParts.push(secondaryLine);
  }
  const figureAriaLabel =
    figureLabelParts.length > 0 ? figureLabelParts.join(' — ') : 'Ruler portrait';
  const styleParts = [];
  if (theme.background) {
    styleParts.push(`--portrait-background:${theme.background}`);
  }
  if (theme.accent) {
    styleParts.push(`--portrait-accent:${theme.accent}`);
  }
  if (theme.border) {
    styleParts.push(`--portrait-border:${theme.border}`);
  }
  if (theme.glow) {
    styleParts.push(`--portrait-glow:${theme.glow}`);
  }
  const styleAttr = escapeHtml(styleParts.join(';'));

  return `
    <section class="structure-details-section structure-details-section--portrait">
      <h3 class="structure-details-heading">Ruler Portrait</h3>
      <figure class="ruler-portrait" role="group" aria-label="${escapeHtml(figureAriaLabel)}">
        <div class="ruler-portrait-frame" style="${styleAttr}">
          <div class="ruler-portrait-image">
            <span class="ruler-portrait-emblem">${escapeHtml(initials)}</span>
          </div>
        </div>
        <figcaption class="ruler-portrait-caption">
          ${displayName ? `<span class="ruler-portrait-name">${escapeHtml(displayName)}</span>` : ''}
          ${roleText ? `<span class="ruler-portrait-role">${escapeHtml(roleText)}</span>` : ''}
          ${secondaryLine ? `<span class="ruler-portrait-epithet">${escapeHtml(secondaryLine)}</span>` : ''}
        </figcaption>
      </figure>
    </section>
  `;
}

function buildStructureDetailsPanelContent(tile, context = {}) {
  if (!tile) {
    return null;
  }

  const details = tile.structureDetails || {};
  const resolvedName =
    (typeof tile.structureName === 'string' && tile.structureName) ||
    (typeof details.name === 'string' && details.name) ||
    null;

  if (!resolvedName) {
    return null;
  }

  if (tile.structureName !== resolvedName) {
    tile = { ...tile, structureName: resolvedName };
  }
  const subtitleParts = [];
  if (details.classification) {
    subtitleParts.push(details.classification);
  }
  const typeLabel = details.displayType || formatStructureDetailLabel(details.type);
  if (typeLabel) {
    subtitleParts.push(typeLabel);
  }
  const subtitle = subtitleParts.join(' • ') || null;

  const overviewEntries = [];
  const addOverviewEntry = (label, value) => {
    if (value === null || value === undefined) {
      return;
    }
    const isNumber = typeof value === 'number';
    const stringValue = isNumber
      ? value.toLocaleString('en-US')
      : typeof value === 'string'
      ? value.trim()
      : String(value).trim();
    if (!stringValue) {
      return;
    }
    overviewEntries.push({ label, value: stringValue });
  };

  const listSections = [];
  const listSectionKeys = new Set();
  const addListSection = (items, label, key) => {
    if (!Array.isArray(items) || items.length === 0) {
      return;
    }
    const uniqueItems = Array.from(
      new Set(
        items
          .map((item) => (typeof item === 'string' ? item.trim() : ''))
          .filter((item) => item.length > 0)
      )
    );
    if (uniqueItems.length === 0) {
      return;
    }
    const sectionKey = key || label;
    if (sectionKey && listSectionKeys.has(sectionKey)) {
      return;
    }
    if (sectionKey) {
      listSectionKeys.add(sectionKey);
    }
    listSections.push({ label, items: uniqueItems });
  };

  const narrativeSections = [];
  const addNarrativeSection = (label, text) => {
    if (!text) {
      return;
    }
    narrativeSections.push({ label, text });
  };

  if (tile.areaName) {
    addOverviewEntry('Region', tile.areaName);
  }

  if (tile.biomeType) {
    const definition = biomeTypeDefinitions[tile.biomeType];
    let biomeLabel = definition && definition.label ? definition.label : null;
    if (!biomeLabel) {
      biomeLabel = formatStructureDetailLabel(tile.biomeType);
    }
    if (biomeLabel) {
      addOverviewEntry('Biome', biomeLabel);
    }
  }

  const faction = getFactionForTile(tile);
  if (faction && faction.name) {
    addOverviewEntry('Realm', faction.name);
  }
  const dominantCulture = getDominantCulturalInfluence(tile);
  if (dominantCulture) {
    const influenceDescription = describeInfluenceStrength(dominantCulture.strength);
    const value = influenceDescription
      ? `${dominantCulture.label} — ${influenceDescription}`
      : dominantCulture.label;
    addOverviewEntry('Cultural Influence', value);
  }

  if (details.population !== null && details.population !== undefined) {
    const roundedPopulation = Math.max(0, Math.round(Number(details.population)));
    if (Number.isFinite(roundedPopulation)) {
      const formattedPopulation = roundedPopulation.toLocaleString('en-US');
      const populationLabel = details.populationLabel || 'Population';
      const descriptor = details.populationDescriptor || null;
      const populationDisplay = descriptor
        ? `${formattedPopulation} ${descriptor}`
        : formattedPopulation;
      addOverviewEntry(populationLabel, populationDisplay);
    }
  }

  if (details.classification && !subtitleParts.includes(details.classification)) {
    addOverviewEntry('Classification', details.classification);
  }

  if (details.displayType) {
    addOverviewEntry('Type', details.displayType);
  } else if (!details.displayType && details.type) {
    const formattedType = formatStructureDetailLabel(details.type);
    if (formattedType) {
      addOverviewEntry('Type', formattedType);
    }
  }

  if (details.tribe) {
    addOverviewEntry('Tribe', details.tribe);
  }
  if (details.threatLevel) {
    addOverviewEntry('Threat Level', details.threatLevel);
  }
  if (details.inhabitants) {
    addOverviewEntry('Inhabitants', details.inhabitants);
  }
  if (details.warLeader) {
    addOverviewEntry('Warlord', details.warLeader);
  }
  if (details.guardians) {
    addOverviewEntry('Guardians', details.guardians);
  }
  if (details.depth) {
    addOverviewEntry('Depth', details.depth);
  }
  if (details.order) {
    addOverviewEntry('Order', details.order);
  }
  if (details.devotion) {
    addOverviewEntry('Devotion', details.devotion);
  }
  if (details.caretaker) {
    addOverviewEntry('Caretaker', details.caretaker);
  }
  if (details.rulingHouse) {
    addOverviewEntry('Ruling House', details.rulingHouse);
  }
  if (details.banner) {
    addOverviewEntry('Banner', details.banner);
  }
  if (Number.isFinite(details.garrison)) {
    addOverviewEntry('Garrison', Math.max(0, Math.round(details.garrison)).toLocaleString('en-US'));
  }
  if (details.patronSaint) {
    addOverviewEntry('Patron Saint', details.patronSaint);
  }
  if (details.vow) {
    addOverviewEntry('Vow', details.vow);
  }

  if (details.ruler && (details.ruler.title || details.ruler.name)) {
    const rulerTitle = details.ruler.title ? `${details.ruler.title} ` : '';
    const rulerName = details.ruler.name || '';
    const combined = `${rulerTitle}${rulerName}`.trim();
    if (combined) {
      const rulerLabel = details.ruler.label || 'Ruler';
      addOverviewEntry(rulerLabel, combined);
    }
  }

  if (Number.isFinite(details.foundedYearsAgo)) {
    const foundedValue = Math.max(1, Math.round(details.foundedYearsAgo));
    addOverviewEntry('Founded', `${foundedValue} years ago`);
  }

  const prominentGroup = details.prominentGroup || details.prominentClan;
  if (prominentGroup) {
    const prominentLabel =
      details.prominentGroupLabel || (details.prominentClan ? 'Prominent Clan' : 'Prominent Group');
    addOverviewEntry(prominentLabel, prominentGroup);
  }

  if (Array.isArray(details.majorClans) && details.majorClans.length > 0) {
    const formattedClans = formatListWithConjunction(details.majorClans);
    if (formattedClans) {
      const majorClansLabel = details.majorClansLabel || 'Major Clans';
      addOverviewEntry(majorClansLabel, formattedClans);
    }
  }

  addListSection(details.majorGuilds, details.majorGuildsLabel || 'Major Guilds', 'majorGuilds');
  addListSection(details.majorExports, details.majorExportsLabel || 'Major Exports', 'majorExports');

  const excludedArrayKeys = new Set([
    'populationBreakdown',
    'majorGuilds',
    'majorExports',
    'majorClans',
    'clanBreakdown',
    'guildBreakdown'
  ]);
  Object.entries(details).forEach(([key, value]) => {
    if (!Array.isArray(value) || excludedArrayKeys.has(key)) {
      return;
    }
    const label = formatStructureDetailLabel(key);
    if (label) {
      addListSection(value, label, key);
    }
  });

  if (details.description) {
    addNarrativeSection('Description', details.description);
  }
  if (details.hallmark) {
    const hallmarkLabel = details.hallmarkLabel || 'Hallmark';
    addNarrativeSection(hallmarkLabel, details.hallmark);
  }

  const populationBreakdownSection = buildPopulationBreakdownPanelSection(
    resolvedName,
    details.populationBreakdown
  );
  const clanBreakdownSection = buildClanBreakdownPanelSection(
    resolvedName,
    details.clanBreakdown,
    details.majorClansLabel
  );
  const guildBreakdownSection = buildGuildBreakdownPanelSection(
    resolvedName,
    details.guildBreakdown,
    details.majorGuildsLabel
  );

  const columnSections = [[], [], []];

  const rulerPortraitSection = buildRulerPortraitPanelSection(resolvedName, details);
  if (rulerPortraitSection) {
    columnSections[0].push(rulerPortraitSection);
  }

  if (overviewEntries.length > 0) {
    const overviewItems = overviewEntries
      .map(
        (entry) => `
          <div>
            <dt>${escapeHtml(entry.label)}</dt>
            <dd>${escapeHtml(entry.value)}</dd>
          </div>
        `
      )
      .join('');
    columnSections[0].push(`
      <section class="structure-details-section structure-details-section--overview">
        <h3 class="structure-details-heading">Overview</h3>
        <dl class="structure-details-list">${overviewItems}</dl>
      </section>
    `);
  }

  if (populationBreakdownSection) {
    columnSections[1].push(populationBreakdownSection);
  }

  if (clanBreakdownSection) {
    columnSections[1].push(clanBreakdownSection);
  }

  if (guildBreakdownSection) {
    columnSections[1].push(guildBreakdownSection);
  }

  if (listSections.length > 0) {
    const collections = listSections
      .map((section) => {
        const items = section.items
          .map((item) => `<li>${escapeHtml(item)}</li>`)
          .join('');
        return `
          <article class="structure-details-collection">
            <h4 class="structure-details-collection-title">${escapeHtml(section.label)}</h4>
            <ul class="structure-details-collection-list">${items}</ul>
          </article>
        `;
      })
      .join('');
    columnSections[2].push(`
      <section class="structure-details-section structure-details-section--collections">
        <h3 class="structure-details-heading">Notable Groups &amp; Orders</h3>
        <div class="structure-details-collections-grid">${collections}</div>
      </section>
    `);
  }

  narrativeSections.forEach((section) => {
    columnSections[2].push(`
      <section class="structure-details-section structure-details-section--narrative">
        <h3 class="structure-details-heading">${escapeHtml(section.label)}</h3>
        <p class="structure-details-paragraph">${escapeHtml(section.text)}</p>
      </section>
    `);
  });

  const settlementArtVariants = [
    {
      file: 'Dwarf-Fortress_1.webp',
      alt: 'Illustration of a dwarven settlement'
    },
    {
      file: 'Dwarf-Fortress_2.webp',
      alt: 'Illustration of a dwarven stronghold'
    },
    {
      file: 'Dwarf-Fortress_grass_1.webp',
      alt: 'Illustration of a dwarven hold nestled in grassy hills'
    },
    {
      file: 'Dwarf_Fortress_3.webp',
      alt: 'Illustration of a sprawling dwarven fortress'
    },
    {
      file: 'dwarf_fortress_4.webp',
      alt: 'Illustration of a fortified dwarven city'
    },
    {
      file: 'Dark-Tower_1.webp',
      alt: 'Illustration of a looming dark tower settlement'
    },
    {
      file: 'Hill-Hold_1.webp',
      alt: 'Illustration of a dwarven hill hold'
    },
    {
      file: 'ruined_dwarfhold_1.webp',
      alt: 'Illustration of a ruined dwarven hold'
    }
  ];
  const settlementArtSeedParts = [
    tile?.structureName,
    details?.name,
    details?.type,
    tile?.structure,
    Number.isFinite(context?.tileX) ? `x${context.tileX}` : null,
    Number.isFinite(context?.tileY) ? `y${context.tileY}` : null
  ]
    .map((value) => (value != null ? String(value).trim() : ''))
    .filter((value) => value.length > 0);
  const settlementArtSeedString =
    settlementArtSeedParts.length > 0 ? settlementArtSeedParts.join('|') : 'default-settlement-art';
  const settlementArtSeed = (stringToSeed(settlementArtSeedString) + 0x5f1f4d5b) >>> 0;
  const settlementArtRandom = mulberry32(settlementArtSeed || 1);
  const isEvilWizardTower = details?.type === 'evilWizardTower';
  const settlementArtPool = isEvilWizardTower
    ? [
        {
          file: 'Evil-Tower_1.webp',
          alt: "Illustration of an evil wizard's tower"
        }
      ]
    : settlementArtVariants;
  const settlementArtIndex = Math.floor(settlementArtRandom() * settlementArtPool.length) || 0;
  const settlementArtVariant =
    settlementArtPool[Math.min(Math.max(settlementArtIndex, 0), settlementArtPool.length - 1)] ||
    settlementArtPool[0];
  const settlementArtwork = `
    <figure class="structure-details-art">
      <div class="structure-details-art-frame">
        <img
          class="structure-details-art-image"
          src="tilesheet/settlement%20art/${encodeURI(settlementArtVariant.file)}"
          alt="${escapeHtml(settlementArtVariant.alt || 'Illustration of a dwarven settlement')}"
          loading="lazy"
        />
      </div>
    </figure>
  `;

  const hasSectionContent = columnSections.some((items) => items.length > 0);

  let body;

  const historyContent = buildSettlementHistoryContent(tile, details, context);

  if (hasSectionContent) {
    columnSections[2].push(settlementArtwork);

    const populatedColumns = columnSections
      .map((items, index) => {
        if (items.length === 0) {
          return '';
        }
        const columnNames = ['primary', 'secondary', 'tertiary'];
        const columnClass = columnNames[index] || `col-${index + 1}`;
        return `
          <div class="structure-details-column structure-details-column--${columnClass}">
            ${items.join('')}
          </div>
        `;
      })
      .filter(Boolean);

    body = populatedColumns.length > 0
      ? populatedColumns.join('')
      : `
        <div class="structure-details-column structure-details-column--tertiary">
          ${settlementArtwork}
        </div>
      `;
  } else {
    body = `
      <div class="structure-details-column structure-details-column--primary">
        <p class="structure-details-empty structure-details-empty--standalone">No additional records found for this location.</p>
      </div>
      <div class="structure-details-column structure-details-column--tertiary">
        ${settlementArtwork}
      </div>
    `;
  }

  return {
    title: resolvedName,
    subtitle,
    body,
    history: historyContent
  };
}

function showStructureDetails(tile, context = {}) {
  hideStructureContextMenu();
  if (!elements.structureDetailsPanel) {
    return;
  }

  const content = buildStructureDetailsPanelContent(tile, context);
  if (!content) {
    hideStructureDetails();
    return;
  }

  structureDetailsState.visible = true;
  elements.structureDetailsPanel.classList.remove('hidden');
  elements.structureDetailsPanel.setAttribute('aria-hidden', 'false');

  if (elements.structureDetailsTitle) {
    elements.structureDetailsTitle.textContent = content.title || tile.structureName;
  }

  if (elements.structureDetailsSubtitle) {
    if (content.subtitle) {
      elements.structureDetailsSubtitle.textContent = content.subtitle;
      elements.structureDetailsSubtitle.classList.remove('hidden');
    } else {
      elements.structureDetailsSubtitle.textContent = '';
      elements.structureDetailsSubtitle.classList.add('hidden');
    }
  }

  structureDetailsState.tabContent = {
    main: content.main || content.body,
    history:
      content.history ||
      getStructureDetailsPlaceholder('No chronicles have been preserved for this settlement yet.'),
    features:
      content.features ||
      getStructureDetailsPlaceholder('No notable features have been recorded for this settlement yet.'),
    economy:
      content.economy ||
      getStructureDetailsPlaceholder('No economic records are available for this settlement yet.')
  };

  setActiveStructureDetailsTab('main', { force: true });

  playStructureAmbienceForTile(tile);

  if (elements.structureDetailsClose && typeof elements.structureDetailsClose.focus === 'function') {
    elements.structureDetailsClose.focus();
  }
}

function hideStructureDetails(options = {}) {
  hideStructureContextMenu();
  if (!elements.structureDetailsPanel) {
    return;
  }

  stopStructureAmbience();

  elements.structureDetailsPanel.classList.add('hidden');
  elements.structureDetailsPanel.setAttribute('aria-hidden', 'true');
  if (elements.structureDetailsContent) {
    elements.structureDetailsContent.innerHTML = '';
  }
  structureDetailsState.tabContent = {};
  setActiveStructureDetailsTab('main', { force: true, skipContent: true });
  structureDetailsState.visible = false;

  if (options.returnFocus && elements.canvasWrapper && typeof elements.canvasWrapper.focus === 'function') {
    elements.canvasWrapper.focus();
  }
}

function showMapTooltip(content, pointerX, pointerY, boundsRect) {
  if (!elements.mapTooltip) {
    return;
  }
  if (!content) {
    hideMapTooltip();
    return;
  }
  const tooltip = elements.mapTooltip;
  tooltip.innerHTML = content;
  tooltip.classList.add('visible');
  tooltip.setAttribute('aria-hidden', 'false');
  const margin = 16;
  const tooltipWidth = tooltip.offsetWidth || 0;
  const tooltipHeight = tooltip.offsetHeight || 0;
  const availableWidth = boundsRect ? boundsRect.width : tooltipWidth + margin * 2;
  const availableHeight = boundsRect ? boundsRect.height : tooltipHeight + margin * 2;

  let left = pointerX + margin;
  if (left + tooltipWidth > availableWidth - margin) {
    left = Math.max(margin, availableWidth - tooltipWidth - margin);
  }
  let top = pointerY - tooltipHeight - margin;
  if (top < margin) {
    top = pointerY + margin;
  }
  if (top + tooltipHeight > availableHeight - margin) {
    top = Math.max(margin, availableHeight - tooltipHeight - margin);
  }

  tooltip.style.left = `${Math.round(left)}px`;
  tooltip.style.top = `${Math.round(top)}px`;
}

function resetView(worldWidth, worldHeight) {
  if (!elements.canvasWrapper) {
    return;
  }
  const rect = elements.canvasWrapper.getBoundingClientRect();
  viewState.wrapperSize = { width: rect.width, height: rect.height };
  viewState.worldSize = { width: worldWidth, height: worldHeight };
  const { contain, cover } = computeViewScales(rect.width, rect.height, worldWidth, worldHeight);
  viewState.containScale = contain;
  viewState.coverScale = cover;
  viewState.minScale = Math.min(0.25, contain);
  viewState.maxScale = Math.max(6, cover * 4);
  viewState.scale = cover;
  viewState.translateX = (rect.width - worldWidth * viewState.scale) / 2;
  viewState.translateY = (rect.height - worldHeight * viewState.scale) / 2;
  viewState.hasInteracted = false;
  applyViewTransform();
  hideStructureDetails();
  hideMapTooltip();
  hideStructureContextMenu();
}

function handleResize() {
  if (!elements.canvasWrapper) {
    return;
  }
  const previousWidth = viewState.wrapperSize.width;
  const previousHeight = viewState.wrapperSize.height;
  const rect = elements.canvasWrapper.getBoundingClientRect();
  viewState.wrapperSize = { width: rect.width, height: rect.height };

  if (!viewState.worldSize.width || !viewState.worldSize.height) {
    applyViewTransform();
    return;
  }

  const { contain, cover } = computeViewScales(
    rect.width,
    rect.height,
    viewState.worldSize.width,
    viewState.worldSize.height
  );
  viewState.containScale = contain;
  viewState.coverScale = cover;
  viewState.minScale = Math.min(0.25, contain);
  viewState.maxScale = Math.max(6, cover * 4);

  if (!viewState.hasInteracted) {
    viewState.scale = cover;
    viewState.translateX = (rect.width - viewState.worldSize.width * viewState.scale) / 2;
    viewState.translateY = (rect.height - viewState.worldSize.height * viewState.scale) / 2;
  } else {
    const deltaX = (rect.width - previousWidth) / 2;
    const deltaY = (rect.height - previousHeight) / 2;
    if (Number.isFinite(deltaX)) {
      viewState.translateX += deltaX;
    }
    if (Number.isFinite(deltaY)) {
      viewState.translateY += deltaY;
    }
  }

  applyViewTransform();
  hideMapTooltip();
}

function setupMapInteractions() {
  if (!elements.canvasWrapper) {
    return;
  }

  let isPanning = false;
  let activePointerId = null;
  const lastPosition = { x: 0, y: 0 };
  const initialPosition = { x: 0, y: 0 };
  let pointerMovedDuringPan = false;
  let activePaintPointerId = null;
  const paintedTileCoords = new Set();

  const shouldUseMapEditor = () => {
    const mapEditor = ensureMapEditorState();
    if (!mapEditor.enabled) {
      return false;
    }
    const canPaintTerrain = mapEditor.applyTerrain && Boolean(mapEditor.terrainKey);
    const canPaintStructure = Boolean(mapEditor.applyStructure);
    return canPaintTerrain || canPaintStructure;
  };

  const paintAtPointer = (event) => {
    const resolved = resolveTileAtPointer(event);
    if (!resolved) {
      return;
    }
    const key = `${resolved.tileX},${resolved.tileY}`;
    if (paintedTileCoords.has(key)) {
      return;
    }
    paintedTileCoords.add(key);
    hideMapTooltip();
    applyMapEditorPaint(resolved.tileX, resolved.tileY);
  };

  const beginPainting = (event) => {
    activePaintPointerId = event.pointerId;
    paintedTileCoords.clear();
    if (elements.canvasWrapper && typeof elements.canvasWrapper.setPointerCapture === 'function') {
      elements.canvasWrapper.setPointerCapture(event.pointerId);
    }
    paintAtPointer(event);
  };

  const stopPainting = (event) => {
    if (activePaintPointerId === null) {
      return;
    }
    if (elements.canvasWrapper && typeof elements.canvasWrapper.releasePointerCapture === 'function') {
      try {
        elements.canvasWrapper.releasePointerCapture(activePaintPointerId);
      } catch (error) {
        // Ignore errors if the pointer capture has already been released.
      }
    }
    activePaintPointerId = null;
    paintedTileCoords.clear();
    if (event) {
      updateHover(event);
    }
  };

  const resolveTileAtPointer = (event) => {
    if (!elements.canvasWrapper) {
      return null;
    }
    const world = state.currentWorld;
    const tiles = world && Array.isArray(world.tiles) ? world.tiles : null;
    if (!tiles || tiles.length === 0) {
      return null;
    }
    const rect = elements.canvasWrapper.getBoundingClientRect();
    const pointerX = event.clientX - rect.left;
    const pointerY = event.clientY - rect.top;
    if (!Number.isFinite(pointerX) || !Number.isFinite(pointerY)) {
      return null;
    }
    if (pointerX < 0 || pointerY < 0 || pointerX > rect.width || pointerY > rect.height) {
      return null;
    }
    const worldPixelX = (pointerX - viewState.translateX) / viewState.scale;
    const worldPixelY = (pointerY - viewState.translateY) / viewState.scale;
    if (
      !Number.isFinite(worldPixelX) ||
      !Number.isFinite(worldPixelY) ||
      worldPixelX < 0 ||
      worldPixelY < 0 ||
      worldPixelX >= viewState.worldSize.width ||
      worldPixelY >= viewState.worldSize.height
    ) {
      return null;
    }
    const tileX = Math.floor(worldPixelX / drawSize);
    const tileY = Math.floor(worldPixelY / drawSize);
    if (tileY < 0 || tileY >= tiles.length) {
      return null;
    }
    const row = tiles[tileY];
    if (!Array.isArray(row) || tileX < 0 || tileX >= row.length) {
      return null;
    }
    const tile = row[tileX];
    if (!tile) {
      return null;
    }
    return { tile, tileX, tileY, pointerX, pointerY, rect };
  };

  const updateHover = (event) => {
    if (!elements.canvasWrapper) {
      return;
    }
    if (structureContextMenuState.visible) {
      return;
    }
    if (event.pointerType && event.pointerType !== 'mouse' && event.pointerType !== 'pen') {
      hideMapTooltip();
      return;
    }
    if (isPanning && event.pointerId === activePointerId) {
      hideMapTooltip();
      return;
    }
    const resolved = resolveTileAtPointer(event);
    if (!resolved) {
      hideMapTooltip();
      return;
    }
    const tooltipContent = buildStructureTooltipContent(resolved.tile);
    if (!tooltipContent) {
      hideMapTooltip();
      return;
    }
    showMapTooltip(tooltipContent, resolved.pointerX, resolved.pointerY, resolved.rect);
  };

  const handleWheel = (event) => {
    if (!elements.canvas) {
      return;
    }
    hideMapTooltip();
    hideStructureContextMenu();
    hideStructureDetails();
    event.preventDefault();
    const rect = elements.canvasWrapper.getBoundingClientRect();
    const pointerX = event.clientX - rect.left;
    const pointerY = event.clientY - rect.top;
    const zoomIntensity = 0.1;
    const direction = event.deltaY > 0 ? -1 : 1;
    const scaleFactor = 1 + zoomIntensity * direction;
    const targetScale = clamp(viewState.scale * scaleFactor, viewState.minScale, viewState.maxScale);
    const originX = (pointerX - viewState.translateX) / viewState.scale;
    const originY = (pointerY - viewState.translateY) / viewState.scale;
    viewState.scale = targetScale;
    viewState.translateX = pointerX - originX * viewState.scale;
    viewState.translateY = pointerY - originY * viewState.scale;
    viewState.hasInteracted = true;
    applyViewTransform();
  };

  const isMacLikePlatform =
    typeof navigator !== 'undefined' &&
    /Mac|iP(?:ad|hone|od)/.test((navigator.platform || navigator.userAgent || '').toString());

  const openStructureContextMenu = (event) => {
    hideMapTooltip();
    const resolved = resolveTileAtPointer(event);
    if (!resolved || !resolved.tile) {
      hideStructureContextMenu();
      return false;
    }
    showStructureContextMenu(resolved);
    return true;
  };

  const handlePointerDown = (event) => {
    if (activePointerId !== null || activePaintPointerId !== null) {
      return;
    }
    const menuElement = elements.structureContextMenu;
    const isPointerInsideMenu = Boolean(menuElement && menuElement.contains(event.target));
    if (isPointerInsideMenu) {
      return;
    }
    const pointerType = event.pointerType || 'mouse';
    const isTouchPointer = pointerType === 'touch';
    const isNonPrimaryButton = event.button !== undefined && event.button !== 0;
    const isMacCtrlClick =
      !isTouchPointer &&
      event.button === 0 &&
      event.ctrlKey &&
      isMacLikePlatform;
    const isContextMenuClick = !isTouchPointer && (isNonPrimaryButton || isMacCtrlClick);
    const isPrimaryPointer = !isContextMenuClick;
    hideStructureDetails();
    hideStructureContextMenu();
    if (!isPrimaryPointer) {
      if (openStructureContextMenu(event)) {
        event.preventDefault();
      }
      return;
    }
    hideMapTooltip();
    if (shouldUseMapEditor()) {
      const resolved = resolveTileAtPointer(event);
      if (resolved) {
        event.preventDefault();
        beginPainting(event);
      }
      return;
    }
    event.preventDefault();
    isPanning = true;
    activePointerId = event.pointerId;
    lastPosition.x = event.clientX;
    lastPosition.y = event.clientY;
    initialPosition.x = event.clientX;
    initialPosition.y = event.clientY;
    pointerMovedDuringPan = false;
    elements.canvasWrapper.setPointerCapture(event.pointerId);
  };

  const handlePointerMove = (event) => {
    if (activePaintPointerId !== null && event.pointerId === activePaintPointerId) {
      event.preventDefault();
      if (shouldUseMapEditor()) {
        paintAtPointer(event);
      } else {
        stopPainting(event);
      }
      return;
    }
    updateHover(event);
    if (!isPanning || event.pointerId !== activePointerId) {
      return;
    }
    event.preventDefault();
    const dx = event.clientX - lastPosition.x;
    const dy = event.clientY - lastPosition.y;
    if (!pointerMovedDuringPan) {
      const totalDx = event.clientX - initialPosition.x;
      const totalDy = event.clientY - initialPosition.y;
      const distance = Math.hypot(totalDx, totalDy);
      if (distance > 3) {
        pointerMovedDuringPan = true;
      }
    }
    lastPosition.x = event.clientX;
    lastPosition.y = event.clientY;
    viewState.translateX += dx;
    viewState.translateY += dy;
    viewState.hasInteracted = true;
    applyViewTransform();
  };

  const handlePointerUp = (event) => {
    if (event.pointerId === activePaintPointerId) {
      stopPainting(event);
      return;
    }
    const wasActivePointer = event.pointerId === activePointerId;
    if (wasActivePointer) {
      elements.canvasWrapper.releasePointerCapture(event.pointerId);
      isPanning = false;
      activePointerId = null;
      if (!pointerMovedDuringPan) {
        const resolved = resolveTileAtPointer(event);
        if (resolved) {
          showLocalViewAt(resolved.tileX, resolved.tileY);
        }
      } else {
        updateHover(event);
      }
      return;
    }
    updateHover(event);
  };

  const handlePointerLeave = (event) => {
    hideMapTooltip();
    hideStructureContextMenu();
    if (activePaintPointerId !== null) {
      stopPainting(event);
    }
  };

  const handleDoubleClick = (event) => {
    if (!viewState.worldSize.width || !viewState.worldSize.height) {
      return;
    }

    if (typeof event?.preventDefault === 'function') {
      event.preventDefault();
    }

    const resolved = resolveTileAtPointer(event);
    if (resolved && resolved.tile) {
      const { tile, tileX, tileY } = resolved;
      const enrichedTile = resolveTileForContextMenu(tile, tileX, tileY) || tile;
      const details = enrichedTile?.structureDetails || null;
      const detailType = typeof details?.type === 'string' ? details.type : null;
      const isSettlement =
        (details && details.isSettlement === true) ||
        (detailType ? settlementDetailTypes.has(detailType) : false);
          const resolvedName =
        (typeof enrichedTile?.structureName === 'string' && enrichedTile.structureName) ||
        (typeof details?.name === 'string' ? details.name : null);

      if (isSettlement && resolvedName) {
        const tileWithName =
          enrichedTile && enrichedTile.structureName === resolvedName
            ? enrichedTile
            : { ...enrichedTile, structureName: resolvedName };
        hideStructureContextMenu();
        hideLocalView({ suppressRedraw: true });
        showStructureDetails(tileWithName, { tileX, tileY });
        return;
      }
    }

    hideStructureContextMenu();
    hideStructureDetails();
    resetView(viewState.worldSize.width, viewState.worldSize.height);
  };

  const handleContextMenu = (event) => {
    event.preventDefault();
    openStructureContextMenu(event);
  };

  elements.canvasWrapper.addEventListener('wheel', handleWheel, { passive: false });
  elements.canvasWrapper.addEventListener('pointerdown', handlePointerDown);
  elements.canvasWrapper.addEventListener('pointermove', handlePointerMove);
  elements.canvasWrapper.addEventListener('pointerup', handlePointerUp);
  elements.canvasWrapper.addEventListener('pointercancel', handlePointerUp);
  elements.canvasWrapper.addEventListener('pointerenter', updateHover);
  elements.canvasWrapper.addEventListener('pointerleave', handlePointerLeave);
  elements.canvasWrapper.addEventListener('contextmenu', handleContextMenu);
  elements.canvasWrapper.addEventListener('dblclick', handleDoubleClick);
  window.addEventListener('resize', handleResize);
}

function updateMusicToggleLabel() {
  const toggles = getMusicToggleElements();
  if (toggles.length === 0) {
    return;
  }
  const label = audioState.isPlaying ? 'Pause Music' : 'Play Music';
  toggles.forEach((toggle) => {
    toggle.textContent = label;
    toggle.setAttribute('aria-pressed', audioState.isPlaying.toString());
  });
}

function updateNowPlaying() {
  if (!audioState.tracks.length) {
    return;
  }
  const track = audioState.tracks[audioState.currentIndex];
  const displays = getMusicNowPlayingDisplays();
  if (displays.length === 0) {
    return;
  }
  const message = audioState.isPlaying
    ? `Now playing: ${track.title}`
    : `Ready: ${track.title}`;
  displays.forEach((display) => {
    display.textContent = message;
  });
}

function loadTrack(index) {
  if (!elements.audioElement || !audioState.tracks.length) {
    return;
  }
  const trackCount = audioState.tracks.length;
  const normalizedIndex = ((index % trackCount) + trackCount) % trackCount;
  audioState.currentIndex = normalizedIndex;
  const track = audioState.tracks[normalizedIndex];
  const encodedSrc = encodeURI(track.src);
  elements.audioElement.src = encodedSrc;
  elements.audioElement.load();
  audioState.initialised = true;
  updateNowPlaying();
}

function attemptPlay() {
  if (!elements.audioElement) {
    return Promise.resolve();
  }
  const playPromise = elements.audioElement.play();
  if (playPromise && typeof playPromise.then === 'function') {
    return playPromise
      .then(() => {
        audioState.isPlaying = true;
        updateMusicToggleLabel();
        updateNowPlaying();
      })
      .catch((error) => {
        console.warn('Music playback prevented:', error);
        audioState.isPlaying = false;
        updateMusicToggleLabel();
        updateNowPlaying();
      });
  }
  audioState.isPlaying = true;
  updateMusicToggleLabel();
  updateNowPlaying();
  return Promise.resolve();
}

function playNextTrack() {
  if (!audioState.tracks.length) {
    return;
  }
  const nextIndex = (audioState.currentIndex + 1) % audioState.tracks.length;
  loadTrack(nextIndex);
  attemptPlay();
}

function ensureMusicStarted() {
  if (!elements.audioElement || getMusicToggleElements().length === 0) {
    return;
  }
  if (!audioState.initialised) {
    loadTrack(audioState.currentIndex);
  }
  attemptPlay();
}

function setupAudioControls() {
  if (!elements.audioElement) {
    return;
  }

  const volumeInputs = getMusicVolumeInputs();
  const toggles = getMusicToggleElements();
  if (toggles.length === 0 && volumeInputs.length === 0) {
    return;
  }

  const initialVolumeSource = volumeInputs[0];
  const parsedInputVolume = initialVolumeSource ? Number.parseFloat(initialVolumeSource.value) : Number.NaN;
  const fallbackVolume = Number.isNaN(parsedInputVolume) ? elements.audioElement.volume : parsedInputVolume;
  const initialVolume = clamp(Number.isNaN(fallbackVolume) ? 0.5 : fallbackVolume, 0, 1);
  elements.audioElement.volume = initialVolume;
  volumeInputs.forEach((input) => {
    input.value = initialVolume.toString();
  });

  const handleVolumeInput = (event) => {
    const newVolume = clamp(parseFloat(event.target.value), 0, 1);
    const resolvedVolume = Number.isNaN(newVolume) ? elements.audioElement.volume : newVolume;
    elements.audioElement.volume = resolvedVolume;
    volumeInputs.forEach((input) => {
      if (input !== event.target) {
        input.value = resolvedVolume.toString();
      }
    });
  };

  volumeInputs.forEach((input) => {
    input.addEventListener('input', handleVolumeInput);
  });

  const handleToggle = () => {
    if (!audioState.initialised) {
      loadTrack(audioState.currentIndex);
    }
    if (audioState.isPlaying) {
      elements.audioElement.pause();
      audioState.isPlaying = false;
      updateMusicToggleLabel();
      updateNowPlaying();
    } else {
      attemptPlay();
    }
  };

  toggles.forEach((toggle) => {
    toggle.addEventListener('click', handleToggle);
    toggle.setAttribute('aria-pressed', audioState.isPlaying.toString());
  });

  loadTrack(audioState.currentIndex);
  updateMusicToggleLabel();
  updateNowPlaying();

  elements.audioElement.addEventListener('ended', () => {
    audioState.isPlaying = false;
    playNextTrack();
  });

  elements.audioElement.addEventListener('play', () => {
    audioState.isPlaying = true;
    updateMusicToggleLabel();
    updateNowPlaying();
  });

  elements.audioElement.addEventListener('pause', () => {
    audioState.isPlaying = false;
    updateMusicToggleLabel();
    updateNowPlaying();
  });

  elements.audioElement.addEventListener('error', () => {
    console.error('Failed to play track, skipping to next.');
    audioState.isPlaying = false;
    playNextTrack();
  });
}

function updateSoundEffectsToggleLabel() {
  if (elements.sfxToggle) {
    const enabled = !audioState.effectsMuted;
    elements.sfxToggle.textContent = enabled ? 'Sound Effects On' : 'Sound Effects Off';
    elements.sfxToggle.setAttribute('aria-pressed', enabled.toString());
  }
  if (elements.sfxVolume) {
    elements.sfxVolume.disabled = audioState.effectsMuted;
    elements.sfxVolume.setAttribute('aria-disabled', audioState.effectsMuted.toString());
  }
  const finalVolume = audioState.effectsMuted ? 0 : clamp(audioState.effectsVolume, 0, 1);
  Object.values(soundEffects).forEach((audio) => {
    if (audio) {
      audio.volume = finalVolume;
    }
  });
  updateStructureAmbienceVolume();
}

function setupSoundEffectControls() {
  if (!elements.sfxToggle && !elements.sfxVolume) {
    return;
  }

  if (elements.sfxVolume) {
    const initialVolume = clamp(
      parseFloat(elements.sfxVolume.value) || audioState.effectsVolume,
      0,
      1
    );
    audioState.effectsVolume = initialVolume;
    elements.sfxVolume.value = initialVolume.toString();
    elements.sfxVolume.addEventListener('input', (event) => {
      const newVolume = clamp(parseFloat(event.target.value), 0, 1);
      if (Number.isNaN(newVolume)) {
        return;
      }
      audioState.effectsVolume = newVolume;
      if (newVolume > 0 && audioState.effectsMuted) {
        audioState.effectsMuted = false;
      }
      updateSoundEffectsToggleLabel();
    });
  }

  if (elements.sfxToggle) {
    elements.sfxToggle.addEventListener('click', () => {
      audioState.effectsMuted = !audioState.effectsMuted;
      updateSoundEffectsToggleLabel();
    });
  }

  updateSoundEffectsToggleLabel();
}

function loadImage(src) {
  const img = new Image();
  img.src = src;
  img.decoding = 'async';
  if (img.decode) {
    return img.decode().then(() => img);
  }
  return new Promise((resolve, reject) => {
    img.onload = () => resolve(img);
    img.onerror = reject;
  });
}

function stringToSeed(str) {
  if (!str) {
    return Math.floor(Math.random() * 0xffffffff);
  }
  let hash = 2166136261;
  for (let i = 0; i < str.length; i += 1) {
    hash ^= str.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  return hash >>> 0;
}

function mulberry32(a) {
  return function rng() {
    let t = (a += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function hashCoords(x, y, seed) {
  let h = Math.imul(x, 374761393) ^ Math.imul(y, 668265263) ^ seed;
  h = Math.imul(h ^ (h >>> 13), 1274126177);
  return ((h ^ (h >>> 16)) >>> 0) / 4294967295;
}

function fade(t) {
  return t * t * t * (t * (t * 6 - 15) + 10);
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function sampleLandMask(normalizedX, normalizedY) {
  return sampleMaskValue(state.landMask, normalizedX, normalizedY);
}

function valueNoise(x, y, seed) {
  const x0 = Math.floor(x);
  const y0 = Math.floor(y);
  const x1 = x0 + 1;
  const y1 = y0 + 1;
  const sx = fade(x - x0);
  const sy = fade(y - y0);

  const n00 = hashCoords(x0, y0, seed);
  const n10 = hashCoords(x1, y0, seed);
  const n01 = hashCoords(x0, y1, seed);
  const n11 = hashCoords(x1, y1, seed);

  const ix0 = lerp(n00, n10, sx);
  const ix1 = lerp(n01, n11, sx);
  return lerp(ix0, ix1, sy);
}

function createProceduralMask(width, height, sampler) {
  const data = new Float32Array(width * height);
  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const nx = (x + 0.5) / width;
      const ny = (y + 0.5) / height;
      const value = sampler(nx, ny);
      data[y * width + x] = clamp(value, 0, 1);
    }
  }
  return { width, height, data };
}

function sampleMaskValue(mask, normalizedX, normalizedY) {
  if (
    !mask ||
    !mask.data ||
    !Number.isFinite(mask.width) ||
    !Number.isFinite(mask.height) ||
    mask.width <= 1 ||
    mask.height <= 1
  ) {
    return null;
  }

  const clampedX = clamp(normalizedX, 0, 1);
  const clampedY = clamp(normalizedY, 0, 1);
  const scaledX = clampedX * (mask.width - 1);
  const scaledY = clampedY * (mask.height - 1);

  const x0 = Math.floor(scaledX);
  const y0 = Math.floor(scaledY);
  const x1 = Math.min(x0 + 1, mask.width - 1);
  const y1 = Math.min(y0 + 1, mask.height - 1);
  const tx = scaledX - x0;
  const ty = scaledY - y0;

  const idx00 = y0 * mask.width + x0;
  const idx10 = y0 * mask.width + x1;
  const idx01 = y1 * mask.width + x0;
  const idx11 = y1 * mask.width + x1;

  const top = lerp(mask.data[idx00], mask.data[idx10], tx);
  const bottom = lerp(mask.data[idx01], mask.data[idx11], tx);
  return lerp(top, bottom, ty);
}

function createTwinContinentsMask() {
  const size = 512;
  return createProceduralMask(size, size, (nx, ny) => {
    const left = Math.hypot((nx - 0.32) / 0.55, (ny - 0.48) / 0.33);
    const right = Math.hypot((nx - 0.68) / 0.55, (ny - 0.52) / 0.33);
    let value = 1 - Math.min(left, right);
    value = Math.pow(clamp(value, 0, 1), 0.82);
    const saddle = Math.cos((ny - 0.5) * Math.PI * 2.2) * 0.05;
    const noise = (valueNoise(nx * 12.5 + 3.1, ny * 12.5 + 7.9, 0x9e3779b) - 0.5) * 0.12;
    const detail = (valueNoise(nx * 34.2 + 11.3, ny * 34.2 + 4.6, 0x85ebca6) - 0.5) * 0.06;
    value += saddle + noise + detail;
    return value;
  });
}

function createInlandSeaMask() {
  const size = 512;
  return createProceduralMask(size, size, (nx, ny) => {
    const ellipseFalloff = (cx, cy, rx, ry, power = 1.2) => {
      const dx = (nx - cx) / rx;
      const dy = (ny - cy) / ry;
      const distance = dx * dx + dy * dy;
      const falloff = clamp(1 - distance, 0, 1);
      return Math.pow(falloff, power);
    };

    const mainBasin = ellipseFalloff(0.55, 0.55, 0.36, 0.18, 1.1);
    const westernBasin = ellipseFalloff(0.32, 0.54, 0.17, 0.14, 1.1);
    const easternBasin = ellipseFalloff(0.76, 0.54, 0.18, 0.14, 1.15);
    const aegeanBasin = ellipseFalloff(0.8, 0.61, 0.12, 0.13, 1.2);
    const adriaticBasin = ellipseFalloff(0.6, 0.4, 0.1, 0.2, 1.35);
    const levantBasin = ellipseFalloff(0.83, 0.63, 0.12, 0.12, 1.25);

    let seaValue = Math.max(
      mainBasin,
      westernBasin,
      easternBasin,
      aegeanBasin,
      adriaticBasin,
      levantBasin
    );

    const saharaRidge = ellipseFalloff(0.55, 0.73, 0.5, 0.16, 1.6);
    const anatoliaRidge = ellipseFalloff(0.77, 0.42, 0.26, 0.14, 1.4);
    const italianRidge = ellipseFalloff(0.56, 0.45, 0.12, 0.22, 1.3);
    seaValue -= (saharaRidge + anatoliaRidge + italianRidge) * 0.25;

    const coastlineNoise =
      (valueNoise(nx * 8.5 + 2.1, ny * 8.5 + 3.4, 0x6c8e9cf) - 0.5) * 0.18;
    const detailNoise =
      (valueNoise(nx * 24.5 + 8.7, ny * 24.5 + 1.9, 0x51a7f5d) - 0.5) * 0.08;
    seaValue = clamp(seaValue + coastlineNoise + detailNoise, 0, 1);

    const edgeDistance = Math.min(nx, 1 - nx, ny, 1 - ny);
    const edgeLand = clamp(1 - edgeDistance / 0.12, 0, 1);

    let landValue = 1 - seaValue;
    landValue = Math.max(landValue, edgeLand);
    landValue = clamp(landValue + 0.05, 0, 1);
    return landValue;
  });
}

function createArchipelagoMask() {
  const size = 512;
  return createProceduralMask(size, size, (nx, ny) => {
    const gridSize = 6;
    const spacing = 1 / gridSize;
    const islands = [];

    for (let gx = 0; gx < gridSize; gx += 1) {
      for (let gy = 0; gy < gridSize; gy += 1) {
        const sampleX = (gx + 0.37) * 2.17;
        const sampleY = (gy + 0.63) * 2.03;
        const activation = valueNoise(sampleX, sampleY, 0x9e3779b9);
        if (activation <= 0.42) {
          continue;
        }

        const offsetSeedX = valueNoise(sampleX + 4.91, sampleY - 6.44, 0xc2b2ae35) - 0.5;
        const offsetSeedY = valueNoise(sampleX - 7.73, sampleY + 3.57, 0x165667b1) - 0.5;
        const centerX = clamp(
          (gx + 0.5) * spacing + offsetSeedX * spacing * 0.45,
          0.04,
          0.96
        );
        const centerY = clamp(
          (gy + 0.5) * spacing + offsetSeedY * spacing * 0.45,
          0.04,
          0.96
        );

        const radiusSeed = valueNoise(sampleX + 3.11, sampleY + 5.81, 0x27d4eb2f);
        const radiusX = spacing * (0.26 + activation * 0.3 + radiusSeed * 0.1);
        const radiusY = spacing * (0.24 + activation * 0.28 + (1 - radiusSeed) * 0.12);
        const height = 0.6 + activation * 0.65;
        const power = 1.25 + valueNoise(sampleX - 2.48, sampleY + 8.92, 0x85ebca77) * 0.55;
        const lobeCount =
          2 + Math.floor(valueNoise(sampleX - 9.17, sampleY + 2.41, 0x94d049bb) * 6.6);
        const lobeStrength =
          0.11 + valueNoise(sampleX + 5.19, sampleY + 1.77, 0x748f82ee) * 0.32;
        const lobePhase =
          valueNoise(sampleX - 2.63, sampleY + 4.82, 0x510e527f) * Math.PI * 2;
        const subLobeCount =
          lobeCount * 2 +
          Math.floor(valueNoise(sampleX + 8.41, sampleY - 3.76, 0xbf58476d) * 4.6);
        const subLobeStrength =
          0.045 + valueNoise(sampleX - 1.28, sampleY + 9.11, 0x3bd39e10) * 0.13;
        const subLobePhase =
          valueNoise(sampleX + 6.73, sampleY + 2.19, 0x2545f491) * Math.PI * 2;
        const ridgeStrength =
          0.035 + valueNoise(sampleX * 1.9 + 3.13, sampleY * 1.9 - 4.77, 0x13198a2e) * 0.18;
        const ridgePhase =
          valueNoise(sampleX * 2.4 - 5.61, sampleY * 2.4 + 8.37, 0x243f6a88) * Math.PI * 2;
        const ridgeSeed =
          Math.floor(valueNoise(sampleX * 3.7 + 1.91, sampleY * 3.7 - 7.42, 0x9e3779b9) * 0xffffffff) >>> 0;
        const fractureStrength =
          0.03 + valueNoise(sampleX * 1.7 - 4.22, sampleY * 1.7 + 5.94, 0xbb67ae85) * 0.12;
        const fracturePhase =
          valueNoise(sampleX * 2.1 + 7.38, sampleY * 2.1 - 6.57, 0x6c44198c) * Math.PI * 2;
        const fractureSeed =
          Math.floor(valueNoise(sampleX * 4.2 - 2.63, sampleY * 4.2 + 3.41, 0x3243f6a9) * 0xffffffff) >>> 0;

        islands.push({
          x: centerX,
          y: centerY,
          radiusX,
          radiusY,
          height,
          power,
          lobeCount,
          lobeStrength,
          lobePhase,
          subLobeCount,
          subLobeStrength,
          subLobePhase,
          ridgeStrength,
          ridgePhase,
          ridgeSeed,
          fractureStrength,
          fracturePhase,
          fractureSeed
        });
      }
    }

    let sum = 0;
    for (let i = 0; i < islands.length; i += 1) {
      const island = islands[i];
      const dx = nx - island.x;
      const dy = ny - island.y;
      const baseDistance = Math.sqrt(
        (dx * dx) / (island.radiusX * island.radiusX) +
          (dy * dy) / (island.radiusY * island.radiusY)
      );
      const angle = Math.atan2(dy, dx);
      const edgeBlend = clamp(1 - Math.min(baseDistance, 1.6) * 0.55, 0, 1);
      const lobeWarp =
        Math.sin(angle * island.lobeCount + island.lobePhase) * island.lobeStrength * edgeBlend;
      const subLobeWarp =
        Math.sin(angle * island.subLobeCount + island.subLobePhase) *
        island.subLobeStrength *
        edgeBlend;
      const ridgeNoise =
        (valueNoise(
          Math.cos(angle + island.ridgePhase) * 3.3 + baseDistance * 1.4,
          Math.sin(angle + island.ridgePhase) * 3.3 + baseDistance * 1.4,
          island.ridgeSeed
        ) -
          0.5) *
        island.ridgeStrength *
        edgeBlend;
      const fractureNoise =
        (valueNoise(
          Math.cos(angle * 0.6 + island.fracturePhase) * 4.6 + baseDistance * 2.1,
          Math.sin(angle * 0.6 + island.fracturePhase) * 4.6 + baseDistance * 2.1,
          island.fractureSeed
        ) -
          0.5) *
        island.fractureStrength *
        edgeBlend;
      const warpedDistance = baseDistance - lobeWarp - subLobeWarp - ridgeNoise - fractureNoise;
      const distance = warpedDistance < 0 ? 0 : warpedDistance;
      let influence = clamp(1 - distance, 0, 1);
      influence = Math.pow(influence, island.power) * island.height;
      sum += influence;
    }

    const jagged = (valueNoise(nx * 22.5 + 4.7, ny * 22.5 + 9.1, 0x3c6ef372) - 0.5) * 0.38;
    const detail = (valueNoise(nx * 48.1 + 12.5, ny * 48.1 + 3.8, 0xa54ff53a) - 0.5) * 0.24;
    const micro = (valueNoise(nx * 86.3 + 6.2, ny * 86.3 + 14.4, 0x510e527f) - 0.5) * 0.12;
    const scatter = Math.max(
      0,
      valueNoise(nx * 11.7 + 1.6, ny * 11.7 + 7.4, 0x51eb851f) - 0.63
    ) * 0.32;

    let value = sum * 0.58 + jagged + detail + micro + scatter;

    const edge = Math.min(nx, 1 - nx, ny, 1 - ny);
    value -= clamp(0.22 - edge, 0, 0.22) * 3.6;
    value -= 0.52;
    return value;
  });
}

function createArchipelagoIslandDefinition({
  rng,
  width,
  height,
  minRadius,
  maxRadius,
  islandSeed,
  centerNormX,
  centerNormY,
  orientation,
  clusterIntensity,
  maskSample,
  radiusBaseRange,
  sizeScale
}) {
  const centerX = centerNormX * width;
  const centerY = centerNormY * height;

  const radiusBaseMin = Math.max(
    3,
    Math.floor(
      radiusBaseRange && Number.isFinite(radiusBaseRange.min)
        ? radiusBaseRange.min
        : minRadius
    )
  );
  const radiusBaseMax = Math.max(
    radiusBaseMin,
    Math.floor(
      radiusBaseRange && Number.isFinite(radiusBaseRange.max)
        ? radiusBaseRange.max
        : maxRadius
    )
  );
  const radiusBase =
    radiusBaseMax <= radiusBaseMin
      ? radiusBaseMin
      : Math.floor(rng() * (radiusBaseMax - radiusBaseMin + 1)) + radiusBaseMin;

  const effectiveSizeScale = sizeScale !== undefined ? sizeScale : 1;
  const sizeMultiplier = Math.max(0.1, (0.7 + maskSample * 0.9) * effectiveSizeScale);
  const radius = Math.max(3, Math.floor(radiusBase * sizeMultiplier));
  const aspect = 0.55 + rng() * 1.15;
  let majorRadius = Math.max(radius, 3);
  let minorRadius = Math.max(majorRadius * aspect, 3);
  if (rng() < 0.5) {
    const swap = majorRadius;
    majorRadius = minorRadius;
    minorRadius = swap;
  }

  const cosRotation = Math.cos(orientation);
  const sinRotation = Math.sin(orientation);
  const falloffPower = 1.15 + rng() * 1.5 - clusterIntensity * 0.35;
  const shelfStrength = 0.28 + rng() * 0.32 + maskSample * 0.25;
  const peakHeight = 0.52 + rng() * 0.42 + maskSample * 0.35;
  const coastlineRoughness = 0.24 + rng() * 0.26 + (1 - clusterIntensity) * 0.18;
  const turbulenceStrength = 0.26 + rng() * 0.34 + maskSample * 0.2;
  const noiseScale = 3.8 + rng() * 5.8;
  const tectonicStrength = 0.32 + rng() * 0.42 + maskSample * 0.35;
  const lobeCount = 2 + Math.floor(rng() * 7);
  const lobePhase = rng() * Math.PI * 2;
  const lobeStrength = 0.12 + rng() * 0.22 + (clusterIntensity - 0.6) * 0.18;
  const rippleCount = lobeCount * 2 + Math.floor(rng() * 5);
  const ripplePhase = rng() * Math.PI * 2;
  const rippleStrength = 0.045 + rng() * 0.085 + (1 - clusterIntensity) * 0.045;
  const ridgeStrength = 0.035 + rng() * 0.1 + maskSample * 0.08;
  const ridgePhase = rng() * Math.PI * 2;
  const ridgeSeed = (islandSeed ^ 0x27d4eb2f) >>> 0;
  const fractureStrength = 0.04 + rng() * 0.12 + (1 - maskSample) * 0.06;
  const fracturePhase = rng() * Math.PI * 2;
  const fractureSeed = (islandSeed ^ 0xbb67ae85) >>> 0;
  const radialNoiseSeed = (islandSeed ^ 0xc4ceb9fe) >>> 0;
  const radialNoiseStrength = 0.07 + rng() * 0.09 + maskSample * 0.08;
  const radialNoisePhase = rng() * Math.PI * 2;
  const radialNoiseFrequency = 2.2 + rng() * 2.6;

  const influenceRadiusX = majorRadius * 1.7;
  const influenceRadiusY = minorRadius * 1.7;
  const approxRadius = Math.max(majorRadius / width, minorRadius / height);

  return {
    centerX,
    centerY,
    centerNormX,
    centerNormY,
    majorRadius,
    minorRadius,
    cosRotation,
    sinRotation,
    falloffPower,
    shelfStrength,
    peakHeight,
    coastlineRoughness,
    turbulenceStrength,
    noiseScale,
    tectonicStrength,
    lobeCount,
    lobePhase,
    lobeStrength,
    rippleCount,
    ripplePhase,
    rippleStrength,
    ridgeStrength,
    ridgePhase,
    ridgeSeed,
    fractureStrength,
    fracturePhase,
    fractureSeed,
    radialNoiseSeed,
    radialNoiseStrength,
    radialNoisePhase,
    radialNoiseFrequency,
    influenceRadiusX,
    influenceRadiusY,
    islandSeed,
    maskSample,
    approxRadius,
    clusterIntensity
  };
}

function applyArchipelagoIslandDefinition(island, width, height, heights, tectonics) {
  const {
    centerX,
    centerY,
    majorRadius,
    minorRadius,
    cosRotation,
    sinRotation,
    influenceRadiusX,
    influenceRadiusY,
    falloffPower,
    shelfStrength,
    peakHeight,
    coastlineRoughness,
    turbulenceStrength,
    noiseScale,
    tectonicStrength,
    lobeCount,
    lobePhase,
    lobeStrength,
    rippleCount,
    ripplePhase,
    rippleStrength,
    ridgeStrength,
    ridgePhase,
    ridgeSeed,
    fractureStrength,
    fracturePhase,
    fractureSeed,
    radialNoiseSeed,
    radialNoiseStrength,
    radialNoisePhase,
    radialNoiseFrequency,
    islandSeed,
    maskSample
  } = island;

  const minX = Math.max(0, Math.floor(centerX - influenceRadiusX));
  const maxX = Math.min(width - 1, Math.ceil(centerX + influenceRadiusX));
  const minY = Math.max(0, Math.floor(centerY - influenceRadiusY));
  const maxY = Math.min(height - 1, Math.ceil(centerY + influenceRadiusY));

  for (let y = minY; y <= maxY; y += 1) {
    for (let x = minX; x <= maxX; x += 1) {
      const offsetX = (x + 0.5 - centerX) / majorRadius;
      const offsetY = (y + 0.5 - centerY) / minorRadius;
      const rotatedX = offsetX * cosRotation - offsetY * sinRotation;
      const rotatedY = offsetX * sinRotation + offsetY * cosRotation;
      const distance = Math.sqrt(rotatedX * rotatedX + rotatedY * rotatedY);
      if (distance > 1.9) {
        continue;
      }

      const normalizedX = (x + 0.5) / width;
      const normalizedY = (y + 0.5) / height;
      const angle = Math.atan2(rotatedY, rotatedX);
      const edgeBlend = clamp(1 - Math.min(distance, 1.6) * 0.65, 0, 1);
      const harmonicWarp =
        (Math.sin(angle * lobeCount + lobePhase) * lobeStrength +
          Math.sin(angle * rippleCount + ripplePhase) * rippleStrength) *
        edgeBlend;
      const radialNoise =
        (valueNoise(
          (normalizedX + islandSeed * 0.000021) * (noiseScale * 0.55) +
            Math.cos(angle + radialNoisePhase) * radialNoiseFrequency,
          (normalizedY + islandSeed * 0.000021) * (noiseScale * 0.55) +
            Math.sin(angle + radialNoisePhase) * radialNoiseFrequency,
          radialNoiseSeed
        ) -
          0.5) *
        radialNoiseStrength *
        edgeBlend;
      const angularWarp = clamp(
        harmonicWarp + radialNoise,
        -0.36,
        0.24 + maskSample * 0.06
      );
      const ridgeNoise =
        (valueNoise(
          (normalizedX + islandSeed * 0.00013) * 9.1 + Math.cos(angle + ridgePhase) * 3.1,
          (normalizedY + islandSeed * 0.00013) * 9.1 + Math.sin(angle + ridgePhase) * 3.1,
          ridgeSeed
        ) -
          0.5) *
        ridgeStrength *
        edgeBlend;
      const fractureNoise =
        (valueNoise(
          (normalizedX + islandSeed * 0.000091) * 13.2 +
            Math.cos(angle * 0.65 + fracturePhase) * 4.5,
          (normalizedY + islandSeed * 0.000091) * 13.2 +
            Math.sin(angle * 0.65 + fracturePhase) * 4.5,
          fractureSeed
        ) -
          0.5) *
        fractureStrength *
        edgeBlend;
      const warpedDistance = distance - angularWarp - ridgeNoise - fractureNoise;
      if (warpedDistance > 1.6) {
        continue;
      }

      const coastlineNoise =
        valueNoise(
          (normalizedX + islandSeed * 0.0000153) * noiseScale,
          (normalizedY + islandSeed * 0.0000271) * noiseScale,
          islandSeed
        ) - 0.5;
      const coastalWarp = coastlineNoise * coastlineRoughness;
      const adjustedDistance = warpedDistance - coastalWarp;
      if (adjustedDistance > 1.2) {
        continue;
      }

      const influence = clamp(1 - adjustedDistance, 0, 1);
      if (influence <= 0) {
        continue;
      }

      const shaped = Math.pow(influence, falloffPower);
      const beach = clamp((influence - 0.35) / 0.65, 0, 1) * shelfStrength;
      const turbulence =
        (valueNoise(
          (normalizedX + islandSeed * 0.000042) * (noiseScale * 0.7),
          (normalizedY + islandSeed * 0.000058) * (noiseScale * 0.7),
          islandSeed ^ 0x85ebca6b
        ) -
          0.5) *
        turbulenceStrength;
      const heightContribution = shaped * peakHeight + beach + turbulence;
      const idx = y * width + x;

      if (heightContribution > heights[idx]) {
        heights[idx] = heightContribution;
      }

      const tectonicContribution = shaped * tectonicStrength;
      if (tectonicContribution > tectonics[idx]) {
        tectonics[idx] = tectonicContribution;
      }
    }
  }
}

function generateArchipelagoIslandFields(width, height, rng, seedNumber) {
  const total = width * height;
  const heights = new Float32Array(total);
  const tectonics = new Float32Array(total);
  const minIslands = 20;
  const maxIslands = 100;
  const islandCount = Math.max(
    minIslands,
    Math.floor(rng() * (maxIslands - minIslands + 1)) + minIslands
  );
  const minDimension = Math.min(width, height);
  const minRadius = Math.max(3, Math.floor(minDimension * 0.03));
  const maxRadius = Math.max(minRadius + 2, Math.floor(minDimension * 0.12));
  const baseSeed = (seedNumber + 0x243f6a88) >>> 0;

  const mask = createArchipelagoMask();
  const sampleMask = mask
    ? (nx, ny) => {
        const sample = sampleMaskValue(mask, nx, ny);
        return sample === null ? 0 : sample;
      }
    : () => 0;

  const clusterCandidates = [];
  if (mask) {
    const clusterGrid = 28;
    const epsilonX = 1 / (mask.width * 1.5);
    const epsilonY = 1 / (mask.height * 1.5);
    for (let gx = 0; gx < clusterGrid; gx += 1) {
      for (let gy = 0; gy < clusterGrid; gy += 1) {
        const nx = (gx + 0.5) / clusterGrid;
        const ny = (gy + 0.5) / clusterGrid;
        const intensity = sampleMask(nx, ny);
        if (intensity <= 0.55) {
          continue;
        }
        const gx1 = sampleMask(clamp(nx + epsilonX, 0, 1), ny);
        const gx0 = sampleMask(clamp(nx - epsilonX, 0, 1), ny);
        const gy1 = sampleMask(nx, clamp(ny + epsilonY, 0, 1));
        const gy0 = sampleMask(nx, clamp(ny - epsilonY, 0, 1));
        const gradX = gx1 - gx0;
        const gradY = gy1 - gy0;
        let orientation = 0;
        const magnitude = Math.hypot(gradX, gradY);
        if (magnitude < 1e-5) {
          orientation = rng() * Math.PI * 2;
        } else {
          orientation = Math.atan2(gradY, gradX) + Math.PI * 0.5;
        }
        clusterCandidates.push({
          x: nx,
          y: ny,
          intensity,
          orientation
        });
      }
    }
  }

  clusterCandidates.sort((a, b) => b.intensity - a.intensity);
  const maxClusters = 72;
  const clusters = clusterCandidates.slice(0, maxClusters);

  const pickCluster = () => {
    if (!clusters.length) {
      return null;
    }
    const index = Math.floor(rng() * clusters.length);
    return clusters[index];
  };

  const generatedIslands = [];

  for (let i = 0; i < islandCount; i += 1) {
    const islandSeed = (baseSeed + i * 0x9e3779b9) >>> 0;
    const cluster = pickCluster();
    let centerNormX = rng();
    let centerNormY = rng();
    let orientation = rng() * Math.PI * 2;
    let clusterIntensity = 0.6;

    if (cluster) {
      const jitterAngle = rng() * Math.PI * 2;
      const jitterDistance = (0.01 + (1 - cluster.intensity) * 0.05) * (0.7 + rng() * 0.6);
      centerNormX = clamp(
        cluster.x + Math.cos(jitterAngle) * jitterDistance,
        0.04,
        0.96
      );
      centerNormY = clamp(
        cluster.y + Math.sin(jitterAngle) * jitterDistance,
        0.04,
        0.96
      );
      orientation = cluster.orientation + (rng() - 0.5) * 0.9;
      clusterIntensity = cluster.intensity;
    }

    const maskSample = clamp(sampleMask(centerNormX, centerNormY), 0, 1);
    const island = createArchipelagoIslandDefinition({
      rng,
      width,
      height,
      minRadius,
      maxRadius,
      islandSeed,
      centerNormX,
      centerNormY,
      orientation,
      clusterIntensity,
      maskSample
    });

    applyArchipelagoIslandDefinition(island, width, height, heights, tectonics);
    generatedIslands.push(island);
  }

  const fillerTarget = Math.min(Math.floor(generatedIslands.length * 0.35), 45);
  let fillerAttempts = fillerTarget * 6;
  const fillerIslands = [];

  while (fillerIslands.length < fillerTarget && fillerAttempts > 0 && generatedIslands.length > 1) {
    fillerAttempts -= 1;
    const islandA = generatedIslands[Math.floor(rng() * generatedIslands.length)];
    let islandB = islandA;
    for (let retry = 0; retry < 4 && islandB === islandA; retry += 1) {
      islandB = generatedIslands[Math.floor(rng() * generatedIslands.length)];
    }
    if (islandB === islandA) {
      continue;
    }

    const vectorX = islandB.centerNormX - islandA.centerNormX;
    const vectorY = islandB.centerNormY - islandA.centerNormY;
    const distance = Math.hypot(vectorX, vectorY);
    if (!Number.isFinite(distance) || distance < 0.08 || distance > 0.62) {
      continue;
    }

    const midpointX = islandA.centerNormX + vectorX * 0.5;
    const midpointY = islandA.centerNormY + vectorY * 0.5;
    const perpendicularAngle = Math.atan2(vectorY, vectorX) + Math.PI * 0.5;
    const perpendicularOffset = (rng() - 0.5) * distance * 0.45;
    const centerNormX = clamp(midpointX + Math.cos(perpendicularAngle) * perpendicularOffset, 0.05, 0.95);
    const centerNormY = clamp(midpointY + Math.sin(perpendicularAngle) * perpendicularOffset, 0.05, 0.95);
    const maskSample = clamp(sampleMask(centerNormX, centerNormY), 0, 1);
    if (maskSample < 0.28 || maskSample > 0.74) {
      continue;
    }

    const sampleX = clamp(Math.floor(centerNormX * width), 0, width - 1);
    const sampleY = clamp(Math.floor(centerNormY * height), 0, height - 1);
    const sampleIdx = sampleY * width + sampleX;
    if (heights[sampleIdx] > 0.32) {
      continue;
    }

    const fillerSeed = (baseSeed + (islandCount + fillerIslands.length + 1) * 0x9e3779b9) >>> 0;
    const distanceScale = clamp(distance / 0.55, 0, 1);
    const radiusBaseMin = Math.max(3, Math.floor(minRadius * 0.45));
    const radiusBaseMax = Math.max(
      radiusBaseMin,
      Math.min(
        Math.floor(maxRadius * 0.65),
        Math.floor(minDimension * (0.06 + distanceScale * 0.08))
      )
    );
    if (radiusBaseMax < radiusBaseMin) {
      continue;
    }

    const fillerClusterIntensity = clamp(
      (islandA.clusterIntensity + islandB.clusterIntensity) * 0.5 + (rng() - 0.5) * 0.12,
      0.45,
      0.92
    );

    const fillerIsland = createArchipelagoIslandDefinition({
      rng,
      width,
      height,
      minRadius,
      maxRadius,
      islandSeed: fillerSeed,
      centerNormX,
      centerNormY,
      orientation: rng() * Math.PI * 2,
      clusterIntensity: fillerClusterIntensity,
      maskSample,
      radiusBaseRange: { min: radiusBaseMin, max: radiusBaseMax },
      sizeScale: 0.55 + rng() * 0.35
    });

    const approxRadius = fillerIsland.approxRadius;
    let tooClose = false;
    for (let existingIndex = 0; existingIndex < generatedIslands.length; existingIndex += 1) {
      const other = generatedIslands[existingIndex];
      const dx = centerNormX - other.centerNormX;
      const dy = centerNormY - other.centerNormY;
      const separation = Math.hypot(dx, dy);
      const limit = other.approxRadius + approxRadius + 0.035;
      if (separation < limit) {
        tooClose = true;
        break;
      }
    }

    if (tooClose) {
      continue;
    }

    applyArchipelagoIslandDefinition(fillerIsland, width, height, heights, tectonics);
    generatedIslands.push(fillerIsland);
    fillerIslands.push(fillerIsland);
  }

  const margin = Math.max(4, Math.floor(Math.min(width, height) * 0.05));
  if (margin > 0) {
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const edgeDistance = Math.min(x, y, width - 1 - x, height - 1 - y);
        if (edgeDistance < margin) {
          const t = clamp(edgeDistance / margin, 0, 1);
          heights[idx] *= t * t;
          tectonics[idx] *= t * 0.85;
        }
      }
    }
  }

  return { heights, tectonics };
}

const continentalPlateConfigs = {
  archipelago: {
    majorTargetRange: [1, 2],
    fragmentTargetRange: [9, 13],
    useMaskPlacement: true,
    maskLandThreshold: 0.52,
    maskOceanThreshold: 0.28,
    maskSearchRadius: 0.12,
    minDistance: 0.1,
    fragmentDistance: 0.06,
    majorRadiusRange: [0.12, 0.2],
    fragmentRadiusRange: [0.05, 0.11],
    majorRadiusXMultiplierRange: [0.55, 2.2],
    majorRadiusYMultiplierRange: [0.5, 2.05],
    fragmentRadiusXMultiplierRange: [0.5, 1.9],
    fragmentRadiusYMultiplierRange: [0.45, 1.75],
    majorOceanChance: 0.6,
    fragmentOceanChance: 0.45,
    majorLandStrengthRange: [0.45, 0.85],
    fragmentLandStrengthRange: [0.4, 0.75],
    majorOceanStrengthRange: [0.45, 0.7],
    fragmentOceanStrengthRange: [0.35, 0.6],
    majorFalloffRange: [1.25, 2.7],
    fragmentFalloffRange: [1.2, 2.4],
    majorSharpnessRange: [1.2, 2],
    fragmentSharpnessRange: [1.15, 2.05],
    majorJaggednessRange: [1.45, 3.2],
    fragmentJaggednessRange: [1.6, 3.5],
    majorTurbulenceRange: [0.85, 1.4],
    fragmentTurbulenceRange: [0.95, 1.55],
    majorNoiseScaleRange: [5.2, 10.5],
    fragmentNoiseScaleRange: [8.5, 16.8],
    majorMinEdge: 0.04,
    fragmentMinEdge: 0.015,
    fallbackPlate: {
      radiusX: 0.18,
      radiusY: 0.13,
      falloff: 1.65,
      sharpness: 1.6,
      strength: 0.6,
      jaggedness: 1.45,
      turbulence: 0.95,
      noiseScale: 7.8
    }
  }
};

const worldGenerationProfiles = {
  normal: {
    key: 'normal',
    label: 'Normal',
    baseNoiseScaleRange: [1.6, 2.6],
    detailNoiseScaleRange: [4.2, 7.4],
    ridgeNoiseScaleRange: [7, 11.4],
    edgeTaperRange: [2.1, 2.9],
    edgeDropRange: [0.24, 0.36],
    maskInfluence: 0.38,
    seaLevelShift: 0.02,
    rainfallBias: 0
  },
  major_continent: {
    key: 'major_continent',
    label: 'Major Continent',
    baseNoiseScaleRange: [1.2, 2],
    detailNoiseScaleRange: [3.6, 6.8],
    ridgeNoiseScaleRange: [6.4, 10.6],
    edgeTaperRange: [2.4, 3.2],
    edgeDropRange: [0.28, 0.42],
    maskInfluence: 0.5,
    seaLevelShift: 0,
    rainfallBias: 0
  },
  twin_continents: {
    key: 'twin_continents',
    label: 'Twin Continents',
    baseNoiseScaleRange: [1, 1.6],
    detailNoiseScaleRange: [3.2, 5.4],
    ridgeNoiseScaleRange: [5.6, 8.4],
    edgeTaperRange: [2.2, 3],
    edgeDropRange: [0.24, 0.36],
    maskInfluence: 0.65,
    seaLevelShift: -0.02,
    rainfallBias: -0.02,
    createMask: createTwinContinentsMask
  },
  inland_sea: {
    key: 'inland_sea',
    label: 'Inland Sea',
    baseNoiseScaleRange: [1.1, 1.8],
    detailNoiseScaleRange: [3.4, 6],
    ridgeNoiseScaleRange: [6, 9.2],
    edgeTaperRange: [2.6, 3.4],
    edgeDropRange: [0.3, 0.46],
    maskInfluence: 0.62,
    seaLevelShift: 0.04,
    rainfallBias: 0.03,
    createMask: createInlandSeaMask
  },
  archipelago: {
    key: 'archipelago',
    label: 'Archipelago',
    baseNoiseScaleRange: [1.4, 2.2],
    detailNoiseScaleRange: [4, 6.6],
    ridgeNoiseScaleRange: [7.2, 11],
    edgeTaperRange: [2.1, 2.8],
    edgeDropRange: [0.22, 0.34],
    maskInfluence: 0.68,
    seaLevelShift: 0.08,
    rainfallBias: 0.05,
    createMask: createArchipelagoMask
  }
};

function octaveNoise(x, y, seed, octaves = 4, persistence = 0.5, lacunarity = 2.1) {
  let amplitude = 1;
  let frequency = 1;
  let sum = 0;
  let maxAmplitude = 0;
  for (let i = 0; i < octaves; i += 1) {
    sum += amplitude * valueNoise(x * frequency, y * frequency, seed + i * 131);
    maxAmplitude += amplitude;
    amplitude *= persistence;
    frequency *= lacunarity;
  }
  return sum / maxAmplitude;
}

function generateContinentalPlates(rng, options = {}) {
  const profileKey = options && typeof options.profileKey === 'string' ? options.profileKey : null;
  const config =
    profileKey && Object.prototype.hasOwnProperty.call(continentalPlateConfigs, profileKey)
      ? continentalPlateConfigs[profileKey]
      : null;

  const mask = options && options.landMask && options.landMask.data ? options.landMask : null;
  const maskPlacementEnabled = Boolean(config && config.useMaskPlacement && mask);
  const maskLandThreshold =
    config && Number.isFinite(config.maskLandThreshold) ? config.maskLandThreshold : 0.5;
  const maskOceanThreshold =
    config && Number.isFinite(config.maskOceanThreshold) ? config.maskOceanThreshold : 0.35;
  const maskSearchRadius =
    config && Number.isFinite(config.maskSearchRadius) ? config.maskSearchRadius : 0.1;
  const maskStepSize = maskPlacementEnabled ? Math.max(maskSearchRadius, 0.02) : 0;

  const findMaskPlacement = maskPlacementEnabled
    ? (baseX, baseY, preferHigh) => {
        let bestX = clamp(baseX, 0.03, 0.97);
        let bestY = clamp(baseY, 0.03, 0.97);
        let bestSample = sampleMaskValue(mask, bestX, bestY);
        const attempts = 6;
        for (let i = 0; i < attempts; i += 1) {
          const angle = rng() * Math.PI * 2;
          const distance = (0.3 + rng() * 0.7) * maskStepSize;
          if (distance <= 0) {
            continue;
          }
          const testX = clamp(baseX + Math.cos(angle) * distance, 0.03, 0.97);
          const testY = clamp(baseY + Math.sin(angle) * distance, 0.03, 0.97);
          const sample = sampleMaskValue(mask, testX, testY);
          if (sample === null) {
            continue;
          }
          if (bestSample === null || (preferHigh ? sample > bestSample : sample < bestSample)) {
            bestSample = sample;
            bestX = testX;
            bestY = testY;
          }
        }
        return { x: bestX, y: bestY, sample: bestSample };
      }
    : null;

  const sampleRangeValue = (range, defaultMin, defaultMax) => {
    let min = defaultMin;
    let max = defaultMax;
    if (Array.isArray(range) && range.length >= 2) {
      if (Number.isFinite(range[0])) {
        min = range[0];
      }
      if (Number.isFinite(range[1])) {
        max = range[1];
      }
    } else if (Number.isFinite(range)) {
      return range;
    }
    if (!Number.isFinite(min) || !Number.isFinite(max)) {
      min = defaultMin;
      max = defaultMax;
    }
    if (max <= min) {
      return min;
    }
    return min + rng() * (max - min);
  };

  const sampleIntRange = (range, defaultMin, defaultMax) => {
    let min = defaultMin;
    let max = defaultMax;
    if (Array.isArray(range) && range.length >= 2) {
      if (Number.isFinite(range[0])) {
        min = Math.round(range[0]);
      }
      if (Number.isFinite(range[1])) {
        max = Math.round(range[1]);
      }
    } else if (Number.isFinite(range)) {
      return Math.round(range);
    }
    if (!Number.isFinite(min) || !Number.isFinite(max)) {
      min = defaultMin;
      max = defaultMax;
    }
    if (max <= min) {
      return min;
    }
    return min + Math.floor(rng() * (max - min + 1));
  };

  const plates = [];
  const majorTarget = sampleIntRange(config && config.majorTargetRange, 4, 7);
  const fragmentTarget = sampleIntRange(config && config.fragmentTargetRange, 3, 7);
  const totalTarget = majorTarget + fragmentTarget;
  const maxAttempts = totalTarget * 40;
  const minDistance = config && Number.isFinite(config.minDistance) ? config.minDistance : 0.14;
  const fragmentDistance =
    config && Number.isFinite(config.fragmentDistance) ? config.fragmentDistance : 0.08;

  const randomUint32 = () => Math.floor(rng() * 0xffffffff);

  for (let attempt = 0; attempt < maxAttempts && plates.length < totalTarget; attempt += 1) {
    const isFragment = plates.length >= majorTarget;
    const radiusBase = isFragment
      ? sampleRangeValue(config && config.fragmentRadiusRange, 0.08, 0.22)
      : sampleRangeValue(config && config.majorRadiusRange, 0.18, 0.42);
    const rotation = rng() * Math.PI * 2;
    const oceanChance = clamp(
      isFragment
        ? sampleRangeValue(config && config.fragmentOceanChance, 0.25, 0.25)
        : sampleRangeValue(config && config.majorOceanChance, 0.4, 0.4),
      0,
      1
    );
    const isOcean = rng() < oceanChance;
    const oceanStrength = isFragment
      ? sampleRangeValue(config && config.fragmentOceanStrengthRange, 0.28, 0.525)
      : sampleRangeValue(config && config.majorOceanStrengthRange, 0.4, 0.75);
    const landStrength = isFragment
      ? sampleRangeValue(config && config.fragmentLandStrengthRange, 0.45, 0.8625)
      : sampleRangeValue(config && config.majorLandStrengthRange, 0.6, 1.15);
    const strengthBase = isOcean ? -oceanStrength : landStrength;
    const jaggedness = isFragment
      ? sampleRangeValue(config && config.fragmentJaggednessRange, 0.8, 1.9)
      : sampleRangeValue(config && config.majorJaggednessRange, 0.45, 1.25);
    const turbulence = isFragment
      ? sampleRangeValue(config && config.fragmentTurbulenceRange, 0.4, 1)
      : sampleRangeValue(config && config.majorTurbulenceRange, 0.4, 1);
    const radiusXMultiplier = isFragment
      ? sampleRangeValue(config && config.fragmentRadiusXMultiplierRange, 0.7, 2.3)
      : sampleRangeValue(config && config.majorRadiusXMultiplierRange, 0.7, 2.3);
    const radiusYMultiplier = isFragment
      ? sampleRangeValue(config && config.fragmentRadiusYMultiplierRange, 0.6, 2)
      : sampleRangeValue(config && config.majorRadiusYMultiplierRange, 0.6, 2);
    const falloff = isFragment
      ? sampleRangeValue(config && config.fragmentFalloffRange, 1.15, 2.95)
      : sampleRangeValue(config && config.majorFalloffRange, 1.15, 2.95);
    const sharpness = isFragment
      ? sampleRangeValue(config && config.fragmentSharpnessRange, 1.1, 2.4)
      : sampleRangeValue(config && config.majorSharpnessRange, 1.1, 2.4);
    const noiseScale = isFragment
      ? sampleRangeValue(config && config.fragmentNoiseScaleRange, 6, 16)
      : sampleRangeValue(config && config.majorNoiseScaleRange, 3, 9);

    const candidate = {
      x: clamp(rng() * 0.82 + 0.09, 0.03, 0.97),
      y: clamp(rng() * 0.82 + 0.09, 0.03, 0.97),
      radiusX: radiusBase * radiusXMultiplier,
      radiusY: radiusBase * radiusYMultiplier,
      falloff,
      sharpness,
      strength: strengthBase,
      rotation,
      cos: Math.cos(rotation),
      sin: Math.sin(rotation),
      type: isOcean ? 'ocean' : 'land',
      jaggedness,
      turbulence,
      noiseScale,
      noiseSeed: randomUint32(),
      noiseOffsetX: rng() * 256,
      noiseOffsetY: rng() * 256
    };

    if (maskPlacementEnabled && findMaskPlacement) {
      const placement = findMaskPlacement(candidate.x, candidate.y, !isOcean);
      const maskSample = placement ? placement.sample : null;

      if (!isOcean) {
        if (maskSample === null || maskSample < maskLandThreshold) {
          continue;
        }
      } else if (maskSample !== null && maskSample > maskOceanThreshold) {
        continue;
      }

      if (placement) {
        candidate.x = placement.x;
        candidate.y = placement.y;
      }
    }

    const edgeDistance = Math.min(candidate.x, 1 - candidate.x, candidate.y, 1 - candidate.y);
    const minEdge = isFragment
      ? (config && Number.isFinite(config.fragmentMinEdge) ? config.fragmentMinEdge : 0.02)
      : (config && Number.isFinite(config.majorMinEdge) ? config.majorMinEdge : 0.06);
    if (edgeDistance < minEdge) {
      continue;
    }

    let tooClose = false;
    for (let i = 0; i < plates.length; i += 1) {
      const existing = plates[i];
      const separation = Math.hypot(candidate.x - existing.x, candidate.y - existing.y);
      const limit =
        existing.type === candidate.type
          ? isFragment
            ? fragmentDistance
            : minDistance
          : minDistance * 0.75;
      if (separation < limit) {
        tooClose = true;
        break;
      }
    }

    if (tooClose) {
      continue;
    }

    plates.push(candidate);
  }

  if (!plates.some((plate) => plate.strength > 0)) {
    const rotation = rng() * Math.PI * 2;
    const fallback = config && config.fallbackPlate ? config.fallbackPlate : null;
    const radiusX = fallback && Number.isFinite(fallback.radiusX) ? fallback.radiusX : 0.26;
    const radiusY = fallback && Number.isFinite(fallback.radiusY) ? fallback.radiusY : 0.2;
    const falloff = fallback && Number.isFinite(fallback.falloff) ? fallback.falloff : 1.5;
    const sharpness = fallback && Number.isFinite(fallback.sharpness) ? fallback.sharpness : 1.3;
    const strength = fallback && Number.isFinite(fallback.strength) ? fallback.strength : 0.85;
    const jaggedness = fallback && Number.isFinite(fallback.jaggedness) ? fallback.jaggedness : 0.7;
    const turbulence = fallback && Number.isFinite(fallback.turbulence) ? fallback.turbulence : 0.6;
    const noiseScale = fallback && Number.isFinite(fallback.noiseScale) ? fallback.noiseScale : 4.5;
    plates.push({
      x: 0.5,
      y: 0.5,
      radiusX,
      radiusY,
      falloff,
      sharpness,
      strength,
      rotation,
      cos: Math.cos(rotation),
      sin: Math.sin(rotation),
      type: 'land',
      jaggedness,
      turbulence,
      noiseScale,
      noiseSeed: randomUint32(),
      noiseOffsetX: rng() * 128,
      noiseOffsetY: rng() * 128
    });
  }

  return plates;
}

function sampleContinentalPlates(x, y, plates) {
  if (!plates || plates.length === 0) {
    return { height: 0, mask: 0, tectonic: 0 };
  }

  let landSum = 0;
  let landWeight = 0;
  let oceanSum = 0;
  let oceanWeight = 0;
  let maxLand = 0;
  let secondLand = 0;
  let maxOcean = 0;
  let secondOcean = 0;
  let variation = 0;
  let landTurbulence = 0;
  let boundaryMix = 0;

  for (let i = 0; i < plates.length; i += 1) {
    const plate = plates[i];
    const dx = x - plate.x;
    const dy = y - plate.y;
    const rotatedX = dx * plate.cos + dy * plate.sin;
    const rotatedY = dy * plate.cos - dx * plate.sin;

    const boundaryNoise = octaveNoise(
      (rotatedX + plate.noiseOffsetX) * plate.noiseScale,
      (rotatedY + plate.noiseOffsetY) * plate.noiseScale,
      plate.noiseSeed,
      3,
      0.55 + plate.turbulence * 0.25,
      2 + plate.turbulence * 0.9
    );

    const radiusScale = clamp(1 + (boundaryNoise - 0.5) * plate.jaggedness, 0.35, 2.8);
    const distX = rotatedX / (plate.radiusX * radiusScale);
    const distY = rotatedY / (plate.radiusY * radiusScale);
    const distance = Math.sqrt(distX * distX + distY * distY);

    let influence = clamp(1 - Math.pow(distance, plate.falloff), 0, 1);
    influence = Math.pow(influence, plate.sharpness);

    if (influence <= 0) {
      continue;
    }

    const contribution = influence * Math.abs(plate.strength);
    const turbulence = Math.pow(Math.abs(boundaryNoise - 0.5) * 2, 1.35) * plate.turbulence * influence;

    if (plate.strength >= 0) {
      if (contribution > maxLand) {
        secondLand = maxLand;
        maxLand = contribution;
      } else if (contribution > secondLand) {
        secondLand = contribution;
      }
      landSum += contribution;
      landWeight += Math.abs(plate.strength);
      variation += turbulence;
      landTurbulence += turbulence;
      boundaryMix += contribution * 0.75;
    } else {
      if (contribution > maxOcean) {
        secondOcean = maxOcean;
        maxOcean = contribution;
      } else if (contribution > secondOcean) {
        secondOcean = contribution;
      }
      oceanSum += contribution;
      oceanWeight += Math.abs(plate.strength);
      variation -= turbulence;
      boundaryMix += contribution * 0.45;
    }
  }

  if (landWeight === 0 && oceanWeight === 0) {
    return { height: 0, mask: 0, tectonic: 0 };
  }

  const landAvg = landWeight > 0 ? landSum / landWeight : 0;
  const oceanAvg = oceanWeight > 0 ? oceanSum / oceanWeight : 0;

  const separation = Math.max(0, maxLand - secondLand * 0.65);
  const oceanSeparation = Math.max(0, maxOcean - secondOcean * 0.7);

  let height = landAvg - oceanAvg * 0.9 + separation * 0.25 - oceanSeparation * 0.22 + variation * 0.18;
  const mask = clamp(landAvg + separation * 0.6 - oceanAvg * 0.8, 0, 1);

  height = clamp(height, -1, 1);

  const normalizedLandTurbulence = landTurbulence / (landWeight || 1);
  const totalWeight = landWeight + oceanWeight;
  const normalizedBoundaryMix = boundaryMix / (totalWeight || 1);
  const tectonicActivity = clamp(
    separation * 0.85 +
      oceanSeparation * 0.55 +
      Math.max(0, variation) * 0.4 +
      normalizedLandTurbulence * 0.3 +
      normalizedBoundaryMix * 0.15,
    0,
    1
  );

  return { height, mask, tectonic: tectonicActivity };
}

function normalizeField(field) {
  let minValue = Infinity;
  let maxValue = -Infinity;
  for (let i = 0; i < field.length; i += 1) {
    const value = field[i];
    if (value < minValue) {
      minValue = value;
    }
    if (value > maxValue) {
      maxValue = value;
    }
  }
  const range = maxValue - minValue || 1;
  for (let i = 0; i < field.length; i += 1) {
    field[i] = (field[i] - minValue) / range;
  }
  return field;
}

function applyThermalErosion(field, width, height, iterations = 3, talus = 0.035) {
  const temp = new Float32Array(field.length);
  const directions = [
    [-1, -1],
    [0, -1],
    [1, -1],
    [-1, 0],
    [1, 0],
    [-1, 1],
    [0, 1],
    [1, 1]
  ];

  for (let iter = 0; iter < iterations; iter += 1) {
    temp.set(field);
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        let value = temp[idx];
        let total = value;
        let count = 1;
        for (let d = 0; d < directions.length; d += 1) {
          const nx = x + directions[d][0];
          const ny = y + directions[d][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          const diff = Math.abs(value - temp[nIdx]);
          if (diff > talus) {
            total += temp[nIdx];
            count += 1;
          }
        }
        field[idx] = total / count;
      }
    }
  }

  return normalizeField(field);
}

function applyRainShadow(elevation, rainfall, width, height) {
  const adjusted = new Float32Array(rainfall);

  const sweep = (startX, endX, step) => {
    for (let y = 0; y < height; y += 1) {
      let carried = rainfall[y * width + startX];
      for (let x = startX + step; step > 0 ? x < endX : x > endX; x += step) {
        const idx = y * width + x;
        const prevIdx = y * width + (x - step);
        const slope = elevation[prevIdx] - elevation[idx];
        if (slope > 0.05) {
          carried -= slope * 0.5;
        } else if (slope < -0.05) {
          carried += (-slope) * 0.35;
        }
        carried = clamp(carried, 0, 1);
        adjusted[idx] = clamp((adjusted[idx] * 2 + carried) / 3, 0, 1);
      }
    }
  };

  sweep(0, width, 1);
  sweep(width - 1, -1, -1);

  return normalizeField(adjusted);
}

function determineAlignmentSuffix(alignment, savagery) {
  const goodThreshold = 0.33;
  const savageThreshold = 0.65;
  if (alignment > goodThreshold) {
    return savagery > savageThreshold ? '_GOODSAV' : '_GOOD';
  }
  if (alignment < -goodThreshold) {
    return savagery > savageThreshold ? '_EVILSAV' : '_EVIL';
  }
  return '';
}

function buildRiverMap(
  elevation,
  rainfall,
  drainage,
  width,
  height,
  seaLevel,
  waterMask,
  options = {}
) {
  const frequencyNormalized = clamp(
    typeof options.frequencyNormalized === 'number' ? options.frequencyNormalized : 0.5,
    0,
    1
  );
  const frequencyMultiplier = lerp(0.45, 1.75, frequencyNormalized);
  const weightThreshold = 0.12 * lerp(1.45, 0.45, frequencyNormalized);
  const majorRiverThreshold = lerp(0.45, 0.28, frequencyNormalized);
  const randomFn =
    typeof options.random === 'function'
      ? options.random
      : typeof options.rng === 'function'
      ? options.rng
      : Math.random;

  const riverMap = new Uint8Array(width * height);
  const candidates = [];
  for (let y = 1; y < height - 1; y += 1) {
    for (let x = 1; x < width - 1; x += 1) {
      const idx = y * width + x;
      const elev = elevation[idx];
      if (elev <= seaLevel + 0.02) {
        continue;
      }
      const sink = 1 - drainage[idx];
      const heightFactor = Math.max(0, elev - seaLevel);
      const randomness = 0.35 + randomFn() * 0.65;
      const weight = (heightFactor * 0.7 + sink * 0.3) * randomness;
      if (weight > weightThreshold) {
        candidates.push({ x, y, weight });
      }
    }
  }

  candidates.sort((a, b) => b.weight - a.weight);
  const baseSources = Math.max(8, Math.floor((width * height) / 3200));
  const sourceDensityMultiplier = lerp(1.8, 3.1, frequencyNormalized);
  const maxSources = Math.max(
    4,
    Math.round(baseSources * frequencyMultiplier * sourceDensityMultiplier)
  );
  const directions = [
    [0, -1],
    [1, 0],
    [0, 1],
    [-1, 0]
  ];

  const oceanDistance = new Float32Array(width * height);
  oceanDistance.fill(Number.POSITIVE_INFINITY);
  const oceanMask = new Uint8Array(width * height);
  let hasOceanTiles = false;
  if (waterMask && typeof waterMask.length === 'number') {
    const queue = new Int32Array(width * height);
    let queueHead = 0;
    let queueTail = 0;
    const enqueue = (value) => {
      queue[queueTail] = value;
      queueTail += 1;
    };

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (!waterMask[idx]) {
          continue;
        }
        if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
          oceanMask[idx] = 1;
          hasOceanTiles = true;
          enqueue(idx);
        }
      }
    }

    if (queueTail === 0) {
      for (let i = 0; i < waterMask.length; i += 1) {
        if (waterMask[i]) {
          oceanMask[i] = 1;
          hasOceanTiles = true;
          enqueue(i);
        }
      }
    }

    while (queueHead < queueTail) {
      const current = queue[queueHead];
      queueHead += 1;
      const cx = current % width;
      const cy = Math.floor(current / width);
      for (let d = 0; d < directions.length; d += 1) {
        const nx = cx + directions[d][0];
        const ny = cy + directions[d][1];
        if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
          continue;
        }
        const nIdx = ny * width + nx;
        if (!waterMask[nIdx] || oceanMask[nIdx]) {
          continue;
        }
        oceanMask[nIdx] = 1;
        enqueue(nIdx);
      }
    }

    queueHead = 0;
    queueTail = 0;

    for (let i = 0; i < oceanMask.length; i += 1) {
      if (oceanMask[i]) {
        oceanDistance[i] = 0;
        hasOceanTiles = true;
        enqueue(i);
      }
    }

    if (queueTail === 0) {
      for (let i = 0; i < waterMask.length; i += 1) {
        if (waterMask[i]) {
          oceanDistance[i] = 0;
          hasOceanTiles = true;
          enqueue(i);
        }
      }
    }

    while (queueHead < queueTail) {
      const current = queue[queueHead];
      queueHead += 1;
      const cx = current % width;
      const cy = Math.floor(current / width);
      const baseDistance = oceanDistance[current];
      for (let d = 0; d < directions.length; d += 1) {
        const nx = cx + directions[d][0];
        const ny = cy + directions[d][1];
        if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
          continue;
        }
        const nIdx = ny * width + nx;
        const nextDistance = baseDistance + 1;
        if (nextDistance < oceanDistance[nIdx]) {
          oceanDistance[nIdx] = nextDistance;
          enqueue(nIdx);
        }
      }
    }
  } else {
    oceanDistance.fill(width + height);
  }

  const oceanInfluence = lerp(0.008, 0.02, frequencyNormalized);

  for (let i = 0; i < candidates.length && i < maxSources; i += 1) {
    let { x, y } = candidates[i];
    let steps = 0;
    let strength = candidates[i].weight > majorRiverThreshold ? 2 : 1;
    while (steps < width + height) {
      const idx = y * width + x;
      riverMap[idx] = Math.min(4, riverMap[idx] + strength);
      steps += 1;

      let lowestIdx = idx;
      const currentBaseValue = elevation[idx] - drainage[idx] * 0.02;
      let lowestScore = currentBaseValue;
      let lowestBaseValue = currentBaseValue;
      const currentOceanDistance = oceanDistance[idx];
      for (let d = 0; d < directions.length; d += 1) {
        const nx = x + directions[d][0];
        const ny = y + directions[d][1];
        if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
          continue;
        }
        const nIdx = ny * width + nx;
        const neighborBaseValue = elevation[nIdx] - drainage[nIdx] * 0.02;
        let score = neighborBaseValue;
        if (Number.isFinite(currentOceanDistance) && Number.isFinite(oceanDistance[nIdx])) {
          const distanceDelta = oceanDistance[nIdx] - currentOceanDistance;
          score += distanceDelta * oceanInfluence;
        }
        if (score < lowestScore - 1e-6) {
          lowestScore = score;
          lowestBaseValue = neighborBaseValue;
          lowestIdx = nIdx;
        } else if (Math.abs(score - lowestScore) <= 1e-6 && neighborBaseValue < lowestBaseValue) {
          lowestBaseValue = neighborBaseValue;
          lowestIdx = nIdx;
        }
      }

      if (lowestIdx === idx) {
        break;
      }

      const nextElevation = elevation[lowestIdx];
      if (nextElevation <= seaLevel) {
        const seaIdx = lowestIdx;
        riverMap[seaIdx] = Math.max(riverMap[seaIdx], strength);
        break;
      }

      x = lowestIdx % width;
      y = Math.floor(lowestIdx / width);

      if (riverMap[lowestIdx] > 0 && steps > 3) {
        break;
      }
    }
  }

  if (
    hasOceanTiles &&
    waterMask &&
    typeof waterMask.length === 'number' &&
    frequencyNormalized > 0.05
  ) {
    const coastalCandidates = [];
    const coastalTaken = new Uint8Array(width * height);

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (!oceanMask[idx]) {
          continue;
        }

        for (let d = 0; d < directions.length; d += 1) {
          const nx = x + directions[d][0];
          const ny = y + directions[d][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (waterMask[nIdx] || coastalTaken[nIdx]) {
            continue;
          }
          if (elevation[nIdx] <= seaLevel) {
            continue;
          }
          const sink = 1 - drainage[nIdx];
          const lowlandBoost = Math.max(0, seaLevel + 0.12 - elevation[nIdx]);
          const randomness = 0.4 + randomFn() * 0.6;
          const basePotential = Math.max(0, elevation[nIdx] - seaLevel) * 0.5 + sink * 0.5;
          const weight = (basePotential + lowlandBoost * 3.2) * randomness;
          const strength = weight > majorRiverThreshold ? 2 : 1;
          coastalTaken[nIdx] = 1;
          coastalCandidates.push({
            x: nx,
            y: ny,
            weight,
            strength,
            idx: nIdx
          });
        }
      }
    }

    coastalCandidates.sort((a, b) => b.weight - a.weight);
    const oceanSourceFactor = lerp(0.18, 0.5, frequencyNormalized);
    const maxOceanSources = Math.min(
      coastalCandidates.length,
      Math.max(0, Math.round(maxSources * oceanSourceFactor))
    );

    if (maxOceanSources > 0) {
      const inlandInfluence = lerp(0.006, 0.018, frequencyNormalized);
      const maxReverseLength = Math.max(
        6,
        Math.round(
          Math.sqrt(width * height) * lerp(0.32, 0.58, frequencyNormalized)
        )
      );
      const detourProbability = lerp(0.08, 0.22, frequencyNormalized);

      for (let i = 0; i < maxOceanSources; i += 1) {
        const start = coastalCandidates[i];
        if (!start || riverMap[start.idx] > 0) {
          continue;
        }

        const pathIndices = [];
        const localVisited = new Set();
        let currentIdx = start.idx;

        while (pathIndices.length < maxReverseLength) {
          if (localVisited.has(currentIdx)) {
            break;
          }
          localVisited.add(currentIdx);
          pathIndices.push(currentIdx);

          let bestIdx = -1;
          let bestScore = Number.POSITIVE_INFINITY;
          const cx = currentIdx % width;
          const cy = Math.floor(currentIdx / width);
          const currentDistance = oceanDistance[currentIdx];
          const currentBaseValue = elevation[currentIdx] - drainage[currentIdx] * 0.02;

          for (let d = 0; d < directions.length; d += 1) {
            const nx = cx + directions[d][0];
            const ny = cy + directions[d][1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            const nIdx = ny * width + nx;
            if (waterMask[nIdx] || localVisited.has(nIdx)) {
              continue;
            }
            if (riverMap[nIdx] > 0 && pathIndices.length > 2) {
              continue;
            }
            const neighborDistance = oceanDistance[nIdx];
            const distanceDelta = neighborDistance - currentDistance;
            if (distanceDelta < 0) {
              continue;
            }
            if (distanceDelta === 0 && pathIndices.length > 4) {
              continue;
            }
            const neighborBaseValue =
              elevation[nIdx] - drainage[nIdx] * 0.02;
            if (
              neighborBaseValue - currentBaseValue >
              0.22 + pathIndices.length * 0.015
            ) {
              continue;
            }
            if (pathIndices.length > 4 && randomFn() < detourProbability) {
              continue;
            }

            let score = neighborBaseValue;
            score -= distanceDelta * inlandInfluence;
            score -= randomFn() * 0.02;

            if (score < bestScore) {
              bestScore = score;
              bestIdx = nIdx;
            }
          }

          if (bestIdx === -1) {
            break;
          }

          const nextDistance = oceanDistance[bestIdx];
          if (nextDistance <= currentDistance && pathIndices.length > 5) {
            break;
          }

          currentIdx = bestIdx;
        }

        if (pathIndices.length >= 3) {
          for (let p = 0; p < pathIndices.length; p += 1) {
            const idx = pathIndices[p];
            const t =
              pathIndices.length <= 1 ? 0 : p / (pathIndices.length - 1);
            const strengthAtTile = Math.max(
              1,
              Math.round(lerp(start.strength, 1, t))
            );
            riverMap[idx] = Math.max(riverMap[idx], strengthAtTile);
          }
        }
      }
    }
  }

  return riverMap;
}

const riverNeighborDefinitions = [
  { dx: 0, dy: -1, key: 'N', bit: 1 },
  { dx: 1, dy: 0, key: 'E', bit: 2 },
  { dx: 0, dy: 1, key: 'S', bit: 4 },
  { dx: -1, dy: 0, key: 'W', bit: 8 }
];

function computeEdgeConnectedWaterMask(waterMask, width, height) {
  if (!waterMask || typeof waterMask.length !== 'number') {
    return null;
  }

  const totalSize = width * height;
  if (totalSize === 0) {
    return null;
  }

  const mask = new Uint8Array(totalSize);
  const queue = new Int32Array(totalSize);
  let queueHead = 0;
  let queueTail = 0;

  const enqueue = (idx) => {
    if (mask[idx]) {
      return;
    }
    mask[idx] = 1;
    queue[queueTail] = idx;
    queueTail += 1;
  };

  for (let x = 0; x < width; x += 1) {
    const topIdx = x;
    if (waterMask[topIdx]) {
      enqueue(topIdx);
    }
    if (height > 1) {
      const bottomIdx = (height - 1) * width + x;
      if (waterMask[bottomIdx]) {
        enqueue(bottomIdx);
      }
    }
  }

  for (let y = 1; y < height - 1; y += 1) {
    const leftIdx = y * width;
    if (waterMask[leftIdx]) {
      enqueue(leftIdx);
    }
    if (width > 1) {
      const rightIdx = leftIdx + (width - 1);
      if (waterMask[rightIdx]) {
        enqueue(rightIdx);
      }
    }
  }

  if (queueTail === 0) {
    return null;
  }

  while (queueHead < queueTail) {
    const current = queue[queueHead];
    queueHead += 1;
    const cx = current % width;
    const cy = Math.floor(current / width);
    for (let i = 0; i < riverNeighborDefinitions.length; i += 1) {
      const { dx, dy } = riverNeighborDefinitions[i];
      const nx = cx + dx;
      const ny = cy + dy;
      if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
        continue;
      }
      const nIdx = ny * width + nx;
      if (!waterMask[nIdx] || mask[nIdx]) {
        continue;
      }
      enqueue(nIdx);
    }
  }

  return mask;
}

const riverMaskSuffixLookup = {
  0: '0',
  1: 'N',
  2: 'E',
  3: 'NE',
  4: 'S',
  5: 'NS',
  6: 'SE',
  7: 'NSE',
  8: 'W',
  9: 'NW',
  10: 'WE',
  11: 'NWE',
  12: 'SW',
  13: 'NSW',
  14: 'SWE',
  15: 'NSWE'
};

function resolveRiverTile(riverMap, width, height, x, y, waterMask, oceanMask) {
  const idx = y * width + x;
  const strength = riverMap[idx];
  if (strength === 0) {
    return null;
  }

  const prefix = 'RIVER_';

  let mask = 0;
  let riverNeighborCount = 0;
  riverNeighborDefinitions.forEach(({ dx, dy, bit }) => {
    const nx = x + dx;
    const ny = y + dy;
    if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
      return;
    }
    if (riverMap[ny * width + nx] > 0) {
      mask |= bit;
      riverNeighborCount += 1;
    }
  });
  let touchesOcean = false;
  if (oceanMask && riverNeighborCount === 1) {
    for (let i = 0; i < riverNeighborDefinitions.length; i += 1) {
      const { dx, dy, bit } = riverNeighborDefinitions[i];
      if (mask & bit) {
        continue;
      }
      const nx = x + dx;
      const ny = y + dy;
      if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
        continue;
      }
      const nIdx = ny * width + nx;
      if (oceanMask[nIdx]) {
        mask |= bit;
        touchesOcean = true;
      }
    }
  }
  const suffix = riverMaskSuffixLookup[mask] || 'NSWE';
  const baseKey = `${prefix}${suffix}`;
  const majorKey = `RIVER_MAJOR_${suffix}`;
  const hasMajor = tileLookup.has(majorKey);
  const useMajor = strength >= 3 && hasMajor;

  let tileKey = useMajor ? majorKey : baseKey;

  if (!useMajor && suffix.length === 1 && suffix !== '0' && waterMask && !touchesOcean) {
    const direction = suffix;
    const mouthKey = `RIVER_MOUTH_NARROW_${direction}`;
    if (tileLookup.has(mouthKey)) {
      const neighbor = riverNeighborDefinitions.find(({ key }) => key === direction);
      if (neighbor) {
        const nx = x + neighbor.dx;
        const ny = y + neighbor.dy;
        if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            tileKey = mouthKey;
          }
        }
      }
    }
  }

  if (useMajor && suffix.length === 1 && suffix !== '0' && waterMask && !touchesOcean) {
    const direction = suffix;
    const mouthKey = `RIVER_MAJOR_MOUTH_NARROW_${direction}`;
    if (tileLookup.has(mouthKey)) {
      const neighbor = riverNeighborDefinitions.find(({ key }) => key === direction);
      if (neighbor) {
        const nx = x + neighbor.dx;
        const ny = y + neighbor.dy;
        if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            tileKey = mouthKey;
          }
        }
      }
    }
  }

  return {
    key: tileKey,
    mask,
    strength,
    connections: suffix,
    tileKey
  };
}

function ensureRiverConnectionsToWater(riverMap, waterMask, tiles, width, height) {
  const waterTileKey = tileLookup.has('WATER') ? 'WATER' : null;
  if (!waterTileKey) {
    return;
  }

  const visited = new Uint8Array(width * height);

  const convertToWater = (idx) => {
    if (waterMask[idx]) {
      return true;
    }
    const x = idx % width;
    const y = Math.floor(idx / width);
    const tile = tiles[y] && tiles[y][x];
    if (!tile) {
      return false;
    }
    tile.base = waterTileKey;
    tile.overlay = null;
    tile.hillOverlay = null;
    tile.structure = null;
    tile.structureName = null;
    tile.structureDetails = null;
    tile.ambientStructure = null;
    tile.river = null;
    tile.biomeType = null;
    tile.biomeClusterId = null;
    tile.areaName = null;
    tile.waterDepth = 0;
    tile.coastProximity = 0;
    tile.marshProximity = 0;
    tile.desertProximity = 0;
    tile.volcanoProximity = 0;
    waterMask[idx] = 1;
    return true;
  };

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      if (visited[idx] || riverMap[idx] === 0) {
        continue;
      }

      const stack = [idx];
      const component = [];
      const endpoints = [];
      let touchesWater = false;

      while (stack.length > 0) {
        const current = stack.pop();
        if (visited[current]) {
          continue;
        }
        visited[current] = 1;
        component.push(current);
        const cx = current % width;
        const cy = Math.floor(current / width);

        let neighborCount = 0;
        riverNeighborDefinitions.forEach(({ dx, dy }) => {
          const nx = cx + dx;
          const ny = cy + dy;
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            return;
          }
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            touchesWater = true;
          }
          if (riverMap[nIdx] > 0) {
            neighborCount += 1;
            if (!visited[nIdx]) {
              stack.push(nIdx);
            }
          }
        });

        if (neighborCount <= 1) {
          endpoints.push(current);
        }
      }

      if (touchesWater) {
        continue;
      }

      const candidates = endpoints.length > 0 ? endpoints : component;
      for (let i = 0; i < candidates.length; i += 1) {
        if (convertToWater(candidates[i])) {
          touchesWater = true;
          break;
        }
      }

      if (!touchesWater && component.length > 0) {
        convertToWater(component[0]);
      }
    }
  }
}

function createWorld(seedString) {
  const seedNumber = stringToSeed(seedString);
  const rng = mulberry32(seedNumber || 1);
  const width = state.settings.width;
  const height = state.settings.height;
  const chronology = ensureChronology();
  const isFirstAge = chronology && chronology.age === 1;
  const forestFrequencySetting = sanitizeFrequencyValue(
    state.settings.forestFrequency,
    defaultForestFrequency
  );
  const mountainFrequencySetting = sanitizeFrequencyValue(
    state.settings.mountainFrequency,
    defaultMountainFrequency
  );
  const riverFrequencySetting = sanitizeFrequencyValue(state.settings.riverFrequency, 50);
  const humanSettlementFrequencySetting = sanitizeFrequencyValue(
    state.settings.humanSettlementFrequency,
    50
  );
  const dwarfSettlementFrequencySetting = sanitizeFrequencyValue(
    state.settings.dwarfSettlementFrequency,
    50
  );
  const woodElfSettlementFrequencySetting = sanitizeFrequencyValue(
    state.settings.woodElfSettlementFrequency,
    50
  );
  const lizardmenSettlementFrequencySetting = sanitizeFrequencyValue(
    state.settings.lizardmenSettlementFrequency,
    50
  );
  const profile = getWorldGenerationProfile(state.settings.worldGenerationType);
  ensureLandMaskForProfile(profile.key);
  const maskInfluence = clamp(
    typeof profile.maskInfluence === 'number' ? profile.maskInfluence : 0.5,
    0,
    1
  );
  const targetWaterRatio = clamp(0.47 + (profile.seaLevelShift || 0), 0.2, 0.8);
  const rainfallBias = Number.isFinite(profile.rainfallBias) ? profile.rainfallBias : 0;
  const forestBias = clamp(
    // Normalize relative to the default slider position so negative values mean "sparser"
    // and positive values mean "denser", then clip extremes to keep the downstream math stable.
    (forestFrequencySetting - defaultForestFrequency) / Math.max(1, defaultForestFrequency),
    -1.5,
    1.5
  );
  const mountainFrequencyNormalized = clamp(mountainFrequencySetting / 100, 0, 1);
  const riverFrequencyNormalized = clamp(riverFrequencySetting / 100, 0, 1);
  const humanSettlementFrequencyNormalized = clamp(humanSettlementFrequencySetting / 100, 0, 1);
  const dwarfSettlementFrequencyNormalized = clamp(dwarfSettlementFrequencySetting / 100, 0, 1);
  const woodElfSettlementFrequencyNormalized = clamp(woodElfSettlementFrequencySetting / 100, 0, 1);
  const lizardmenSettlementFrequencyNormalized = clamp(
    lizardmenSettlementFrequencySetting / 100,
    0,
    1
  );
  const towerSettlementFrequencySetting =
    (humanSettlementFrequencySetting + dwarfSettlementFrequencySetting) / 2;
  const towerSettlementFrequencyNormalized = clamp(towerSettlementFrequencySetting / 100, 0, 1);
  const humanSettlementMultiplier = computeFrequencyMultiplier(humanSettlementFrequencySetting);
  const dwarfSettlementMultiplier = computeFrequencyMultiplier(dwarfSettlementFrequencySetting);
  const woodElfSettlementMultiplier = computeFrequencyMultiplier(woodElfSettlementFrequencySetting);
  const lizardmenSettlementMultiplier = computeFrequencyMultiplier(lizardmenSettlementFrequencySetting);
  const towerSettlementMultiplier = computeFrequencyMultiplier(towerSettlementFrequencySetting);
  const mountainBiasLinear = mountainFrequencyNormalized * 2 - 1;
  const mountainBias =
    mountainBiasLinear === 0
      ? 0
      : Math.sign(mountainBiasLinear) * Math.pow(Math.abs(mountainBiasLinear), 0.8);
  const mountainScarcity = 1 - mountainFrequencyNormalized;
  const mountainGrowthFactor = 0.42 + mountainFrequencyNormalized * 0.7;

  const useArchipelagoIslandPlacement = profile.key === 'archipelago';
  const archipelagoFields = useArchipelagoIslandPlacement
    ? generateArchipelagoIslandFields(width, height, rng, seedNumber)
    : null;

  const continentalPlates = generateContinentalPlates(rng, {
    profileKey: profile.key,
    landMask: state.landMask
  });
  const elevationField = new Float32Array(width * height);
  const tectonicActivityField = new Float32Array(width * height);

  const baseNoiseOffsetX = rng() * 2048;
  const baseNoiseOffsetY = rng() * 2048;
  const detailNoiseOffsetX = rng() * 4096;
  const detailNoiseOffsetY = rng() * 4096;

  const baseNoiseScale = sampleRange(rng, profile.baseNoiseScaleRange, 1.2, 2);
  const detailNoiseScale = sampleRange(rng, profile.detailNoiseScaleRange, 3.6, 6.8);
  const ridgeNoiseScale = sampleRange(rng, profile.ridgeNoiseScaleRange, 6.4, 10.6);
  const edgeTaper = sampleRange(rng, profile.edgeTaperRange, 2.4, 3.2);
  const edgeDrop = sampleRange(rng, profile.edgeDropRange, 0.28, 0.42);

  const baseNoiseSeed = (seedNumber + 0x9e3779b9) >>> 0;
  const detailNoiseSeed = (seedNumber + 0x85ebca6b) >>> 0;
  const ridgeNoiseSeed = (seedNumber + 0xc2b2ae35) >>> 0;
  const ridgeDetailSeed = (seedNumber + 0x4cf5ad43) >>> 0;
  const ridgeOrientationSeed = (seedNumber + 0x94d049bb) >>> 0;
  const ridgeDetailOffsetX = rng() * 8192;
  const ridgeDetailOffsetY = rng() * 8192;
  const ridgeOrientationOffsetX = rng() * 4096;
  const ridgeOrientationOffsetY = rng() * 4096;

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;

      if (useArchipelagoIslandPlacement && archipelagoFields) {
        const heightValue = clamp(archipelagoFields.heights[idx], -1, 1);
        const tectonicValue = clamp(archipelagoFields.tectonics[idx], 0, 1);
        elevationField[idx] = heightValue;
        tectonicActivityField[idx] = tectonicValue;
        continue;
      }

      const normalizedX = (x + 0.5) / width;
      const normalizedY = (y + 0.5) / height;
      const plateSample = sampleContinentalPlates(normalizedX, normalizedY, continentalPlates);
      tectonicActivityField[idx] = plateSample.tectonic;

      const baseNoise = octaveNoise(
        (normalizedX + baseNoiseOffsetX) * baseNoiseScale,
        (normalizedY + baseNoiseOffsetY) * baseNoiseScale,
        baseNoiseSeed,
        3,
        0.6,
        1.9
      );

      const detailNoise = octaveNoise(
        (normalizedX + detailNoiseOffsetX) * detailNoiseScale,
        (normalizedY + detailNoiseOffsetY) * detailNoiseScale,
        detailNoiseSeed,
        4,
        0.55,
        2.2
      );

      const ridgeNoise = octaveNoise(
        (normalizedX + detailNoiseOffsetX * 0.5) * ridgeNoiseScale,
        (normalizedY + detailNoiseOffsetY * 0.5) * ridgeNoiseScale,
        ridgeNoiseSeed,
        2,
        0.45,
        2.4
      );

      const maskSample = sampleLandMask(normalizedX, normalizedY);
      const edgeDistance = Math.min(normalizedX, 1 - normalizedX, normalizedY, 1 - normalizedY);
      const edgeFalloff = clamp(1 - edgeDistance * edgeTaper, 0, 1);

      let heightValue = plateSample.height;
      heightValue = lerp(heightValue, plateSample.mask, 0.35);
      heightValue += (baseNoise - 0.5) * (0.35 + plateSample.mask * 0.25);
      heightValue += (detailNoise - 0.5) * 0.18;
      heightValue += (ridgeNoise - 0.5) * 0.1 * plateSample.mask;
      heightValue -= edgeFalloff * edgeFalloff * edgeDrop;

      if (maskSample !== null && maskSample !== undefined) {
        heightValue = lerp(heightValue, maskSample, maskInfluence);
      }

      heightValue = clamp(heightValue, -1, 1);
      elevationField[idx] = heightValue;
    }
  }

  normalizeField(elevationField);
  normalizeField(tectonicActivityField);

  const { seaLevel } = estimateSeaLevels(elevationField, targetWaterRatio);
  const rainfallField = new Float32Array(width * height);
  const drainageField = new Float32Array(width * height);
  const rainfallBaseSeed = (seedNumber + 0x7f4a7c15) >>> 0;
  const rainfallDetailSeed = (seedNumber + 0x6c8e9cf1) >>> 0;
  const rainfallBaseScale = 2.2 + rng() * 1.8;
  const rainfallDetailScale = 5.4 + rng() * 4.1;
  const rainfallBaseOffsetX = rng() * 4096;
  const rainfallBaseOffsetY = rng() * 4096;
  const rainfallDetailOffsetX = rng() * 8192;
  const rainfallDetailOffsetY = rng() * 8192;
  const drainageNoiseSeed = (seedNumber + 0x51a7f5d3) >>> 0;
  const drainageNoiseOffsetX = rng() * 4096;
  const drainageNoiseOffsetY = rng() * 4096;
  const drainageNoiseScale = 4.3 + rng() * 3.6;
  const drainageOffsets = [
    [-1, 0],
    [1, 0],
    [0, -1],
    [0, 1],
    [-1, -1],
    [1, -1],
    [-1, 1],
    [1, 1]
  ];

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      const normalizedX = (x + 0.5) / width;
      const normalizedY = (y + 0.5) / height;
      const elevationValue = elevationField[idx];
      const baseRainNoise = octaveNoise(
        (normalizedX + rainfallBaseOffsetX) * rainfallBaseScale,
        (normalizedY + rainfallBaseOffsetY) * rainfallBaseScale,
        rainfallBaseSeed,
        3,
        0.6,
        2.05
      );
      const detailRainNoise = octaveNoise(
        (normalizedX + rainfallDetailOffsetX) * rainfallDetailScale,
        (normalizedY + rainfallDetailOffsetY) * rainfallDetailScale,
        rainfallDetailSeed,
        4,
        0.55,
        2.25
      );
      const latitudeInfluence = 1 - Math.abs(normalizedY - 0.5) * 1.8;
      const coastalInfluence = clamp(1 - Math.abs(elevationValue - seaLevel) * 2.4, 0, 1);
      let rainfallValue = baseRainNoise * 0.65 + detailRainNoise * 0.35;
      rainfallValue = clamp(
        rainfallValue * 0.55 + latitudeInfluence * 0.25 + coastalInfluence * 0.2 + rainfallBias,
        0,
        1
      );
      rainfallField[idx] = rainfallValue;

      let outwardSlope = 0;
      let inwardSlope = 0;
      let neighborCount = 0;
      for (let i = 0; i < drainageOffsets.length; i += 1) {
        const nx = x + drainageOffsets[i][0];
        const ny = y + drainageOffsets[i][1];
        if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
          continue;
        }
        const nIdx = ny * width + nx;
        const diff = elevationValue - elevationField[nIdx];
        if (diff > 0) {
          outwardSlope += diff;
        } else {
          inwardSlope += -diff;
        }
        neighborCount += 1;
      }
      const slopeAverage = neighborCount > 0 ? outwardSlope / neighborCount : 0;
      const basinAverage = neighborCount > 0 ? inwardSlope / neighborCount : 0;
      const slopeComponent = clamp(slopeAverage * 5.2, 0, 1);
      const basinComponent = clamp(basinAverage * 3.2, 0, 1);
      const drainageNoise = octaveNoise(
        (normalizedX + drainageNoiseOffsetX) * drainageNoiseScale,
        (normalizedY + drainageNoiseOffsetY) * drainageNoiseScale,
        drainageNoiseSeed,
        3,
        0.6,
        2.2
      );
      let drainageValue = slopeComponent * 0.7 + (1 - basinComponent) * 0.3;
      drainageValue = clamp(drainageValue * 0.68 + drainageNoise * 0.32, 0, 1);
      if (elevationValue <= seaLevel) {
        drainageValue = 1;
      }
      drainageField[idx] = drainageValue;
    }
  }

  const adjustedRainfall = applyRainShadow(elevationField, rainfallField, width, height);
  rainfallField.set(adjustedRainfall);
  normalizeField(drainageField);
  const grassTileKey = resolveTileName('GRASS');
  const hasMarshTile = tileLookup.has('MARSH');
  const marshTileKey = hasMarshTile ? 'MARSH' : grassTileKey;
  const waterTileKey = resolveTileName('WATER');
  const hasLavaTile = tileLookup.has('LAVA');
  const lavaTileKey = hasLavaTile ? 'LAVA' : null;
  const hasSnowTile = tileLookup.has('SNOW');
  const snowTileKey = hasSnowTile ? 'SNOW' : grassTileKey;
  // Enable desert generation so sand tiles can appear on the world map.
  const sandGenerationEnabled = true;
  const hasSandTile = sandGenerationEnabled && tileLookup.has('SAND');
  const sandTileKey = hasSandTile ? 'SAND' : grassTileKey;
  const oasisTileKey = hasSandTile && tileLookup.has('OASIS') ? 'OASIS' : null;
  const hasBadlandsTile = sandGenerationEnabled && tileLookup.has('BADLANDS');
  const badlandsTileKey = hasBadlandsTile ? 'BADLANDS' : sandTileKey;
  const hasStoneTile = tileLookup.has('STONE');
  const stoneTileKey = hasStoneTile ? 'STONE' : grassTileKey;
  const landBaseKeys = new Set([grassTileKey]);
  if (hasSnowTile) {
    landBaseKeys.add(snowTileKey);
  }
  if (hasSandTile) {
    landBaseKeys.add(sandTileKey);
  }
  if (hasBadlandsTile) {
    landBaseKeys.add(badlandsTileKey);
  }
  if (hasStoneTile) {
    landBaseKeys.add(stoneTileKey);
  }

  const volcanoStoneAreaNoiseSeed = (seedNumber + 0x27d4eb2d) >>> 0;
  const volcanoStoneDetailNoiseSeed = (seedNumber + 0x165667b1) >>> 0;
  const volcanoStoneAreaNoiseScale = 0.18 + rng() * 0.06;
  const volcanoStoneAreaNoiseOffsetX = rng() * 1024;
  const volcanoStoneAreaNoiseOffsetY = rng() * 1024;
  const maybeConvertBaseToStoneNearVolcano = (tile, x, y, proximity = 1) => {
    if (!tile || !stoneTileKey) {
      return;
    }
    if (tile.base !== grassTileKey && tile.base !== snowTileKey) {
      return;
    }

    const clampedProximity = clamp(Number.isFinite(proximity) ? proximity : 0, 0, 1);
    if (clampedProximity <= 0) {
      return;
    }

    if (clampedProximity >= 0.95) {
      tile.base = stoneTileKey;
      return;
    }

    const coarseSampleX =
      (x + volcanoStoneAreaNoiseOffsetX) * volcanoStoneAreaNoiseScale;
    const coarseSampleY =
      (y + volcanoStoneAreaNoiseOffsetY) * volcanoStoneAreaNoiseScale;
    const coarseNoise = valueNoise(coarseSampleX, coarseSampleY, volcanoStoneAreaNoiseSeed) - 0.5;
    const fineNoise = hashCoords(x, y, volcanoStoneDetailNoiseSeed) - 0.5;
    const noiseInfluence = coarseNoise * 0.55 + fineNoise * 0.25;
    const conversionScore = clampedProximity + noiseInfluence;
    const conversionThreshold = 0.58 - clampedProximity * 0.3;

    if (conversionScore >= conversionThreshold) {
      tile.base = stoneTileKey;
    }
  };
  if (hasMarshTile) {
    landBaseKeys.add(marshTileKey);
  }
  if (hasLavaTile && lavaTileKey) {
    landBaseKeys.add(lavaTileKey);
  }
  const snowLatitudeStart = 0.7;
  const snowLatitudeFull = 0.86;
  const snowLatitudeRange = Math.max(snowLatitudeFull - snowLatitudeStart, 0.0001);
  const snowNoiseSeed = (seedNumber + 0x27d4eb2d) >>> 0;
  const snowNoiseScale = 5.3 + rng() * 3.2;
  const snowNoiseOffsetX = rng() * 4096;
  const snowNoiseOffsetY = rng() * 4096;

  const computeSnowPresence = (normalizedX, normalizedY, heightValue) => {
    const latitude = 1 - normalizedY;
    if (latitude >= snowLatitudeFull) {
      return true;
    }
    if (latitude > snowLatitudeStart) {
      const snowBandFactor = clamp((latitude - snowLatitudeStart) / snowLatitudeRange, 0, 1);
      const elevationFactor = clamp((heightValue - seaLevel) * 3.8, 0, 1);
      const coverage = clamp(snowBandFactor * 0.7 + elevationFactor * 0.3, 0, 1);
      const snowNoise = octaveNoise(
        (normalizedX + snowNoiseOffsetX) * snowNoiseScale,
        (normalizedY + snowNoiseOffsetY) * snowNoiseScale,
        snowNoiseSeed,
        3,
        0.55,
        2.2
      );
      return snowNoise < coverage;
    }
    return false;
  };

  const icebergOverlayKeys = Object.keys(icebergTileCoords).filter((key) => tileLookup.has(key));
  const hasIcebergOverlay = icebergOverlayKeys.length > 0;
  const needSnowPresenceField = hasSnowTile || hasIcebergOverlay;
  const snowPresenceField = needSnowPresenceField ? new Uint8Array(width * height) : null;
  const icebergVariantSeed = hasIcebergOverlay ? (seedNumber + 0x3d0e12f7) >>> 0 : 0;
  const icebergPresenceSeed = hasIcebergOverlay ? (seedNumber + 0x5ad1f32b) >>> 0 : 0;
  let snowDistanceField = null;

  const marshNoiseSeed = hasMarshTile ? (seedNumber + 0x1922b3a5) >>> 0 : 0;
  const marshNoiseScale = hasMarshTile ? 2.2 + rng() * 1.6 : 1;
  const marshNoiseOffsetX = hasMarshTile ? rng() * 4096 : 0;
  const marshNoiseOffsetY = hasMarshTile ? rng() * 4096 : 0;
  const marshWarpSeedX = hasMarshTile ? (seedNumber + 0x0c1b9d17) >>> 0 : 0;
  const marshWarpSeedY = hasMarshTile ? (seedNumber + 0x91e10dac) >>> 0 : 0;
  const marshWarpScale = hasMarshTile ? 2.6 + rng() * 2.4 : 1;
  const marshWarpStrength = hasMarshTile ? 0.08 + rng() * 0.12 : 0;
  const marshWarpOffsetX = hasMarshTile ? rng() * 4096 : 0;
  const marshWarpOffsetY = hasMarshTile ? rng() * 4096 : 0;
  const marshSuitabilitySeed = hasMarshTile ? (seedNumber + 0x243f6a88) >>> 0 : 0;
  const marshSuitabilityScale = hasMarshTile ? 2.8 + rng() * 2.6 : 1;
  const marshSuitabilityOffsetX = hasMarshTile ? rng() * 4096 : 0;
  const marshSuitabilityOffsetY = hasMarshTile ? rng() * 4096 : 0;
  const marshSuitabilityStrength = hasMarshTile ? 0.16 + rng() * 0.14 : 0;
  const marshVariationSeed = hasMarshTile ? (seedNumber + 0x13198a2e) >>> 0 : 0;
  const marshVariationScale = hasMarshTile ? 3.4 + rng() * 3 : 1;
  const marshVariationOffsetX = hasMarshTile ? rng() * 4096 : 0;
  const marshVariationOffsetY = hasMarshTile ? rng() * 4096 : 0;
  const marshVariationStrength = hasMarshTile ? 0.12 + rng() * 0.11 : 0;
  const marshThresholdSeed = hasMarshTile ? (seedNumber + 0xa4093822) >>> 0 : 0;
  const marshThresholdScale = hasMarshTile ? 2.6 + rng() * 2.8 : 1;
  const marshThresholdOffsetX = hasMarshTile ? rng() * 4096 : 0;
  const marshThresholdOffsetY = hasMarshTile ? rng() * 4096 : 0;
  const marshThresholdStrength = hasMarshTile ? 0.05 + rng() * 0.05 : 0;
  const marshDistributionStrength = hasMarshTile ? 0.1 + rng() * 0.1 : 0;
  const baseMarshThreshold = 0.65;
  // Require more rainfall-driven wetness before marshes can form to reduce their frequency.
  const marshWetnessThreshold = 0.66;
  const marshSuitabilityField = hasMarshTile ? new Float32Array(width * height) : null;
  const marshMaskField = hasMarshTile ? new Uint8Array(width * height) : null;
  const desertNoiseSeed = hasSandTile ? (seedNumber + 0x51b74f03) >>> 0 : 0;
  const desertNoiseScale = hasSandTile ? 3.8 + rng() * 2.6 : 1;
  const desertNoiseOffsetX = hasSandTile ? rng() * 4096 : 0;
  const desertNoiseOffsetY = hasSandTile ? rng() * 4096 : 0;
  const desertWarpSeedX = hasSandTile ? (seedNumber + 0x2a58d2a5) >>> 0 : 0;
  const desertWarpSeedY = hasSandTile ? (seedNumber + 0x165667b1) >>> 0 : 0;
  const desertWarpScale = hasSandTile ? 2.2 + rng() * 2.6 : 1;
  const desertWarpStrength = hasSandTile ? 0.12 + rng() * 0.18 : 0;
  const desertWarpOffsetX = hasSandTile ? rng() * 4096 : 0;
  const desertWarpOffsetY = hasSandTile ? rng() * 4096 : 0;
  const desertHeatSeed = hasSandTile ? (seedNumber + 0x3b1d23c7) >>> 0 : 0;
  const desertHeatScale = hasSandTile ? 3.1 + rng() * 3.3 : 1;
  const desertHeatOffsetX = hasSandTile ? rng() * 4096 : 0;
  const desertHeatOffsetY = hasSandTile ? rng() * 4096 : 0;
  const desertBandSeed = hasSandTile ? (seedNumber + 0x6a09e667) >>> 0 : 0;
  const desertBandScale = hasSandTile ? 1.4 + rng() * 1.6 : 1;
  const desertBandOffsetX = hasSandTile ? rng() * 2048 : 0;
  const desertBandOffsetY = hasSandTile ? rng() * 2048 : 0;
  const desertBandStrength = hasSandTile ? 0.12 + rng() * 0.18 : 0;
  const desertBandSeedSecondary = hasSandTile ? (seedNumber + 0x1f83d9ab) >>> 0 : 0;
  const desertBandSeedTertiary = hasSandTile ? (seedNumber + 0x5be0cd19) >>> 0 : 0;
  const desertBandScaleSecondary = hasSandTile ? desertBandScale * (0.85 + rng() * 0.5) : 1;
  const desertBandScaleTertiary = hasSandTile ? desertBandScale * (0.75 + rng() * 0.6) : 1;
  const desertBandOffsetXSecondary = hasSandTile ? rng() * 2048 : 0;
  const desertBandOffsetYSecondary = hasSandTile ? rng() * 2048 : 0;
  const desertBandOffsetXTertiary = hasSandTile ? rng() * 2048 : 0;
  const desertBandOffsetYTertiary = hasSandTile ? rng() * 2048 : 0;
  const desertBandRotation = hasSandTile ? rng() * Math.PI * 2 : 0;
  const desertBandRotationSecondary = hasSandTile ? rng() * Math.PI * 2 : 0;
  const desertBandCos = Math.cos(desertBandRotation);
  const desertBandSin = Math.sin(desertBandRotation);
  const desertBandCosSecondary = Math.cos(desertBandRotationSecondary);
  const desertBandSinSecondary = Math.sin(desertBandRotationSecondary);
  const desertSuitabilitySeed = hasSandTile ? (seedNumber + 0xbb67ae85) >>> 0 : 0;
  const desertSuitabilityScale = hasSandTile ? 2.8 + rng() * 2.8 : 1;
  const desertSuitabilityOffsetX = hasSandTile ? rng() * 8192 : 0;
  const desertSuitabilityOffsetY = hasSandTile ? rng() * 8192 : 0;
  const desertSuitabilityStrength = hasSandTile ? 0.18 + rng() * 0.15 : 0;
  const desertThresholdSeed = hasSandTile ? (seedNumber + 0x84caa73d) >>> 0 : 0;
  const desertThresholdScale = hasSandTile ? 3.6 + rng() * 3.2 : 1;
  const desertThresholdOffsetX = hasSandTile ? rng() * 4096 : 0;
  const desertThresholdOffsetY = hasSandTile ? rng() * 4096 : 0;
  const desertThresholdStrength = hasSandTile ? 0.05 + rng() * 0.06 : 0;
  const desertVariationSeed = hasSandTile ? (seedNumber + 0x7c3f0a5b) >>> 0 : 0;
  const desertVariationScale = hasSandTile ? 4.4 + rng() * 3.8 : 1;
  const desertVariationOffsetX = hasSandTile ? rng() * 4096 : 0;
  const desertVariationOffsetY = hasSandTile ? rng() * 4096 : 0;
  const desertVariationStrength = hasSandTile ? 0.08 + rng() * 0.07 : 0;
  const desertSuitabilityField = hasSandTile ? new Float32Array(width * height) : null;
  const desertHeatField = hasSandTile ? new Float32Array(width * height) : null;
  const desertMask = hasSandTile ? new Uint8Array(width * height) : null;
  const badlandsMask = hasBadlandsTile ? new Uint8Array(width * height) : null;
  const desertBadlandsSeed = hasBadlandsTile ? (seedNumber + 0x428a2f98) >>> 0 : 0;
  const desertBadlandsScale = hasBadlandsTile ? 3.4 + rng() * 3.6 : 1;
  const desertBadlandsOffsetX = hasBadlandsTile ? rng() * 4096 : 0;
  const desertBadlandsOffsetY = hasBadlandsTile ? rng() * 4096 : 0;

  const sampleLatitudeWarp = (normalizedX, normalizedY, latitude) => {
    if (!hasSandTile || desertWarpStrength <= 0) {
      return { warpX: 0, warpY: 0, warpedLatitude: latitude };
    }
    const warpSampleX = octaveNoise(
      (normalizedX + desertWarpOffsetX) * desertWarpScale,
      (normalizedY + desertWarpOffsetY) * desertWarpScale,
      desertWarpSeedX,
      3,
      0.55,
      2.05
    );
    const warpSampleY = octaveNoise(
      (normalizedX + desertWarpOffsetX + 37.71) * (desertWarpScale * 1.1),
      (normalizedY + desertWarpOffsetY + 11.53) * (desertWarpScale * 0.92),
      desertWarpSeedY,
      3,
      0.55,
      2.05
    );
    const warpX = (warpSampleX * 2 - 1) * desertWarpStrength;
    const warpY = (warpSampleY * 2 - 1) * desertWarpStrength;
    return { warpX, warpY, warpedLatitude: clamp(latitude + warpY * 0.8, 0, 1) };
  };

  const calculateMarshSuitability = (
    x,
    y,
    heightValue,
    rainfallValue,
    drainageValue,
    recordFields
  ) => {
    const idx = y * width + x;
    if (!hasMarshTile || heightValue <= seaLevel) {
      if (recordFields && marshSuitabilityField) {
        marshSuitabilityField[idx] = 0;
      }
      if (recordFields && marshMaskField) {
        marshMaskField[idx] = 0;
      }
      return { score: -Infinity, threshold: baseMarshThreshold, qualifies: false };
    }
    const normalizedX = (x + 0.5) / width;
    const normalizedY = (y + 0.5) / height;
    if (rainfallValue === undefined) {
      rainfallValue = rainfallField[idx];
    }
    if (drainageValue === undefined) {
      drainageValue = drainageField[idx];
    }
    const latitude = 1 - normalizedY;
    const { warpedLatitude } = sampleLatitudeWarp(normalizedX, normalizedY, latitude);
    const equatorialAlignment = clamp(1 - Math.abs(warpedLatitude - 0.5) * 2, 0, 1);
    const elevationAboveSea = heightValue - seaLevel;
    const positiveElevation = Math.max(0, elevationAboveSea);
    const elevationPenalty = clamp(positiveElevation * 3.4, 0, 1);
    const heat = clamp(equatorialAlignment * 0.6 + (1 - elevationPenalty) * 0.4, 0, 1);
    const wetness = clamp(rainfallValue * 0.75 + (1 - drainageValue) * 0.25, 0, 1);
    const lowlandFactor = clamp(1 - positiveElevation * 4.2, 0, 1);
    const baseSuitability = clamp(wetness * 0.68 + lowlandFactor * 0.2 + heat * 0.12, 0, 1);
    if (wetness <= marshWetnessThreshold || lowlandFactor <= 0.22 || heat <= 0.45) {
      if (recordFields && marshSuitabilityField) {
        marshSuitabilityField[idx] = baseSuitability;
      }
      if (recordFields && marshMaskField) {
        marshMaskField[idx] = 0;
      }
      return { score: -Infinity, threshold: baseMarshThreshold, qualifies: false };
    }
    let warpX = 0;
    let warpY = 0;
    if (marshWarpStrength > 0) {
      const warpSampleX = octaveNoise(
        (normalizedX + marshWarpOffsetX) * marshWarpScale,
        (normalizedY + marshWarpOffsetY) * marshWarpScale,
        marshWarpSeedX,
        3,
        0.55,
        2.05
      );
      const warpSampleY = octaveNoise(
        (normalizedX + marshWarpOffsetX + 17.31) * (marshWarpScale * 0.94),
        (normalizedY + marshWarpOffsetY + 23.77) * (marshWarpScale * 1.06),
        marshWarpSeedY,
        3,
        0.55,
        2.05
      );
      warpX = (warpSampleX * 2 - 1) * marshWarpStrength;
      warpY = (warpSampleY * 2 - 1) * marshWarpStrength;
    }
    let suitability = baseSuitability;
    if (marshSuitabilityStrength > 0) {
      const suitabilityNoise =
        octaveNoise(
          (normalizedX + warpX + marshSuitabilityOffsetX) * marshSuitabilityScale,
          (normalizedY + warpY + marshSuitabilityOffsetY) * marshSuitabilityScale,
          marshSuitabilitySeed,
          4,
          0.55,
          2.15
        ) *
          2 -
        1;
      suitability = clamp(suitability + suitabilityNoise * marshSuitabilityStrength, 0, 1);
    }
    if (marshVariationStrength > 0) {
      const variationNoise =
        octaveNoise(
          (normalizedX + warpX + marshVariationOffsetX) * marshVariationScale,
          (normalizedY + warpY + marshVariationOffsetY) * marshVariationScale,
          marshVariationSeed,
          4,
          0.55,
          2.1
        ) *
          2 -
        1;
      suitability = clamp(suitability + variationNoise * marshVariationStrength, 0, 1);
    }
    if (marshDistributionStrength > 0) {
      const distributionNoise =
        octaveNoise(
          (normalizedX + warpX + marshNoiseOffsetX) * marshNoiseScale,
          (normalizedY + warpY + marshNoiseOffsetY) * marshNoiseScale,
          marshNoiseSeed,
          3,
          0.55,
          2.15
        ) *
          2 -
        1;
      suitability = clamp(suitability + distributionNoise * marshDistributionStrength, 0, 1);
    }
    let threshold = baseMarshThreshold;
    if (marshThresholdStrength > 0) {
      const thresholdNoise =
        octaveNoise(
          (normalizedX + warpX + marshThresholdOffsetX) * marshThresholdScale,
          (normalizedY + warpY + marshThresholdOffsetY) * marshThresholdScale,
          marshThresholdSeed,
          3,
          0.55,
          2.1
        ) *
          2 -
        1;
      threshold = clamp(threshold + thresholdNoise * marshThresholdStrength, 0.5, 0.7);
    }
    let touchesSurfaceWater = false;
    let nearSeaLevelNeighborCount = 0;
    let lowerNeighborCount = 0;
    for (let dy = -1; dy <= 1; dy += 1) {
      for (let dx = -1; dx <= 1; dx += 1) {
        if (dx === 0 && dy === 0) {
          continue;
        }
        const nx = x + dx;
        const ny = y + dy;
        if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
          continue;
        }
        const nIdx = ny * width + nx;
        const neighborElevation = elevationField[nIdx];
        if (neighborElevation <= seaLevel) {
          touchesSurfaceWater = true;
        }
        if (neighborElevation <= seaLevel + 0.02) {
          nearSeaLevelNeighborCount += 1;
        }
        if (neighborElevation < heightValue) {
          lowerNeighborCount += 1;
        }
      }
    }
    const inlandMarshCandidate =
      !touchesSurfaceWater &&
      nearSeaLevelNeighborCount >= 4 &&
      wetness > marshWetnessThreshold + 0.05 &&
      drainageValue < 0.42 &&
      lowlandFactor > 0.34 &&
      lowerNeighborCount >= 2;
    if (inlandMarshCandidate && !touchesSurfaceWater) {
      threshold = clamp(threshold + 0.03, 0.5, 0.75);
    }
    const qualifiesByScore = suitability > threshold;
    if (recordFields && marshSuitabilityField) {
      marshSuitabilityField[idx] = suitability;
    }
    if (!touchesSurfaceWater && !inlandMarshCandidate) {
      if (recordFields && marshMaskField) {
        marshMaskField[idx] = 0;
      }
      return { score: -Infinity, threshold, qualifies: false };
    }
    if (!qualifiesByScore) {
      if (recordFields && marshMaskField) {
        marshMaskField[idx] = 0;
      }
      return { score: suitability, threshold, qualifies: false };
    }
    if (recordFields && marshMaskField) {
      marshMaskField[idx] = 1;
    }
    return { score: suitability, threshold, qualifies: true };
  };

  const computeMarshSuitabilityScore = (x, y, heightValue) => {
    const idx = y * width + x;
    const rainfallValue = rainfallField[idx];
    const drainageValue = drainageField[idx];
    return calculateMarshSuitability(
      x,
      y,
      heightValue,
      rainfallValue,
      drainageValue,
      false
    ).score;
  };

  const determineLandBaseTile = (x, y, heightValue) => {
    const normalizedX = (x + 0.5) / width;
    const normalizedY = (y + 0.5) / height;
    const latitude = 1 - normalizedY;
    const { warpX, warpY, warpedLatitude } = sampleLatitudeWarp(normalizedX, normalizedY, latitude);
    const idx = y * width + x;

    if (hasSandTile) {
      desertSuitabilityField[idx] = 0;
      desertMask[idx] = 0;
    }
    if (hasMarshTile) {
      marshSuitabilityField[idx] = 0;
      marshMaskField[idx] = 0;
    }

    if (hasSnowTile && computeSnowPresence(normalizedX, normalizedY, heightValue)) {
      return snowTileKey;
    }

    const rainfallValue = rainfallField[idx];
    const drainageValue = drainageField[idx];
    if (hasMarshTile) {
      const marshEvaluation = calculateMarshSuitability(
        x,
        y,
        heightValue,
        rainfallValue,
        drainageValue,
        true
      );
      if (marshEvaluation.qualifies) {
        return marshTileKey;
      }
    }

    if (hasSandTile) {
      const aridity = clamp(1 - rainfallValue * 1.2, 0, 1);
      let equatorialAlignment = clamp(1 - Math.abs(warpedLatitude - 0.5) * 2, 0, 1);
      if (desertBandStrength > 0) {
        const bandNoisePrimary = octaveNoise(
          (normalizedX + desertBandOffsetX) * desertBandScale,
          (normalizedY + desertBandOffsetY) * desertBandScale,
          desertBandSeed,
          4,
          0.55,
          2.1
        );
        const centeredX = normalizedX - 0.5;
        const centeredY = normalizedY - 0.5;
        const rotatedPrimaryX = centeredX * desertBandCos - centeredY * desertBandSin;
        const rotatedPrimaryY = centeredX * desertBandSin + centeredY * desertBandCos;
        const bandNoiseSecondary = octaveNoise(
          (rotatedPrimaryX + 0.5 + desertBandOffsetXSecondary) * desertBandScaleSecondary,
          (rotatedPrimaryY + 0.5 + desertBandOffsetYSecondary) * desertBandScaleSecondary,
          desertBandSeedSecondary,
          4,
          0.55,
          2.1
        );
        const rotatedSecondaryX = centeredX * desertBandCosSecondary - centeredY * desertBandSinSecondary;
        const rotatedSecondaryY = centeredX * desertBandSinSecondary + centeredY * desertBandCosSecondary;
        const bandNoiseTertiary = octaveNoise(
          (rotatedSecondaryX + 0.5 + desertBandOffsetXTertiary) * desertBandScaleTertiary,
          (rotatedSecondaryY + 0.5 + desertBandOffsetYTertiary) * desertBandScaleTertiary,
          desertBandSeedTertiary,
          4,
          0.55,
          2.1
        );
        const combinedBandNoise = (bandNoisePrimary + bandNoiseSecondary + bandNoiseTertiary) / 3;
        const bandWarp = (combinedBandNoise * 2 - 1) * desertBandStrength;
        equatorialAlignment = clamp(equatorialAlignment + bandWarp, 0, 1);
      }
      const elevationFactor = clamp((heightValue - seaLevel) * 2.6, 0, 1);
      const desertHeatNoise =
        (octaveNoise(
          (normalizedX + warpX + desertHeatOffsetX) * desertHeatScale,
          (normalizedY + warpY + desertHeatOffsetY) * desertHeatScale,
          desertHeatSeed,
          4,
          0.55,
          2.2
        ) *
          2 -
          1) *
        0.25;
      const heat = clamp(equatorialAlignment * 0.55 + (1 - elevationFactor) * 0.3 + desertHeatNoise, 0, 1);
      if (desertHeatField) {
        desertHeatField[idx] = heat;
      }
      let suitability = clamp(aridity * 0.68 + heat * 0.42, 0, 1);
      if (desertSuitabilityStrength > 0) {
        const suitabilityNoise =
          octaveNoise(
            (normalizedX + warpX + desertSuitabilityOffsetX) * desertSuitabilityScale,
            (normalizedY + warpY + desertSuitabilityOffsetY) * desertSuitabilityScale,
            desertSuitabilitySeed,
            4,
            0.55,
            2.2
          ) *
            2 -
          1;
        suitability = clamp(
          suitability + suitabilityNoise * desertSuitabilityStrength,
            0,
            1
        );
      }
      if (desertVariationStrength > 0) {
        const variationNoise =
          octaveNoise(
            (normalizedX + warpX + desertVariationOffsetX) * desertVariationScale,
            (normalizedY + warpY + desertVariationOffsetY) * desertVariationScale,
            desertVariationSeed,
            4,
            0.55,
            2.15
          ) *
            2 -
          1;
        suitability = clamp(
          suitability + variationNoise * desertVariationStrength,
          0,
          1
        );
      }
      desertSuitabilityField[idx] = suitability;
      desertMask[idx] = 0;
      if (suitability > 0.52) {
        const desertNoise = octaveNoise(
          (normalizedX + warpX + desertNoiseOffsetX) * desertNoiseScale,
          (normalizedY + warpY + desertNoiseOffsetY) * desertNoiseScale,
          desertNoiseSeed,
          3,
          0.55,
          2.15
        );
        let latitudeThreshold = lerp(0.58, 0.52, equatorialAlignment);
        if (desertThresholdStrength > 0) {
          const thresholdNoise =
            octaveNoise(
              (normalizedX + warpX + desertThresholdOffsetX) * desertThresholdScale,
              (normalizedY + warpY + desertThresholdOffsetY) * desertThresholdScale,
              desertThresholdSeed,
              3,
              0.55,
              2.1
            ) *
              2 -
            1;
          latitudeThreshold = clamp(
            latitudeThreshold + thresholdNoise * desertThresholdStrength,
            0.45,
            0.65
          );
        }
        if (desertNoise < suitability && suitability > latitudeThreshold) {
          desertMask[idx] = 1;
          return sandTileKey;
        }
      }
    }

    return grassTileKey;
  };

  const isLandBaseTile = (baseKey) => landBaseKeys.has(baseKey);
  const tiles = Array.from(
    { length: height },
    () =>
      Array.from({ length: width }, () => ({
        base: grassTileKey,
        overlay: null,
        hillOverlay: null,
        structure: null,
        structureName: null,
        structureDetails: null,
        ambientStructure: null,
        river: null,
        biomeType: null,
        biomeClusterId: null,
        areaName: null,
        waterDepth: 0,
        coastProximity: 0,
        marshProximity: 0,
        desertProximity: 0,
        volcanoProximity: 0,
        mountainRuggedness: 0,
        forestCanopyDensity: 0,
        elevation: 0,
        temperature: 0,
        moisture: 0
      }))
  );
  const dwarfholds = [];
  const mines = [];
  const hillholds = [];
  const towns = [];
  const towers = [];
  const caves = [];
  const evilWizardTowers = [];
  const towerProximityPoints = [];
  const woodElfGroves = [];
  const lizardmenCities = [];
  const orcCamps = [];
  const gnollCamps = [];
  const trollCamps = [];
  const ogreCamps = [];
  const banditCamps = [];
  const hostileWarCamps = [];
  const centaurEncampments = [];
  const travelerCamps = [];
  const dungeons = [];
  const monasteries = [];
  const castles = [];
  const saintShrines = [];
  const roadsideTaverns = [];
  const hamletPoints = [];
  const hamletPlacementStats = { grass: 0, snow: 0 };
  const recordHamletPlacement = (x, y, isSnow) => {
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      return;
    }
    hamletPoints.push({ x, y });
    if (isSnow) {
      hamletPlacementStats.snow += 1;
    } else {
      hamletPlacementStats.grass += 1;
    }
  };
  const recordTowerProximityPoint = (x, y) => {
    if (Number.isFinite(x) && Number.isFinite(y)) {
      towerProximityPoints.push({ x, y });
    }
  };
  const computeNearestDistanceSq = (x, y, points) => {
    if (!Array.isArray(points) || points.length === 0) {
      return Infinity;
    }
    let best = Infinity;
    for (let i = 0; i < points.length; i += 1) {
      const point = points[i];
      if (!point || !Number.isFinite(point.x) || !Number.isFinite(point.y)) {
        continue;
      }
      const dx = x - point.x;
      const dy = y - point.y;
      const distSq = dx * dx + dy * dy;
      if (distSq < best) {
        best = distSq;
      }
    }
    return best;
  };
  const findNearestPointWithDetails = (x, y, points) => {
    if (!Array.isArray(points) || points.length === 0) {
      return null;
    }
    let bestPoint = null;
    let bestDistanceSq = Infinity;
    for (let i = 0; i < points.length; i += 1) {
      const point = points[i];
      if (!point || !Number.isFinite(point.x) || !Number.isFinite(point.y)) {
        continue;
      }
      const dx = x - point.x;
      const dy = y - point.y;
      const distSq = dx * dx + dy * dy;
      if (distSq < bestDistanceSq) {
        bestDistanceSq = distSq;
        bestPoint = point;
      }
    }
    if (bestPoint === null) {
      return null;
    }
    return {
      point: bestPoint,
      distanceSq: bestDistanceSq,
      distance: Math.sqrt(bestDistanceSq)
    };
  };
  const waterMask = new Uint8Array(width * height);
  let riverMap = null;
  const hasMountainTile = tileLookup.has('MOUNTAIN');
  const mountainOverlayKey = hasMountainTile ? 'MOUNTAIN' : null;
  const mountainPeakKey = hasMountainTile && tileLookup.has('MOUNTAIN_PEAK') ? 'MOUNTAIN_PEAK' : null;
  const activeVolcanoKey = hasMountainTile && tileLookup.has('ACTIVE_VOLCANO') ? 'ACTIVE_VOLCANO' : null;
  const dormantVolcanoKey = hasMountainTile && tileLookup.has('VOLCANO') ? 'VOLCANO' : null;
  const volcanoOverlayKeys = hasMountainTile
    ? [activeVolcanoKey, dormantVolcanoKey].filter(Boolean)
    : [];
  const mountainRuggednessSeed = hasMountainTile ? (seedNumber + 0x8f3a3c4d) >>> 0 : 0;
  const mountainPeakHeightThreshold = 0.97;
  const mountainTopVariantKeys = hasMountainTile
    ? ['MOUNTAIN_TOP_A', 'MOUNTAIN_TOP_B'].filter((key) => tileLookup.has(key))
    : [];
  const mountainBottomVariantKeys = hasMountainTile
    ? ['MOUNTAIN_BOTTOM_A', 'MOUNTAIN_BOTTOM_B'].filter((key) => tileLookup.has(key))
    : [];
  const mountainOverlayKeySet = hasMountainTile
    ? new Set([
        mountainOverlayKey,
        mountainPeakKey,
        ...mountainTopVariantKeys,
        ...mountainBottomVariantKeys,
        ...volcanoOverlayKeys
      ].filter(Boolean))
    : new Set();
  const isMountainOverlay = (overlayKey) =>
    overlayKey != null && mountainOverlayKeySet.has(overlayKey);
  let mountainBaseThreshold = hasMountainTile ? Math.min(Math.max(seaLevel + 0.1, 0.58), 0.82) : 1;
  let mountainFullThreshold = hasMountainTile ? Math.min(0.98, mountainBaseThreshold + 0.35) : 1;
  let mountainRange = hasMountainTile ? Math.max(mountainFullThreshold - mountainBaseThreshold, 0.0001) : 1;
  if (hasMountainTile) {
    const thresholdShift = mountainBias * 0.18;
    const minBaseThreshold = Math.min(
      Math.max(seaLevel + 0.08 + mountainScarcity * 0.05, 0.5),
      0.92
    );
    mountainBaseThreshold = clamp(mountainBaseThreshold - thresholdShift, minBaseThreshold, 0.92);
    mountainFullThreshold = clamp(
      mountainFullThreshold - thresholdShift * 1.3,
      mountainBaseThreshold + 0.12,
      0.99
    );
    mountainRange = Math.max(mountainFullThreshold - mountainBaseThreshold, 0.0001);
  }
  let mountainScores = null;
  let mountainCandidateThreshold = null;
  let mountainMask = null;
  let mountainHeightField = null;
  const cardinalOffsets = [
    [0, -1],
    [1, 0],
    [0, 1],
    [-1, 0]
  ];
  const neighborOffsets8 = [
    [-1, -1],
    [0, -1],
    [1, -1],
    [-1, 0],
    [1, 0],
    [-1, 1],
    [0, 1],
    [1, 1]
  ];

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      const heightValue = elevationField[idx];
      const isWater = heightValue <= seaLevel;
      waterMask[idx] = isWater ? 1 : 0;
      const tile = tiles[y][x];
      tile.base = isWater ? waterTileKey : determineLandBaseTile(x, y, heightValue);
      tile.overlay = null;
      tile.hillOverlay = null;
      tile.structure = null;
      tile.structureName = null;
      tile.structureDetails = null;
      tile.ambientStructure = null;
      tile.river = null;
      tile.biomeType = null;
      tile.biomeClusterId = null;
      tile.areaName = null;
      tile.waterDepth = 0;
      tile.coastProximity = 0;
      tile.desertProximity = 0;
      tile.volcanoProximity = 0;
      tile.elevation = heightValue;
    }
  }

  if (hasSandTile) {
    const isAdjacentToWater = (x, y) => {
      for (let i = 0; i < neighborOffsets8.length; i += 1) {
        const nx = x + neighborOffsets8[i][0];
        const ny = y + neighborOffsets8[i][1];
        if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
          continue;
        }
        const nIdx = ny * width + nx;
        if (waterMask[nIdx]) {
          return true;
        }
      }
      return false;
    };

    const hasAdjacentSand = (x, y, excludeIndices = null) => {
      for (let i = 0; i < neighborOffsets8.length; i += 1) {
        const nx = x + neighborOffsets8[i][0];
        const ny = y + neighborOffsets8[i][1];
        if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
          continue;
        }
        const nIdx = ny * width + nx;
        if (excludeIndices && excludeIndices.has(nIdx)) {
          continue;
        }
        if (tiles[ny][nx].base === sandTileKey) {
          return true;
        }
      }
      return false;
    };

    const blurIterations = 2;
    const blurRadius = 2;
    const smoothingSamples = [];
    for (let dy = -blurRadius; dy <= blurRadius; dy += 1) {
      for (let dx = -blurRadius; dx <= blurRadius; dx += 1) {
        const distance = Math.sqrt(dx * dx + dy * dy);
        const weight = distance === 0 ? 1.25 : 1 / (1 + distance);
        smoothingSamples.push({ dx, dy, weight });
      }
    }
    let blurFieldCurrent = new Float32Array(width * height);
    let blurFieldBuffer = new Float32Array(width * height);
    blurFieldCurrent.set(desertSuitabilityField);

    for (let iteration = 0; iteration < blurIterations; iteration += 1) {
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (waterMask[idx]) {
            blurFieldBuffer[idx] = 0;
            continue;
          }
          const baseTile = tiles[y][x].base;
          if (baseTile === snowTileKey) {
            blurFieldBuffer[idx] = 0;
            continue;
          }
          let weightSum = 0;
          let sampleSum = 0;
          for (let i = 0; i < smoothingSamples.length; i += 1) {
            const { dx, dy, weight } = smoothingSamples[i];
            const nx = x + dx;
            const ny = y + dy;
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            const nIdx = ny * width + nx;
            if (waterMask[nIdx]) {
              continue;
            }
            const neighborTile = tiles[ny][nx].base;
            if (neighborTile === snowTileKey) {
              continue;
            }
            sampleSum += blurFieldCurrent[nIdx] * weight;
            weightSum += weight;
          }
          if (weightSum > 0) {
            blurFieldBuffer[idx] = sampleSum / weightSum;
          } else {
            blurFieldBuffer[idx] = blurFieldCurrent[idx];
          }
        }
      }
      const swap = blurFieldCurrent;
      blurFieldCurrent = blurFieldBuffer;
      blurFieldBuffer = swap;
    }

    const updatedMask = new Uint8Array(width * height);
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          updatedMask[idx] = 0;
          continue;
        }
        const baseTile = tiles[y][x].base;
        if (baseTile === snowTileKey) {
          updatedMask[idx] = 0;
          continue;
        }
        const baseSuitability = desertSuitabilityField[idx];
        const clusteredSuitability = blurFieldCurrent[idx];
        let neighborDesert = 0;
        let neighborCount = 0;
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            continue;
          }
          const neighborTile = tiles[ny][nx].base;
          if (neighborTile === snowTileKey) {
            continue;
          }
          neighborDesert += desertMask[nIdx];
          neighborCount += 1;
        }
        const localDensity = neighborCount > 0 ? neighborDesert / neighborCount : desertMask[idx];
        const combinedScore = baseSuitability * 0.55 + clusteredSuitability * 0.45 + localDensity * 0.15;
        if (combinedScore > 0.62 && baseSuitability > 0.48) {
          updatedMask[idx] = 1;
        } else if (combinedScore < 0.5 || baseSuitability < 0.45) {
          updatedMask[idx] = 0;
        } else {
          updatedMask[idx] = desertMask[idx];
        }
      }
    }

    desertMask.set(updatedMask);

    if (hasSandTile) {
      const verticalIsolation = [];
      for (let y = 1; y < height - 1; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (!desertMask[idx]) {
            continue;
          }
          const aboveIdx = idx - width;
          const belowIdx = idx + width;
          const aboveIsDesert = desertMask[aboveIdx] === 1;
          const belowIsDesert = desertMask[belowIdx] === 1;
          if (!aboveIsDesert && !belowIsDesert) {
            verticalIsolation.push(idx);
          }
        }
      }
      if (verticalIsolation.length > 0) {
        for (let i = 0; i < verticalIsolation.length; i += 1) {
          desertMask[verticalIsolation[i]] = 0;
        }
      }

      const isolatedSingles = [];
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (!desertMask[idx]) {
            continue;
          }
          let hasDesertNeighbor = false;
          for (let i = 0; i < neighborOffsets8.length; i += 1) {
            const nx = x + neighborOffsets8[i][0];
            const ny = y + neighborOffsets8[i][1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            const nIdx = ny * width + nx;
            if (desertMask[nIdx]) {
              hasDesertNeighbor = true;
              break;
            }
          }
          if (!hasDesertNeighbor) {
            isolatedSingles.push(idx);
          }
        }
      }
      if (isolatedSingles.length > 0) {
        for (let i = 0; i < isolatedSingles.length; i += 1) {
          desertMask[isolatedSingles[i]] = 0;
        }
      }
    }

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          if (badlandsMask) {
            badlandsMask[idx] = 0;
          }
          continue;
        }
        if (desertMask[idx]) {
          let baseTileName = sandTileKey;
          if (hasBadlandsTile) {
            const heatValue = desertHeatField ? desertHeatField[idx] : 1;
            const dryness = desertSuitabilityField ? desertSuitabilityField[idx] : heatValue;
            if (heatValue > 0.58 && dryness > 0.5) {
              const normalizedX = (x + 0.5) / width;
              const normalizedY = (y + 0.5) / height;
              const badlandsNoise = octaveNoise(
                (normalizedX + desertBadlandsOffsetX) * desertBadlandsScale,
                (normalizedY + desertBadlandsOffsetY) * desertBadlandsScale,
                desertBadlandsSeed,
                3,
                0.55,
                2.15
              );
              const badlandsLikelihood = clamp((heatValue - 0.58) * 1.25 + (dryness - 0.5) * 0.85, 0, 1);
              if (
                badlandsNoise < badlandsLikelihood &&
                !isAdjacentToWater(x, y) &&
                hasAdjacentSand(x, y)
              ) {
                baseTileName = badlandsTileKey;
              }
            }
          }
          tiles[y][x].base = baseTileName;
          if (badlandsMask) {
            badlandsMask[idx] = baseTileName === badlandsTileKey ? 1 : 0;
          }
        } else if (tiles[y][x].base === sandTileKey || (hasBadlandsTile && tiles[y][x].base === badlandsTileKey)) {
          tiles[y][x].base = grassTileKey;
          if (badlandsMask) {
            badlandsMask[idx] = 0;
          }
        }
      }
    }

    if (badlandsMask) {
      const badlandsFillRadius = 2;
      const badlandsFillOffsets = [];
      for (let dy = -badlandsFillRadius; dy <= badlandsFillRadius; dy += 1) {
        for (let dx = -badlandsFillRadius; dx <= badlandsFillRadius; dx += 1) {
          if (dx === 0 && dy === 0) {
            continue;
          }
          if (Math.max(Math.abs(dx), Math.abs(dy)) > badlandsFillRadius) {
            continue;
          }
          badlandsFillOffsets.push([dx, dy]);
        }
      }
      const badlandsFillIterations = 2;
      for (let iteration = 0; iteration < badlandsFillIterations; iteration += 1) {
        const additions = [];
        for (let y = 0; y < height; y += 1) {
          for (let x = 0; x < width; x += 1) {
            const idx = y * width + x;
            if (!desertMask[idx] || badlandsMask[idx]) {
              continue;
            }
            if (isAdjacentToWater(x, y)) {
              continue;
            }
            let neighborCount = 0;
            let hasLeft = false;
            let hasRight = false;
            let hasUp = false;
            let hasDown = false;
            for (let i = 0; i < badlandsFillOffsets.length; i += 1) {
              const offset = badlandsFillOffsets[i];
              const nx = x + offset[0];
              const ny = y + offset[1];
              if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
                continue;
              }
              const nIdx = ny * width + nx;
              if (!badlandsMask[nIdx]) {
                continue;
              }
              neighborCount += 1;
              if (offset[0] < 0) {
                hasLeft = true;
              } else if (offset[0] > 0) {
                hasRight = true;
              }
              if (offset[1] < 0) {
                hasUp = true;
              } else if (offset[1] > 0) {
                hasDown = true;
              }
            }
            const hasHorizontalBridge = hasLeft && hasRight;
            const hasVerticalBridge = hasUp && hasDown;
            const hasCrossBridge =
              (hasLeft || hasRight) && (hasUp || hasDown) && neighborCount >= 3;
            if (
              neighborCount >= 2 &&
              (hasHorizontalBridge || hasVerticalBridge || hasCrossBridge) &&
              hasAdjacentSand(x, y)
            ) {
              additions.push({ idx, x, y });
            }
          }
        }
        if (additions.length === 0) {
          break;
        }
        const additionSet = new Set(additions.map(({ idx }) => idx));
        const validAdditions = additions.filter(({ x, y }) =>
          hasAdjacentSand(x, y, additionSet)
        );
        if (validAdditions.length === 0) {
          break;
        }
        for (let i = 0; i < validAdditions.length; i += 1) {
          const { idx, x, y } = validAdditions[i];
          badlandsMask[idx] = 1;
          tiles[y][x].base = badlandsTileKey;
        }
      }
    }

    if (badlandsMask) {
      const revertIndices = [];
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (!badlandsMask[idx]) {
            continue;
          }
          if (isAdjacentToWater(x, y) || !hasAdjacentSand(x, y)) {
            revertIndices.push({ idx, x, y });
          }
        }
      }
      if (revertIndices.length > 0) {
        for (let i = 0; i < revertIndices.length; i += 1) {
          const { idx, x, y } = revertIndices[i];
          badlandsMask[idx] = 0;
          tiles[y][x].base = sandTileKey;
        }
      }
    }

    if (hasBadlandsTile && badlandsMask) {
      const surroundedSand = [];
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (tiles[y][x].base !== sandTileKey) {
            continue;
          }
          let hasNeighbor = false;
          let allBadlands = true;
          for (let i = 0; i < neighborOffsets8.length; i += 1) {
            const nx = x + neighborOffsets8[i][0];
            const ny = y + neighborOffsets8[i][1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              allBadlands = false;
              continue;
            }
            hasNeighbor = true;
            if (tiles[ny][nx].base !== badlandsTileKey) {
              allBadlands = false;
              break;
            }
          }
          if (hasNeighbor && allBadlands) {
            surroundedSand.push({ idx, x, y });
          }
        }
      }
      for (let i = 0; i < surroundedSand.length; i += 1) {
        const { idx, x, y } = surroundedSand[i];
        tiles[y][x].base = badlandsTileKey;
        badlandsMask[idx] = 1;
        if (desertMask) {
          desertMask[idx] = 1;
        }
      }
    }

    if (hasSnowTile) {
      const snowClearRadius = 2;
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (
            tiles[y][x].base !== sandTileKey &&
            (!hasBadlandsTile || tiles[y][x].base !== badlandsTileKey)
          ) {
            continue;
          }
          let nearSnow = false;
          for (let dy = -snowClearRadius; dy <= snowClearRadius && !nearSnow; dy += 1) {
            for (let dx = -snowClearRadius; dx <= snowClearRadius; dx += 1) {
              if (dx === 0 && dy === 0) {
                continue;
              }
              const nx = x + dx;
              const ny = y + dy;
              if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
                continue;
              }
              const neighborTile = tiles[ny][nx].base;
              if (neighborTile === snowTileKey) {
                nearSnow = true;
                break;
              }
            }
          }
          if (nearSnow) {
            tiles[y][x].base = grassTileKey;
            desertMask[idx] = 0;
            if (badlandsMask) {
              badlandsMask[idx] = 0;
            }
          }
        }
      }
    }

    const cardinalNeighborOffsets = [
      [0, -1],
      [1, 0],
      [0, 1],
      [-1, 0]
    ];

    const sandGrassConversions = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const baseKey = tiles[y][x].base;
        if (baseKey !== sandTileKey && baseKey !== grassTileKey) {
          continue;
        }

        let hasAllNeighbors = true;
        let allGrass = true;
        let allSand = true;
        for (let i = 0; i < cardinalNeighborOffsets.length; i += 1) {
          const nx = x + cardinalNeighborOffsets[i][0];
          const ny = y + cardinalNeighborOffsets[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            hasAllNeighbors = false;
            break;
          }
          const neighborBase = tiles[ny][nx].base;
          if (neighborBase !== grassTileKey) {
            allGrass = false;
          }
          if (neighborBase !== sandTileKey) {
            allSand = false;
          }
          if (!allGrass && !allSand) {
            break;
          }
        }

        if (!hasAllNeighbors) {
          continue;
        }

        if (baseKey === sandTileKey && allGrass) {
          sandGrassConversions.push({ idx, x, y, target: grassTileKey });
        } else if (baseKey === grassTileKey && allSand) {
          sandGrassConversions.push({ idx, x, y, target: sandTileKey });
        }
      }
    }

    for (let i = 0; i < sandGrassConversions.length; i += 1) {
      const { idx, x, y, target } = sandGrassConversions[i];
      tiles[y][x].base = target;
      if (desertMask) {
        desertMask[idx] = target === sandTileKey ? 1 : 0;
      }
      if (badlandsMask) {
        badlandsMask[idx] = 0;
      }
    }
  }

  if (hasSandTile) {
    const desertMaskForDistance = new Uint8Array(width * height);
    let desertTileCount = 0;
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const tile = tiles[y][x];
        if (!tile) {
          continue;
        }
        const baseKey = tile.base;
        const isDesertTile =
          baseKey === sandTileKey || (hasBadlandsTile && baseKey === badlandsTileKey);
        if (isDesertTile) {
          desertMaskForDistance[idx] = 1;
          desertTileCount += 1;
          tile.desertProximity = 0;
        } else {
          desertMaskForDistance[idx] = 0;
        }
      }
    }

    if (desertTileCount > 0) {
      const desertDistanceField = computeEuclideanDistanceField(
        desertMaskForDistance,
        width,
        height
      );
      const desertTransitionFalloff = 4.5;
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          const tile = tiles[y][x];
          if (!tile || desertMaskForDistance[idx]) {
            continue;
          }
          if (tile.base === grassTileKey) {
            const distanceToDesert = Math.sqrt(desertDistanceField[idx]);
            const proximity = clamp(1 - distanceToDesert / desertTransitionFalloff, 0, 1);
            tile.desertProximity = proximity;
          } else {
            tile.desertProximity = 0;
          }
        }
      }
    }

    if (oasisTileKey) {
      const oasisBaseChance = 0.00025;
      const oasisSuitabilityScale = 0.002;
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (!desertMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          if (!tile || tile.base !== sandTileKey) {
            continue;
          }
          if (tile.overlay || tile.hillOverlay || tile.structure || tile.river) {
            continue;
          }
          let hasNeighborOasis = false;
          for (let i = 0; i < neighborOffsets8.length; i += 1) {
            const nx = x + neighborOffsets8[i][0];
            const ny = y + neighborOffsets8[i][1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            const neighborTile = tiles[ny][nx];
            if (neighborTile && neighborTile.overlay === oasisTileKey) {
              hasNeighborOasis = true;
              break;
            }
          }
          if (hasNeighborOasis) {
            continue;
          }
          const suitability = desertSuitabilityField ? desertSuitabilityField[idx] : 0;
          const oasisChance = clamp(
            oasisBaseChance + suitability * oasisSuitabilityScale,
            0,
            0.12
          );
          if (oasisChance <= 0) {
            continue;
          }
          if (rng() < oasisChance) {
            tile.overlay = oasisTileKey;
          }
        }
      }
    }
  }

  if (hasMarshTile) {
    const marshMask = marshMaskField ? new Uint8Array(marshMaskField) : new Uint8Array(width * height);
    const marshBuffer = new Uint8Array(width * height);
    const marshIterations = 2;
    for (let iteration = 0; iteration < marshIterations; iteration += 1) {
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (waterMask[idx]) {
            marshBuffer[idx] = 0;
            continue;
          }
          const tile = tiles[y][x];
          if (!tile) {
            marshBuffer[idx] = 0;
            continue;
          }
          const currentIsMarsh = marshMask[idx] === 1;
          let marshNeighbors = 0;
          for (let i = 0; i < neighborOffsets8.length; i += 1) {
            const nx = x + neighborOffsets8[i][0];
            const ny = y + neighborOffsets8[i][1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            const nIdx = ny * width + nx;
            if (waterMask[nIdx]) {
              continue;
            }
            if (marshMask[nIdx]) {
              marshNeighbors += 1;
            }
          }
          const heightValue = elevationField[idx];
          const rainfallValue = rainfallField[idx];
          const drainageValue = drainageField[idx];
          const {
            score: marshScore,
            threshold: marshThreshold,
            qualifies: marshQualifies
          } = calculateMarshSuitability(
            x,
            y,
            heightValue,
            rainfallValue,
            drainageValue,
            false
          );
          let nextIsMarsh = currentIsMarsh;
          if (currentIsMarsh) {
            if (!marshQualifies && marshNeighbors <= 1) {
              nextIsMarsh = false;
            } else if (marshNeighbors <= 2 && marshScore < marshThreshold) {
              nextIsMarsh = false;
            } else if (marshScore < marshThreshold - 0.08) {
              nextIsMarsh = false;
            }
          } else if (tile.base === grassTileKey) {
            if (
              marshQualifies &&
              (marshNeighbors >= 3 || (marshNeighbors >= 2 && marshScore > marshThreshold + 0.05))
            ) {
              nextIsMarsh = true;
            } else if (marshNeighbors >= 4 && marshScore > marshThreshold - 0.02) {
              nextIsMarsh = true;
            } else {
              nextIsMarsh = false;
            }
          } else {
            nextIsMarsh = false;
          }
          if (!Number.isFinite(marshScore) || marshScore === -Infinity) {
            nextIsMarsh = false;
          }
          marshBuffer[idx] = nextIsMarsh ? 1 : 0;
        }
      }
      marshMask.set(marshBuffer);
    }

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const shouldBeMarsh = marshMask[idx] === 1;
        if (shouldBeMarsh) {
          tiles[y][x].base = marshTileKey;
        } else if (tiles[y][x].base === marshTileKey) {
          tiles[y][x].base = grassTileKey;
        }
        if (marshMaskField) {
          marshMaskField[idx] = shouldBeMarsh ? 1 : 0;
        }
      }
    }

    // Remove isolated marsh tiles by converting them to match surrounding terrain.
    const isolatedMarshes = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const tile = tiles[y][x];
        if (!tile || tile.base !== marshTileKey) {
          continue;
        }
        let validNeighborCount = 0;
        let marshNeighborCount = 0;
        const neighborOptions = [];
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          validNeighborCount += 1;
          const neighborTile = tiles[ny][nx];
          if (!neighborTile) {
            continue;
          }
          if (neighborTile.base === marshTileKey) {
            marshNeighborCount += 1;
          } else {
            neighborOptions.push(neighborTile.base);
          }
        }
        if (
          validNeighborCount > 0 &&
          marshNeighborCount === 0 &&
          neighborOptions.length === validNeighborCount
        ) {
          const replacementIndex = Math.floor(rng() * neighborOptions.length);
          isolatedMarshes.push({ x, y, base: neighborOptions[replacementIndex] });
        }
      }
    }
    for (let i = 0; i < isolatedMarshes.length; i += 1) {
      const { x, y, base } = isolatedMarshes[i];
      const tile = tiles[y][x];
      if (tile) {
        tile.base = base;
        if (marshMaskField) {
          marshMaskField[y * width + x] = base === marshTileKey ? 1 : 0;
        }
      }
    }

    const marshDistanceMask = new Uint8Array(width * height);
    let marshTileCount = 0;
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const tile = tiles[y][x];
        if (!tile) {
          continue;
        }
        if (waterMask[idx]) {
          tile.marshProximity = 0;
          continue;
        }
        if (tile.base === marshTileKey) {
          marshDistanceMask[idx] = 1;
          marshTileCount += 1;
          tile.marshProximity = 0;
        } else {
          marshDistanceMask[idx] = 0;
          tile.marshProximity = 0;
        }
      }
    }

    if (marshTileCount > 0) {
      const marshDistanceField = computeEuclideanDistanceField(
        marshDistanceMask,
        width,
        height
      );
      const marshTransitionFalloff = 3.5;
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (waterMask[idx] || marshDistanceMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          if (!tile) {
            continue;
          }
          if (tile.base !== grassTileKey) {
            tile.marshProximity = 0;
            continue;
          }
          const distanceToMarsh = Math.sqrt(marshDistanceField[idx]);
          const proximity = clamp(1 - distanceToMarsh / marshTransitionFalloff, 0, 1);
          tile.marshProximity = proximity;
        }
      }
    }
  }

  if (hasSnowTile) {
    const surroundedGrassTiles = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const tile = tiles[y][x];
        if (!tile || tile.base !== grassTileKey) {
          continue;
        }
        let surroundedBySnow = true;
        for (let i = 0; i < cardinalOffsets.length; i += 1) {
          const nx = x + cardinalOffsets[i][0];
          const ny = y + cardinalOffsets[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            surroundedBySnow = false;
            break;
          }
          const neighbor = tiles[ny][nx];
          if (!neighbor || neighbor.base !== snowTileKey) {
            surroundedBySnow = false;
            break;
          }
        }
        if (surroundedBySnow) {
          surroundedGrassTiles.push({ x, y });
        }
      }
    }

    for (let i = 0; i < surroundedGrassTiles.length; i += 1) {
      const { x, y } = surroundedGrassTiles[i];
      tiles[y][x].base = snowTileKey;
    }
  }

  if (hasMountainTile) {
    mountainScores = new Float32Array(width * height);
    mountainHeightField = new Float32Array(width * height);
    let ridgeField = new Float32Array(width * height);
    const ridgeDirectionIndex = new Int8Array(width * height);
    ridgeDirectionIndex.fill(-1);
    const ridgeDirectionStrength = new Float32Array(width * height);
    mountainMask = new Uint8Array(width * height);
    const directionOpposites = new Int8Array([7, 6, 5, 4, 3, 2, 1, 0]);
    const baseMountainSeedThreshold = 0.8;
    const baseMountainCandidateThreshold = 0.52;
    const baseMountainPruneThreshold = 0.9;
    const mountainSeedThreshold = clamp(
      baseMountainSeedThreshold - mountainBias * 0.32,
      0.52,
      0.97
    );
    mountainCandidateThreshold = clamp(
      baseMountainCandidateThreshold - mountainBias * 0.28,
      0.2,
      0.78
    );
    const mountainPruneThreshold = clamp(
      baseMountainPruneThreshold - mountainBias * 0.2,
      0.62,
      0.97
    );

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          mountainHeightField[idx] = 0;
          ridgeField[idx] = 0;
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || !isLandBaseTile(tile.base)) {
          mountainHeightField[idx] = 0;
          ridgeField[idx] = 0;
          continue;
        }

        const heightValue = elevationField[idx];
        const normalizedHeight = clamp((heightValue - mountainBaseThreshold) / mountainRange, 0, 1);
        mountainHeightField[idx] = normalizedHeight;

        const normalizedX = (x + 0.5) / width;
        const normalizedY = (y + 0.5) / height;
        const left = x > 0 ? elevationField[idx - 1] : heightValue;
        const right = x < width - 1 ? elevationField[idx + 1] : heightValue;
        const up = y > 0 ? elevationField[idx - width] : heightValue;
        const down = y < height - 1 ? elevationField[idx + width] : heightValue;

        const gradX = (right - left) * 0.5;
        const gradY = (down - up) * 0.5;
        const slopeMagnitude = Math.sqrt(gradX * gradX + gradY * gradY);

        const tectLeft = x > 0 ? tectonicActivityField[idx - 1] : tectonicActivityField[idx];
        const tectRight = x < width - 1 ? tectonicActivityField[idx + 1] : tectonicActivityField[idx];
        const tectUp = y > 0 ? tectonicActivityField[idx - width] : tectonicActivityField[idx];
        const tectDown = y < height - 1 ? tectonicActivityField[idx + width] : tectonicActivityField[idx];
        const tectGradX = (tectRight - tectLeft) * 0.5;
        const tectGradY = (tectDown - tectUp) * 0.5;
        const tectMag = Math.sqrt(tectGradX * tectGradX + tectGradY * tectGradY);

        let neighborSum = 0;
        let neighborCount = 0;
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          neighborSum += elevationField[ny * width + nx];
          neighborCount += 1;
        }
        const neighborAvg = neighborCount > 0 ? neighborSum / neighborCount : heightValue;
        const localContrast = Math.max(0, heightValue - neighborAvg);

        const ridgedBase = octaveNoise(
          (normalizedX + ridgeDetailOffsetX) * 7.4,
          (normalizedY + ridgeDetailOffsetY) * 7.4,
          ridgeDetailSeed,
          5,
          0.47,
          2.28
        );
        const ridged = Math.pow(1 - Math.abs(ridgedBase * 2 - 1), 1.25);

        const tectonicValue = clamp(tectonicActivityField[idx], 0, 1);
        const tectonicBoost = Math.pow(tectonicValue, 0.85);
        const slopeComponent = clamp(slopeMagnitude * 2.4, 0, 1);

        let dirX = 0;
        let dirY = 0;
        if (tectMag > 0.0003) {
          dirX += -tectGradY * 1.6;
          dirY += tectGradX * 1.6;
        }
        if (slopeMagnitude > 0.00035) {
          dirX += -gradY * 0.7;
          dirY += gradX * 0.7;
        }
        const orientationNoise = octaveNoise(
          (normalizedX + ridgeOrientationOffsetX) * 9.2,
          (normalizedY + ridgeOrientationOffsetY) * 9.2,
          ridgeOrientationSeed,
          3,
          0.58,
          2.05
        );
        const noiseAngle = (orientationNoise * 2 - 1) * Math.PI;
        if (Math.abs(dirX) + Math.abs(dirY) < 1e-4) {
          dirX = Math.cos(noiseAngle);
          dirY = Math.sin(noiseAngle);
        } else {
          const dirMag = Math.hypot(dirX, dirY) || 1;
          dirX = (dirX / dirMag) * 0.8 + Math.cos(noiseAngle) * 0.2;
          dirY = (dirY / dirMag) * 0.8 + Math.sin(noiseAngle) * 0.2;
        }
        const finalDirMag = Math.hypot(dirX, dirY);
        if (finalDirMag > 1e-4) {
          dirX /= finalDirMag;
          dirY /= finalDirMag;
          const orientationStrength = clamp(Math.sqrt(tectMag) * 3.5 + slopeMagnitude * 2.1, 0, 1);
          ridgeDirectionStrength[idx] = orientationStrength;
          let bestIndex = -1;
          let bestDot = 0.35;
          for (let i = 0; i < neighborOffsets8.length; i += 1) {
            const offset = neighborOffsets8[i];
            const length = Math.hypot(offset[0], offset[1]) || 1;
            const dot = (dirX * offset[0] + dirY * offset[1]) / length;
            if (dot > bestDot) {
              bestDot = dot;
              bestIndex = i;
            }
          }
          ridgeDirectionIndex[idx] = bestIndex;
        }

        const erosionPenalty = Math.max(0, neighborAvg - heightValue) * 0.35;
        const rawRidgeScore =
          normalizedHeight * 0.28 +
          Math.pow(Math.max(0, normalizedHeight), 1.6) * 0.3 +
          localContrast * 0.9 +
          slopeComponent * 0.55 +
          tectonicBoost * 0.75 +
          ridged * 0.4 -
          erosionPenalty;

        ridgeField[idx] = Math.max(0, rawRidgeScore);
      }
    }

    let ridgeWorking = ridgeField;
    let ridgeBuffer = new Float32Array(ridgeField.length);
    for (let iter = 0; iter < 2; iter += 1) {
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (waterMask[idx]) {
            ridgeBuffer[idx] = 0;
            continue;
          }
          const tile = tiles[y][x];
          if (!tile || !isLandBaseTile(tile.base)) {
            ridgeBuffer[idx] = 0;
            continue;
          }
          const dirIndex = ridgeDirectionIndex[idx];
          if (dirIndex < 0) {
            ridgeBuffer[idx] = ridgeWorking[idx];
            continue;
          }
          const strength = ridgeDirectionStrength[idx];
          const baseValue = ridgeWorking[idx];
          let weight = 1;
          let weightedSum = baseValue;
          const offsets = [dirIndex, directionOpposites[dirIndex]];
          for (let i = 0; i < offsets.length; i += 1) {
            const offset = neighborOffsets8[offsets[i]];
            const nx = x + offset[0];
            const ny = y + offset[1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            const nIdx = ny * width + nx;
            if (waterMask[nIdx]) {
              continue;
            }
            const neighborTile = tiles[ny][nx];
            if (!neighborTile || !isLandBaseTile(neighborTile.base)) {
              continue;
            }
            const neighborWeight = 0.8 + strength * 0.6;
            weightedSum += ridgeWorking[nIdx] * neighborWeight;
            weight += neighborWeight;
          }
          ridgeBuffer[idx] = weightedSum / weight;
        }
      }
      const swap = ridgeWorking;
      ridgeWorking = ridgeBuffer;
      ridgeBuffer = swap;
    }
    ridgeField = ridgeWorking;
    normalizeField(ridgeField);

    for (let idx = 0; idx < mountainScores.length; idx += 1) {
      if (waterMask[idx]) {
        mountainScores[idx] = 0;
        continue;
      }
      const tile = tiles[Math.floor(idx / width)][idx % width];
      if (!tile || !isLandBaseTile(tile.base)) {
        mountainScores[idx] = 0;
        continue;
      }
      const normalizedHeight = mountainHeightField[idx];
      const ridgeValue = ridgeField[idx];
      const tectonicValue = clamp(tectonicActivityField[idx], 0, 1);
      const orientationBonus = ridgeDirectionStrength[idx] * 0.18;
      const combined = clamp(
        ridgeValue * 0.6 +
          Math.pow(Math.max(0, normalizedHeight), 1.6) * 0.25 +
          normalizedHeight * 0.18 +
          Math.pow(tectonicValue, 0.9) * 0.35 +
          orientationBonus,
        0,
        1
      );
      mountainScores[idx] = combined;
    }

    const isTooCoastal = (x, y) => {
      const idx = y * width + x;
      let coastalNeighbors = 0;
      for (let i = 0; i < cardinalOffsets.length; i += 1) {
        const nx = x + cardinalOffsets[i][0];
        const ny = y + cardinalOffsets[i][1];
        if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
          coastalNeighbors += 1;
          continue;
        }
        if (waterMask[ny * width + nx]) {
          coastalNeighbors += 1;
        }
      }
      if (coastalNeighbors < 2) {
        return false;
      }
      const tectonic = tectonicActivityField[idx];
      if (coastalNeighbors >= 3) {
        return tectonic < 0.6;
      }
      return tectonic < 0.35;
    };

    let seedCount = 0;
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || !isLandBaseTile(tile.base)) {
          continue;
        }
        const score = mountainScores[idx];
        if (score >= mountainSeedThreshold && !isTooCoastal(x, y)) {
          mountainMask[idx] = 1;
          seedCount += 1;
        }
      }
    }

    if (seedCount === 0) {
      const fallbackCandidates = [];
      for (let idx = 0; idx < mountainScores.length; idx += 1) {
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[Math.floor(idx / width)][idx % width];
        if (!tile || !isLandBaseTile(tile.base)) {
          continue;
        }
        const score = mountainScores[idx];
        if (score >= mountainSeedThreshold * 0.85) {
          fallbackCandidates.push(idx);
        }
      }
      fallbackCandidates.sort((a, b) => mountainScores[b] - mountainScores[a]);
      const maxFallbackSeeds = Math.max(1, Math.round(4 * mountainFrequencyNormalized));
      const limit = Math.min(maxFallbackSeeds, fallbackCandidates.length);
      for (let i = 0; i < limit; i += 1) {
        const idx = fallbackCandidates[i];
        const x = idx % width;
        const y = Math.floor(idx / width);
        if (!isTooCoastal(x, y)) {
          mountainMask[idx] = 1;
        }
      }
    }

    const traceDirection = (startX, startY, startDirIndex, maxSteps, initialReliability) => {
      let cx = startX;
      let cy = startY;
      let currentDirIndex = startDirIndex;
      let reliability = initialReliability;
      for (let step = 0; step < maxSteps; step += 1) {
        const offset = neighborOffsets8[currentDirIndex];
        const nx = cx + offset[0];
        const ny = cy + offset[1];
        if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
          break;
        }
        const nIdx = ny * width + nx;
        if (waterMask[nIdx]) {
          break;
        }
        const neighborTile = tiles[ny][nx];
        if (!neighborTile || !isLandBaseTile(neighborTile.base)) {
          break;
        }
        if (mountainScores[nIdx] < mountainCandidateThreshold * 0.85) {
          break;
        }
        mountainMask[nIdx] = 1;
        cx = nx;
        cy = ny;
        const nextDirIndex = ridgeDirectionIndex[nIdx];
        if (nextDirIndex >= 0) {
          currentDirIndex = nextDirIndex;
        }
        reliability = Math.max(ridgeDirectionStrength[nIdx], reliability * 0.82);
        if (reliability < 0.06) {
          break;
        }
      }
    };

    const extendRangeFromSeed = (seedIdx) => {
      const baseDirIndex = ridgeDirectionIndex[seedIdx];
      const reliability = ridgeDirectionStrength[seedIdx];
      if (baseDirIndex < 0 || reliability < 0.05) {
        return;
      }
      const seedScore = mountainScores[seedIdx];
      const ridgeStrength = ridgeField[seedIdx];
      const rangeScale = (seedScore * 4 + ridgeStrength * 3) * (0.5 + reliability * 0.4);
      const baseLength = 2 + Math.floor(rangeScale);
      const forwardSteps = Math.min(18, baseLength + Math.floor(rng() * 3));
      const backwardSteps = Math.max(1, Math.floor(forwardSteps * 0.45));
      const startX = seedIdx % width;
      const startY = Math.floor(seedIdx / width);
      traceDirection(startX, startY, baseDirIndex, forwardSteps, reliability);
      traceDirection(startX, startY, directionOpposites[baseDirIndex], backwardSteps, reliability * 0.85);
    };

    const seedIndices = [];
    for (let idx = 0; idx < mountainMask.length; idx += 1) {
      if (mountainMask[idx]) {
        seedIndices.push(idx);
      }
    }
    seedIndices.sort((a, b) => mountainScores[b] - mountainScores[a]);
    for (let i = 0; i < seedIndices.length; i += 1) {
      extendRangeFromSeed(seedIndices[i]);
    }

    for (let pass = 0; pass < 2; pass += 1) {
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx] || mountainMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || !isLandBaseTile(tile.base)) {
          continue;
        }
        const score = mountainScores[idx];
        if (score <= 0 || isTooCoastal(x, y)) {
          continue;
        }
          let mountainNeighbors = 0;
          for (let i = 0; i < neighborOffsets8.length; i += 1) {
            const nx = x + neighborOffsets8[i][0];
            const ny = y + neighborOffsets8[i][1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            if (mountainMask[ny * width + nx]) {
              mountainNeighbors += 1;
            }
          }
          const orientationStrength = ridgeDirectionStrength[idx];
          let minNeighbors = 3;
          if (score > 0.82 || orientationStrength > 0.7) {
            minNeighbors = 1;
          } else if (score > 0.66) {
            minNeighbors = orientationStrength > 0.45 ? 1 : 2;
          } else if (orientationStrength > 0.55) {
            minNeighbors = 2;
          }
          const dirIndex = ridgeDirectionIndex[idx];
          let directionalSupport = false;
          if (dirIndex >= 0) {
            const directionalOffsets = [dirIndex, directionOpposites[dirIndex]];
            for (let i = 0; i < directionalOffsets.length; i += 1) {
              const offset = neighborOffsets8[directionalOffsets[i]];
              const nx = x + offset[0];
              const ny = y + offset[1];
              if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
                continue;
              }
              if (mountainMask[ny * width + nx]) {
                directionalSupport = true;
                break;
              }
            }
          }
          const baseProbability = 0.12 + score * 0.6 + orientationStrength * 0.25;
          let probability = Math.min(0.85, baseProbability * mountainGrowthFactor);
          if (!directionalSupport) {
            probability *= 0.45;
            if (orientationStrength > 0.6) {
              probability *= 0.6;
            }
          }
          const highScoreThreshold = 0.75 + mountainScarcity * 0.12;
          if (
            mountainNeighbors >= minNeighbors &&
            (score > highScoreThreshold || rng() < probability)
          ) {
            mountainMask[idx] = 1;
          }
        }
      }
    }

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx] || mountainMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || !isLandBaseTile(tile.base)) {
          continue;
        }
        const score = mountainScores[idx];
        if (score < mountainCandidateThreshold || isTooCoastal(x, y)) {
          continue;
        }
        let mountainNeighbors = 0;
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          if (mountainMask[ny * width + nx]) {
            mountainNeighbors += 1;
          }
        }
        const orientationStrength = ridgeDirectionStrength[idx];
        const baseRequiredNeighbors = orientationStrength > 0.6 ? 2 : orientationStrength > 0.35 ? 3 : 4;
        const scarcityNeighborPenalty = mountainScarcity > 0.6 ? 2 : mountainScarcity > 0.35 ? 1 : 0;
        const requiredNeighbors = Math.min(7, baseRequiredNeighbors + scarcityNeighborPenalty);
        if (mountainNeighbors >= requiredNeighbors) {
          mountainMask[idx] = 1;
        }
      }
    }

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (!mountainMask[idx]) {
          continue;
        }
        const score = mountainScores[idx];
        let mountainNeighbors = 0;
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          if (mountainMask[ny * width + nx]) {
            mountainNeighbors += 1;
          }
        }
        const orientationStrength = ridgeDirectionStrength[idx];
        const minSupport = orientationStrength > 0.65 ? 0 : 1;
        const pruneBoost = lerp(1.18, 0.85, mountainFrequencyNormalized);
        const effectiveThreshold =
          mountainPruneThreshold * pruneBoost * (1 - orientationStrength * 0.25);
        if (mountainNeighbors <= minSupport && score < effectiveThreshold) {
          mountainMask[idx] = 0;
        }
      }
    }

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (!mountainMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || !isLandBaseTile(tile.base)) {
          mountainMask[idx] = 0;
          continue;
        }
        const normalizedHeight = mountainHeightField ? mountainHeightField[idx] : 0;
        const usePeakOverlay =
          mountainPeakKey && normalizedHeight >= mountainPeakHeightThreshold;
        tile.overlay = usePeakOverlay ? mountainPeakKey : mountainOverlayKey;
        const ruggednessNoise = mountainRuggednessSeed
          ? hashCoords(x, y, mountainRuggednessSeed)
          : 0.5;
        const baseRuggedness = usePeakOverlay
          ? 0.55 + normalizedHeight * 0.35
          : 0.35 + normalizedHeight * 0.45;
        tile.mountainRuggedness = clamp(
          baseRuggedness + (ruggednessNoise - 0.5) * 0.3,
          0,
          1
        );
        const isSandBase = hasSandTile && tile.base === sandTileKey;
        const isBadlandsBase = hasBadlandsTile && tile.base === badlandsTileKey;
        if (isSandBase || isBadlandsBase) {
          tile.base = stoneTileKey;
        } else if (tile.base === marshTileKey) {
          tile.base = grassTileKey;
        }
      }
    }

    if (volcanoOverlayKeys.length > 0) {
      const volcanoCandidates = [];
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (!mountainMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          if (!tile || tile.structure || tile.river) {
            continue;
          }
          if (tile.overlay !== mountainOverlayKey && tile.overlay !== mountainPeakKey) {
            continue;
          }
          const normalizedHeight = mountainHeightField ? mountainHeightField[idx] : 0;
          const score = mountainScores ? mountainScores[idx] : 0;
          volcanoCandidates.push({ x, y, idx, height: normalizedHeight, score });
        }
      }

      if (volcanoCandidates.length > 0) {
        volcanoCandidates.sort((a, b) => {
          if (b.height !== a.height) {
            return b.height - a.height;
          }
          return b.score - a.score;
        });

        const minVolcanoCount = Math.min(volcanoOverlayKeys.length, volcanoCandidates.length);
        const baseVolcanoCount = Math.round(volcanoCandidates.length / 600);
        const volcanoBaseTarget = Math.max(1, Math.max(minVolcanoCount, baseVolcanoCount));
        const volcanoRarityFactor = 0.15;
        const rarityAdjustedTarget = Math.max(
          1,
          Math.round(volcanoBaseTarget * volcanoRarityFactor)
        );
        const desiredVolcanoCount = clamp(
          rarityAdjustedTarget,
          1,
          Math.min(volcanoCandidates.length, 6)
        );

        if (desiredVolcanoCount > 0) {
          const selectionPoolSize = Math.min(
            volcanoCandidates.length,
            Math.max(desiredVolcanoCount * 5, desiredVolcanoCount + 3)
          );
          const selectionPool = volcanoCandidates.slice(0, selectionPoolSize);
          const placedVolcanoes = [];
          const volcanoMinDistance = 6;
          const volcanoMinDistanceSq = volcanoMinDistance * volcanoMinDistance;
          let attempts = 0;
          const maxAttempts = selectionPool.length * 3;

          while (
            selectionPool.length > 0 &&
            placedVolcanoes.length < desiredVolcanoCount &&
            attempts < maxAttempts
          ) {
            attempts += 1;
            const pickIndex = Math.floor(rng() * selectionPool.length);
            const candidate = selectionPool.splice(pickIndex, 1)[0];
            if (!candidate) {
              continue;
            }

            let tooClose = false;
            for (let i = 0; i < placedVolcanoes.length; i += 1) {
              const placed = placedVolcanoes[i];
              const dx = candidate.x - placed.x;
              const dy = candidate.y - placed.y;
              if (dx * dx + dy * dy < volcanoMinDistanceSq) {
                tooClose = true;
                break;
              }
            }
            if (tooClose) {
              continue;
            }

            const tile = tiles[candidate.y][candidate.x];
            if (!tile || tile.structure || tile.river) {
              continue;
            }

            const overlayKey =
              placedVolcanoes.length === 0 && activeVolcanoKey
                ? activeVolcanoKey
                : dormantVolcanoKey || activeVolcanoKey;

            if (!overlayKey) {
              break;
            }

            tile.overlay = overlayKey;
            const volcanoRuggednessNoise = mountainRuggednessSeed
              ? hashCoords(candidate.x, candidate.y, mountainRuggednessSeed ^ 0x9e3779b9)
              : 0.65;
            tile.mountainRuggedness = clamp(0.65 + (volcanoRuggednessNoise - 0.5) * 0.35, 0, 1);
            if (stoneTileKey && tile.base !== stoneTileKey) {
              tile.base = stoneTileKey;
            }

            placedVolcanoes.push({ x: candidate.x, y: candidate.y, overlayKey });
          }

          if (lavaTileKey && placedVolcanoes.length > 0) {
            for (let i = 0; i < placedVolcanoes.length; i += 1) {
              const volcano = placedVolcanoes[i];
              if (!volcano) {
                continue;
              }
              for (let j = 0; j < neighborOffsets8.length; j += 1) {
                const offset = neighborOffsets8[j];
                const nx = volcano.x + offset[0];
                const ny = volcano.y + offset[1];
                if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
                  continue;
                }
                const neighborIdx = ny * width + nx;
                if (!waterMask[neighborIdx]) {
                  continue;
                }
                const neighborTile = tiles[ny][nx];
                if (!neighborTile || neighborTile.base !== waterTileKey) {
                  continue;
                }
                if (neighborTile.biomeType !== 'lake') {
                  continue;
                }
                neighborTile.base = lavaTileKey;
                neighborTile.overlay = null;
                neighborTile.hillOverlay = null;
                neighborTile.structure = null;
                neighborTile.structureName = null;
                neighborTile.structureDetails = null;
                neighborTile.ambientStructure = null;
                neighborTile.river = null;
                neighborTile.biomeType = null;
                neighborTile.biomeClusterId = null;
                neighborTile.areaName = null;
                neighborTile.waterDepth = 0;
                neighborTile.coastProximity = 0;
                neighborTile.marshProximity = 0;
                neighborTile.desertProximity = 0;
                const currentProximity = Number(neighborTile.volcanoProximity) || 0;
                neighborTile.volcanoProximity = Math.max(currentProximity, 1);
                waterMask[neighborIdx] = 0;
              }
            }
          }
        }
      }
    }

    if (!riverMap) {
      riverMap = buildRiverMap(
        elevationField,
        rainfallField,
        drainageField,
        width,
        height,
        seaLevel,
        waterMask,
        {
          frequencyNormalized: riverFrequencyNormalized,
          random: rng
        }
      );
    }

    const dwarfholdKey = tileLookup.has('DWARFHOLD') ? 'DWARFHOLD' : null;
    const darkDwarfholdKey = tileLookup.has('DARK_DWARFHOLD') ? 'DARK_DWARFHOLD' : null;
    const greatDwarfholdKey = tileLookup.has('GREAT_DWARFHOLD') ? 'GREAT_DWARFHOLD' : null;
    const abandonedDwarfholdKey = tileLookup.has('ABANDONED_DWARFHOLD') ? 'ABANDONED_DWARFHOLD' : null;
    const mineKey = tileLookup.has('MINE') ? 'MINE' : null;
    let fallbackMountainScoreThreshold = 0.45;
    const mountainSettlementCandidates = [];
    const dwarfholdDistributionSeed = dwarfholdKey ? (seedNumber + 0x3bd39e8f) >>> 0 : 0;

    if (dwarfholdKey || mineKey) {
      fallbackMountainScoreThreshold =
        mountainScores && mountainCandidateThreshold !== null
          ? clamp(mountainCandidateThreshold * 0.85, 0.28, 0.62)
          : 0.45;
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (waterMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          if (!tile) {
            continue;
          }
          if (isVolcanoOverlayKey(tile.overlay)) {
            continue;
          }
          if (tile.river) {
            continue;
          }
          const score = mountainScores ? mountainScores[idx] : 0;
          const isMountainTile = isMountainOverlay(tile.overlay);
          const fallbackEligible =
            !isMountainTile &&
            !tile.overlay &&
            mountainScores &&
            score >= fallbackMountainScoreThreshold;
          if (!isMountainTile && !fallbackEligible) {
            continue;
          }
          const dwarfholdPriority = dwarfholdKey
            ? score +
              computeDwarfholdDistributionAdjustment(
                x,
                y,
                height,
                dwarfholdDistributionSeed
              )
            : score;

          const biomeType = tile.biomeType || null;
          const areaName = typeof tile.areaName === 'string' ? tile.areaName : null;
          const biomeClusterId = Number.isFinite(tile.biomeClusterId)
            ? tile.biomeClusterId
            : null;
          mountainSettlementCandidates.push({
            x,
            y,
            score,
            isMountainTile,
            dwarfholdPriority,
            biomeType,
            areaName,
            biomeClusterId
          });
        }
      }
    }

    if (!dwarfholdKey && mineKey && mountainSettlementCandidates.length > 0) {
      mountainSettlementCandidates.sort((a, b) => b.score - a.score);
    }

    if (dwarfholdKey) {
      const dwarfholdCandidates = mountainSettlementCandidates;
      if (dwarfholdCandidates.length > 0) {
        dwarfholdCandidates.sort((a, b) => {
          const aPriority = Number.isFinite(a.dwarfholdPriority)
            ? a.dwarfholdPriority
            : a.score;
          const bPriority = Number.isFinite(b.dwarfholdPriority)
            ? b.dwarfholdPriority
            : b.score;
          const diff = bPriority - aPriority;
          if (Math.abs(diff) > 1e-6) {
            return diff;
          }
          return b.score - a.score;
        });
        const baseTarget = Math.max(1, Math.round(dwarfholdCandidates.length / 500));
        const maxDwarfholds = computeStructurePlacementLimit(
          baseTarget,
          24,
          dwarfSettlementMultiplier
        );
        const abandonedDwarfholdChance = computeAbandonedDwarfholdChance(
          dwarfSettlementFrequencyNormalized
        );
        const minDistanceBase = 6;
        const minDistance = adjustMinDistance(minDistanceBase, dwarfSettlementFrequencyNormalized);
        const minDistanceSq = minDistance * minDistance;
        const placed = [];

        const basePlacementContext = {
          tiles,
          width,
          height,
          waterMask,
          mountainScores,
          fallbackMountainScoreThreshold,
          mountainOverlayKey,
          dwarfholdKey,
          darkDwarfholdKey,
          greatDwarfholdKey,
          abandonedDwarfholdKey,
          abandonedDwarfholdChance,
          rng,
          mountainRuggednessSeed,
          dwarfholds,
          towns,
          nearbyTownDistanceSq: dwarfholdNearbyTownRadius * dwarfholdNearbyTownRadius,
          darkDwarfholdVolcanoRadius
        };

        for (let i = 0; i < dwarfholdCandidates.length && placed.length < maxDwarfholds; i += 1) {
          const candidate = dwarfholdCandidates[i];
          tryPlaceDwarfhold(candidate, {
            ...basePlacementContext,
            placed,
            minDistanceSq
          });
        }

        if (placed.length === 0) {
          for (let i = 0; i < dwarfholdCandidates.length; i += 1) {
            if (
              tryPlaceDwarfhold(dwarfholdCandidates[i], {
                ...basePlacementContext,
                placed,
                minDistanceSq: null
              })
            ) {
              break;
            }
          }
        }

        if (dwarfholdCandidates.length > 0) {
          const getMountainAreaKey = (name, clusterId, x, y) => {
            if (Number.isFinite(clusterId)) {
              return `cluster:${clusterId}`;
            }
            if (typeof name === 'string') {
              const trimmed = name.trim();
              if (trimmed) {
                return `name:${trimmed.toLowerCase()}`;
              }
            }
            if (Number.isFinite(x) && Number.isFinite(y)) {
              return `coord:${Math.round(x)}:${Math.round(y)}`;
            }
            return null;
          };

          const mountainAreasWithHolds = new Set();
          if (Array.isArray(dwarfholds)) {
            for (let i = 0; i < dwarfholds.length; i += 1) {
              const hold = dwarfholds[i];
              if (!hold || !Number.isFinite(hold.x) || !Number.isFinite(hold.y)) {
                continue;
              }
              const row = tiles[hold.y];
              if (!Array.isArray(row)) {
                continue;
              }
              const holdTile = row[hold.x];
              if (!holdTile || holdTile.biomeType !== 'mountain') {
                continue;
              }
              const areaKey = getMountainAreaKey(
                holdTile.areaName,
                holdTile.biomeClusterId,
                hold.x,
                hold.y
              );
              if (areaKey) {
                mountainAreasWithHolds.add(areaKey);
              }
            }
          }

          const missingAreaKeys = new Set();
          for (let i = 0; i < dwarfholdCandidates.length; i += 1) {
            const candidate = dwarfholdCandidates[i];
            if (candidate.biomeType !== 'mountain') {
              continue;
            }
            const areaKey = getMountainAreaKey(
              candidate.areaName,
              candidate.biomeClusterId,
              candidate.x,
              candidate.y
            );
            if (!areaKey || mountainAreasWithHolds.has(areaKey)) {
              continue;
            }
            missingAreaKeys.add(areaKey);
          }

          const attemptFocusedPlacement = (respectDistance) => {
            if (missingAreaKeys.size === 0) {
              return;
            }
            const focusedMinDistanceSq =
              respectDistance && Number.isFinite(minDistanceSq)
                ? minDistanceSq
                : null;
            for (
              let i = 0;
              i < dwarfholdCandidates.length && missingAreaKeys.size > 0;
              i += 1
            ) {
              const candidate = dwarfholdCandidates[i];
              if (candidate.biomeType !== 'mountain') {
                continue;
              }
              const areaKey = getMountainAreaKey(
                candidate.areaName,
                candidate.biomeClusterId,
                candidate.x,
                candidate.y
              );
              if (!areaKey || !missingAreaKeys.has(areaKey)) {
                continue;
              }
              if (
                tryPlaceDwarfhold(candidate, {
                  ...basePlacementContext,
                  placed,
                  minDistanceSq: focusedMinDistanceSq
                })
              ) {
                missingAreaKeys.delete(areaKey);
              }
            }
          };

          attemptFocusedPlacement(true);
          attemptFocusedPlacement(false);
        }

        const southBoundary = Math.floor(height * 0.45);
        let southernCandidateCount = 0;
        for (let i = 0; i < dwarfholdCandidates.length; i += 1) {
          if (dwarfholdCandidates[i].y >= southBoundary) {
            southernCandidateCount += 1;
          }
        }

        if (southernCandidateCount > 0) {
          let placedSouthCount = 0;
          for (let i = 0; i < placed.length; i += 1) {
            if (placed[i].y >= southBoundary) {
              placedSouthCount += 1;
            }
          }

          const southBaseTarget = Math.max(1, Math.round(southernCandidateCount / 650));
          const southMax = computeStructurePlacementLimit(
            southBaseTarget,
            16,
            dwarfSettlementMultiplier
          );
          const southLimitFromTotal = Math.max(1, Math.ceil(maxDwarfholds * 0.5));
          const southCandidateCapacity = southernCandidateCount - placedSouthCount;
          const southExtraNeeded = Math.max(
            0,
            Math.min(southMax - placedSouthCount, southLimitFromTotal, southCandidateCapacity)
          );

          if (southExtraNeeded > 0) {
            const southMinDistanceBase = Math.max(3, Math.round(minDistanceBase * 0.85));
            const southMinDistance = adjustMinDistance(
              southMinDistanceBase,
              dwarfSettlementFrequencyNormalized
            );
            const southMinDistanceSq = southMinDistance * southMinDistance;
            let southPlaced = 0;

            for (
              let i = 0;
              i < dwarfholdCandidates.length && southPlaced < southExtraNeeded;
              i += 1
            ) {
              const candidate = dwarfholdCandidates[i];
              if (candidate.y < southBoundary) {
                continue;
              }
              if (
                tryPlaceDwarfhold(candidate, {
                  ...basePlacementContext,
                  placed,
                  minDistanceSq: southMinDistanceSq
                })
              ) {
                southPlaced += 1;
              }
            }
          }
        }
      }
    }

    if (mineKey && mountainSettlementCandidates.length > 0) {
      if (dwarfholdKey && mountainSettlementCandidates.length > 0) {
        mountainSettlementCandidates.sort((a, b) => b.score - a.score);
      }
      const mineCandidates = mountainSettlementCandidates.filter(
        (candidate) => candidate.isMountainTile && candidate.score >= 0.18
      );
      if (mineCandidates.length > 0) {
        const baseTarget = Math.max(1, Math.round(mineCandidates.length / 420));
        const maxMines = computeStructurePlacementLimit(baseTarget, 28, dwarfSettlementMultiplier);
        const minDistanceBase = 3;
        const minDistance = adjustMinDistance(minDistanceBase, dwarfSettlementFrequencyNormalized);
        const minDistanceSq = minDistance * minDistance;
        const placedMines = [];

        for (let i = 0; i < mineCandidates.length && placedMines.length < maxMines; i += 1) {
          const candidate = mineCandidates[i];
          const tile = tiles[candidate.y][candidate.x];
          if (riverMap && riverMap[candidate.y * width + candidate.x] > 0) {
            continue;
          }
          if (!tile || tile.structure || tile.river) {
            continue;
          }
          if (!isMountainOverlay(tile.overlay)) {
            continue;
          }
          let tooClose = false;
          for (let j = 0; j < placedMines.length; j += 1) {
            const other = placedMines[j];
            const dx = candidate.x - other.x;
            const dy = candidate.y - other.y;
            if (dx * dx + dy * dy < minDistanceSq) {
              tooClose = true;
              break;
            }
          }
          if (!tooClose) {
            const distanceToHoldSq = computeNearestDistanceSq(candidate.x, candidate.y, dwarfholds);
            if (distanceToHoldSq !== Infinity && distanceToHoldSq < 9) {
              tooClose = true;
            }
          }
          if (!tooClose) {
            const distanceToHillholdSq = computeNearestDistanceSq(candidate.x, candidate.y, hillholds);
            if (distanceToHillholdSq !== Infinity && distanceToHillholdSq < 9) {
              tooClose = true;
            }
          }
          if (tooClose) {
            continue;
          }

          const name = generateMineName(rng);
          const nearestHoldInfo = findNearestPointWithDetails(candidate.x, candidate.y, dwarfholds);
          const details = generateMineDetails(name, rng, {
            nearestDwarfhold: nearestHoldInfo ? nearestHoldInfo.point : null,
            nearestHoldDistance: nearestHoldInfo ? nearestHoldInfo.distance : null
          });

          tile.structure = mineKey;
          tile.structureName = name;
          tile.structureDetails = details;

          placedMines.push(candidate);
          mines.push({ x: candidate.x, y: candidate.y, ...details });
        }

        if (placedMines.length === 0) {
          for (let i = 0; i < mineCandidates.length; i += 1) {
            const candidate = mineCandidates[i];
            const tile = tiles[candidate.y][candidate.x];
            if (riverMap && riverMap[candidate.y * width + candidate.x] > 0) {
              continue;
            }
            if (!tile || tile.structure || tile.river) {
              continue;
            }
            if (!isMountainOverlay(tile.overlay)) {
              continue;
            }
            const name = generateMineName(rng);
            const nearestHoldInfo = findNearestPointWithDetails(candidate.x, candidate.y, dwarfholds);
            const details = generateMineDetails(name, rng, {
              nearestDwarfhold: nearestHoldInfo ? nearestHoldInfo.point : null,
              nearestHoldDistance: nearestHoldInfo ? nearestHoldInfo.distance : null
            });
            tile.structure = mineKey;
            tile.structureName = name;
            tile.structureDetails = details;
            mines.push({ x: candidate.x, y: candidate.y, ...details });
            break;
          }
        }
      }
    }
  }

  const hillholdKey = tileLookup.has('HILLHOLD') ? 'HILLHOLD' : null;
  if (hillholdKey) {
    const hillholdNoiseSeed = (seedNumber + 0x9b17a4c3) >>> 0;
    const hillholdCandidates = [];
    const hillSearchRadius = 6;
    const hillSearchRadiusSq = hillSearchRadius * hillSearchRadius;
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        const overlayIsHill = isHillOverlayKey(tile.overlay) || isHillOverlayKey(tile.hillOverlay);
        if (!overlayIsHill) {
          continue;
        }
        if (!isLandBaseTile(tile.base)) {
          continue;
        }

        let bestMountainDistSq = Infinity;
        outer: for (let dy = -hillSearchRadius; dy <= hillSearchRadius; dy += 1) {
          const ny = y + dy;
          if (ny < 0 || ny >= height) {
            continue;
          }
          for (let dx = -hillSearchRadius; dx <= hillSearchRadius; dx += 1) {
            const nx = x + dx;
            if (nx < 0 || nx >= width) {
              continue;
            }
            const distSq = dx * dx + dy * dy;
            if (distSq === 0 || distSq > hillSearchRadiusSq) {
              continue;
            }
            const nIdx = ny * width + nx;
            if (mountainMask && mountainMask[nIdx]) {
              if (distSq < bestMountainDistSq) {
                bestMountainDistSq = distSq;
              }
              if (bestMountainDistSq <= 1) {
                break outer;
              }
              continue;
            }
            const neighborRow = tiles[ny];
            const neighborTile = neighborRow ? neighborRow[nx] : null;
            if (neighborTile && (isMountainOverlay(neighborTile.overlay) || isMountainOverlay(neighborTile.hillOverlay))) {
              if (distSq < bestMountainDistSq) {
                bestMountainDistSq = distSq;
              }
              if (bestMountainDistSq <= 1) {
                break outer;
              }
            }
          }
        }

        if (!Number.isFinite(bestMountainDistSq) || bestMountainDistSq === Infinity) {
          continue;
        }

        const mountainDistance = Math.sqrt(bestMountainDistSq);
        const mountainProximity = clamp(1 - mountainDistance / (hillSearchRadius + 0.5), 0, 1);
        const mountainScore = mountainScores ? mountainScores[idx] : 0;
        const mountainAffinity = Math.max(mountainProximity, mountainScore * 0.6);
        const heightValue = elevationField ? elevationField[idx] : seaLevel;

        let slopeSum = 0;
        let neighborCount = 0;
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            continue;
          }
          slopeSum += Math.abs(heightValue - elevationField[nIdx]);
          neighborCount += 1;
        }
        const averageSlope = neighborCount > 0 ? slopeSum / neighborCount : 0;
        const slopeScore = clamp(averageSlope * 32, 0, 0.25);
        const elevationScore = clamp((heightValue - seaLevel + 0.08) * 1.3, 0, 0.22);
        const baseIsSnow = tile.base === snowTileKey;
        const climateBonus = baseIsSnow ? 0.1 : 0.16;
        const holdDistanceSq = computeNearestDistanceSq(x, y, dwarfholds);
        const holdBonus =
          holdDistanceSq === Infinity ? 0.04 : clamp(1 - Math.sqrt(holdDistanceSq) / 24, 0, 0.15);
        const noise = hashCoords(x, y, hillholdNoiseSeed) - 0.5;
        const score =
          climateBonus +
          mountainAffinity * 0.45 +
          slopeScore * 0.18 +
          elevationScore * 0.18 +
          holdBonus +
          noise * 0.12;

        if (score <= 0.22) {
          continue;
        }

        hillholdCandidates.push({
          x,
          y,
          score,
          mountainDistance,
          elevation: heightValue,
          holdDistanceSq
        });
      }
    }

    if (hillholdCandidates.length > 0) {
      hillholdCandidates.sort((a, b) => b.score - a.score);
      const baseTarget = Math.max(1, Math.round(hillholdCandidates.length / 900));
      const maxHillholds = computeStructurePlacementLimit(baseTarget, 18, dwarfSettlementMultiplier);
      const minDistanceBase = 4;
      const minDistance = adjustMinDistance(minDistanceBase, dwarfSettlementFrequencyNormalized);
      const minDistanceSq = minDistance * minDistance;
      const placed = [];

      for (let i = 0; i < hillholdCandidates.length && placed.length < maxHillholds; i += 1) {
        const candidate = hillholdCandidates[i];
        if (candidate.score < 0.24) {
          continue;
        }
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < minDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (tooClose) {
          continue;
        }

        const tile = tiles[candidate.y][candidate.x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        const overlayIsHill = isHillOverlayKey(tile.overlay) || isHillOverlayKey(tile.hillOverlay);
        if (!overlayIsHill) {
          continue;
        }
        const nearestHoldDistanceSq = computeNearestDistanceSq(candidate.x, candidate.y, dwarfholds);
        if (nearestHoldDistanceSq !== Infinity && nearestHoldDistanceSq < 9) {
          continue;
        }

        const name = generateHillholdName(rng);
        const nearestHoldInfo = findNearestPointWithDetails(candidate.x, candidate.y, dwarfholds);
        const details = generateHillholdDetails(name, rng, {
          nearestDwarfhold: nearestHoldInfo,
          mountainDistance: candidate.mountainDistance,
          hasNearbyHumanSettlement: false
        });

        tile.structure = hillholdKey;
        tile.structureName = name;
        tile.structureDetails = details;

        placed.push(candidate);
        hillholds.push({ x: candidate.x, y: candidate.y, ...details });
      }
    }
  }

  const damKey = tileLookup.has('DAM') ? 'DAM' : null;
  if (damKey && Array.isArray(dwarfholds) && dwarfholds.length > 0) {
    const damRadius = 10;
    const damRadiusSq = damRadius * damRadius;
    const damChance = 0.35;
    const damNoiseSeed = (seedNumber + 0x4b5f29d3) >>> 0;
    const isMountainTile = (tile) =>
      Boolean(tile) && (isMountainOverlay(tile.overlay) || isMountainOverlay(tile.hillOverlay));

    for (let y = 1; y < height - 1; y += 1) {
      const aboveRow = tiles[y - 1];
      const row = tiles[y];
      for (let x = 1; x < width - 1; x += 1) {
        const tile = row && row[x];
        if (!tile || tile.structure || !tile.river) {
          continue;
        }

        const aboveIdx = (y - 1) * width + x;
        const aboveTile = Array.isArray(aboveRow) ? aboveRow[x] : null;
        const aboveIsWater =
          (aboveIdx >= 0 && waterMask[aboveIdx]) ||
          (aboveTile && waterTileKey && aboveTile.base === waterTileKey);
        if (!aboveIsWater) {
          continue;
        }

        const leftTile = row[x - 1];
        const rightTile = row[x + 1];
        if (!isMountainTile(leftTile) || !isMountainTile(rightTile)) {
          continue;
        }

        const nearestHoldInfo = findNearestPointWithDetails(x, y, dwarfholds);
        if (!nearestHoldInfo || nearestHoldInfo.distanceSq > damRadiusSq) {
          continue;
        }

        const placementRoll = hashCoords(x, y, damNoiseSeed);
        if (placementRoll >= damChance) {
          continue;
        }

        const controllingHoldName =
          typeof nearestHoldInfo.point?.name === 'string' && nearestHoldInfo.point.name.trim()
            ? nearestHoldInfo.point.name.trim()
            : null;
        const damName = controllingHoldName ? `${controllingHoldName} Dam` : 'Dwarven Dam';

        tile.structure = damKey;
        tile.structureName = damName;
        tile.structureDetails = {
          type: 'dam',
          displayType: 'Dam',
          classification: 'Dwarven Works',
          name: damName,
          controllingHold: controllingHoldName,
          description: controllingHoldName
            ? `Engineers from ${controllingHoldName} raised a stone dam to harness the river.`
            : 'Dwarven engineers raised a stone dam to harness the river.'
        };
      }
    }
  }

  for (let y = 1; y < height - 1; y += 1) {
    for (let x = 1; x < width - 1; x += 1) {
      const idx = y * width + x;
      if (!waterMask[idx]) {
        continue;
      }
      let landNeighbors = 0;
      for (let i = 0; i < neighborOffsets8.length; i += 1) {
        const nx = x + neighborOffsets8[i][0];
        const ny = y + neighborOffsets8[i][1];
        if (waterMask[ny * width + nx] === 0) {
          landNeighbors += 1;
        }
      }
      if (landNeighbors >= 6) {
        waterMask[idx] = 0;
        const tile = tiles[y][x];
        const heightValue = elevationField[idx];
        tile.base = determineLandBaseTile(x, y, heightValue);
        tile.overlay = null;
        tile.hillOverlay = null;
        tile.structure = null;
        tile.structureName = null;
        tile.structureDetails = null;
        tile.ambientStructure = null;
        tile.river = null;
        tile.biomeType = null;
        tile.biomeClusterId = null;
        tile.areaName = null;
      }
    }
  }

  if (snowPresenceField) {
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const normalizedX = (x + 0.5) / width;
        const normalizedY = (y + 0.5) / height;
        const heightValue = elevationField[idx];
        snowPresenceField[idx] = computeSnowPresence(normalizedX, normalizedY, heightValue) ? 1 : 0;
      }
    }
  }

  if (hasMarshTile && hasSnowTile) {
    const snowMask = new Uint8Array(width * height);
    let snowCount = 0;
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const tile = tiles[y][x];
        if (tile && tile.base === snowTileKey) {
          snowMask[idx] = 1;
          snowCount += 1;
        }
      }
    }
    if (snowCount > 0) {
      const distanceField = computeEuclideanDistanceField(snowMask, width, height);
      const marshExclusionRadiusSq = 75 * 75;
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          const tile = tiles[y][x];
          if (tile && tile.base === marshTileKey && distanceField[idx] <= marshExclusionRadiusSq) {
            tile.base = grassTileKey;
          }
        }
      }
    }
  }

  if (hasSnowTile && hasIcebergOverlay && waterTileKey) {
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const tile = tiles[y][x];
        if (!tile || tile.base !== snowTileKey) {
          continue;
        }
        let fullySurroundedByWater = true;
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (ny < 0) {
            if (y === 0) {
              continue;
            }
            fullySurroundedByWater = false;
            break;
          }
          if (nx < 0 || nx >= width || ny >= height) {
            fullySurroundedByWater = false;
            break;
          }
          if (!waterMask[ny * width + nx]) {
            fullySurroundedByWater = false;
            break;
          }
        }
        if (!fullySurroundedByWater) {
          continue;
        }
        waterMask[idx] = 1;
        tile.base = waterTileKey;
        tile.overlay = null;
        tile.hillOverlay = null;
        tile.structure = null;
        tile.structureName = null;
        tile.structureDetails = null;
        tile.ambientStructure = null;
        tile.river = null;
        tile.biomeType = null;
        tile.biomeClusterId = null;
        tile.areaName = null;
        tile.waterDepth = 0;
        tile.coastProximity = 0;
        tile.desertProximity = 0;
        tile.volcanoProximity = 0;
        const variantNoise = hashCoords(x, y, icebergVariantSeed);
        const variantIndex = Math.min(
          icebergOverlayKeys.length - 1,
          Math.floor(variantNoise * icebergOverlayKeys.length)
        );
        const overlayKey = icebergOverlayKeys[Math.max(0, variantIndex)];
        tile.overlay = overlayKey;
        if (snowPresenceField) {
          snowPresenceField[idx] = 1;
        }
      }
    }
  }

  if (hasIcebergOverlay && snowPresenceField) {
    const icebergChance = 1 / 50;
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (!waterMask[idx] || !snowPresenceField[idx]) {
          continue;
        }
        const normalizedY = (y + 0.5) / height;
        const latitude = 1 - normalizedY;
        if (latitude < snowLatitudeStart) {
          continue;
        }
        const presenceNoise = hashCoords(x, y, icebergPresenceSeed);
        if (presenceNoise >= icebergChance) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || tile.overlay) {
          continue;
        }
        const variantNoise = hashCoords(x, y, icebergVariantSeed);
        const variantIndex = Math.min(
          icebergOverlayKeys.length - 1,
          Math.floor(variantNoise * icebergOverlayKeys.length)
        );
        const overlayKey = icebergOverlayKeys[Math.max(0, variantIndex)];
        tile.overlay = overlayKey;
      }
    }
  }

  if (hasSnowTile) {
    const snowMask = new Uint8Array(width * height);
    let snowCount = 0;
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const tile = tiles[y][x];
        if (tile && tile.base === snowTileKey) {
          snowMask[idx] = 1;
          snowCount += 1;
        }
      }
    }
    snowDistanceField = snowCount > 0 ? computeEuclideanDistanceField(snowMask, width, height) : null;
  }

  if (!riverMap) {
    riverMap = buildRiverMap(
      elevationField,
      rainfallField,
      drainageField,
      width,
      height,
      seaLevel,
      waterMask,
      {
        frequencyNormalized: riverFrequencyNormalized,
        random: rng
      }
    );
  }
  ensureRiverConnectionsToWater(riverMap, waterMask, tiles, width, height);

  const edgeConnectedOceanMask = computeEdgeConnectedWaterMask(
    waterMask,
    width,
    height
  );

  const coastlineFalloff = 4.2;
  let oceanMask = waterTileKey ? new Uint8Array(width * height) : null;

  if (waterTileKey) {
    const landMaskForDistance = new Uint8Array(width * height);
    for (let i = 0; i < waterMask.length; i += 1) {
      landMaskForDistance[i] = waterMask[i] ? 0 : 1;
    }
    const waterDistanceField = computeEuclideanDistanceField(landMaskForDistance, width, height);
    const landDistanceField = computeEuclideanDistanceField(waterMask, width, height);

    let maxWaterDepth = 0;
    for (let idx = 0; idx < waterDistanceField.length; idx += 1) {
      if (!waterMask[idx]) {
        continue;
      }
      const depth = Math.sqrt(waterDistanceField[idx]);
      if (depth > maxWaterDepth) {
        maxWaterDepth = depth;
      }
    }
    const depthNormalization = maxWaterDepth > 0 ? 1 / maxWaterDepth : 1;
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const tile = tiles[y][x];
        if (!tile) {
          continue;
        }
        if (waterMask[idx]) {
          const depth = Math.sqrt(waterDistanceField[idx]);
          tile.waterDepth = clamp(depth * depthNormalization, 0, 1);
          tile.coastProximity = 0;
          tile.marshProximity = 0;
          tile.desertProximity = 0;
          tile.volcanoProximity = 0;
        } else {
          const distanceToWater = Math.sqrt(landDistanceField[idx]);
          const proximity = clamp(1 - distanceToWater / coastlineFalloff, 0, 1);
          tile.coastProximity = proximity;
          tile.waterDepth = 0;
        }
      }
    }
  }

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      const tile = tiles[y][x];
      if (!tile) {
        continue;
      }
      if (riverMap[idx] === 0 || waterMask[idx]) {
        tile.river = null;
        continue;
      }
      const riverTile = resolveRiverTile(
        riverMap,
        width,
        height,
        x,
        y,
        waterMask,
        edgeConnectedOceanMask
      );
      tile.river = riverTile || null;
    }
  }

  if (mountainMask || mountainOverlayKey) {
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const tile = tiles[y][x];
        if (!tile || !tile.river) {
          continue;
        }
        if (mountainMask && mountainMask[idx]) {
          mountainMask[idx] = 0;
        }
        if (tile.overlay && isMountainOverlay(tile.overlay)) {
          tile.overlay = null;
          tile.hillOverlay = null;
        }
      }
    }
  }

  if (mountainOverlayKey) {
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const tile = tiles[y][x];
        if (!tile) {
          continue;
        }
        const overlayIsMountain = isMountainOverlay(tile.overlay);
        const hillIsMountain = isMountainOverlay(tile.hillOverlay);
        if (!overlayIsMountain && !hillIsMountain) {
          tile.mountainRuggedness = 0;
        } else if (!Number.isFinite(tile.mountainRuggedness)) {
          tile.mountainRuggedness = 0.45;
        }
      }
    }
  }

  const townKey = tileLookup.has('TOWN') ? 'TOWN' : null;
  const portTownKey = tileLookup.has('PORT_TOWN') ? 'PORT_TOWN' : null;
  const hamletKey = tileLookup.has('HAMLET') ? 'HAMLET' : null;
  const hamletSnowKey = tileLookup.has('HAMLET_SNOW') ? 'HAMLET_SNOW' : null;
  if (townKey) {
    const townCandidates = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || !isLandBaseTile(tile.base) || tile.overlay || tile.structure || tile.river) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = hasSnowTile && tile.base === snowTileKey;
        if (!baseIsGrass && !baseIsSnow) {
          continue;
        }
        const elevationValue = elevationField[idx];
        const preferredElevation = seaLevel + 0.18;
        const elevationScore = clamp(1 - Math.abs(elevationValue - preferredElevation) * 2.1, 0, 1);
        const rainfallValue = rainfallField[idx];
        const drainageValue = drainageField[idx];
        const localMoisture = clamp(rainfallValue * 0.7 + (1 - drainageValue) * 0.3, 0, 1);
        let roughness = 0;
        let neighborCount = 0;
        let neighborhoodMoistureSum = 0;
        let neighborhoodMoistureSamples = 0;
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            continue;
          }
          roughness += Math.abs(elevationValue - elevationField[nIdx]);
          neighborCount += 1;
          const neighborMoisture = clamp(
            rainfallField[nIdx] * 0.7 + (1 - drainageField[nIdx]) * 0.3,
            0,
            1
          );
          neighborhoodMoistureSum += neighborMoisture;
          neighborhoodMoistureSamples += 1;
        }
        const averageRoughness = neighborCount > 0 ? roughness / neighborCount : 0;
        const slopeScore = clamp(1 - averageRoughness * 12, 0, 1);
        const edgeDistance = Math.min(x, width - 1 - x, y, height - 1 - y);
        const maxEdgeDistance = Math.max(1, Math.min(width, height) / 2);
        const edgeScore = clamp(edgeDistance / maxEdgeDistance, 0, 1);
        const neighborhoodMoisture =
          neighborhoodMoistureSamples > 0
            ? neighborhoodMoistureSum / neighborhoodMoistureSamples
            : localMoisture;
        const blendedMoisture = localMoisture * 0.65 + neighborhoodMoisture * 0.35;
        const dryness = 1 - blendedMoisture;
        const humidityExcess = Math.max(0, blendedMoisture - 0.52);
        const swampPressure = Math.max(0, blendedMoisture - 0.68);
        const aridPressure = Math.max(0, dryness - 0.55);
        const poorDrainage = Math.max(0, 0.48 - drainageValue);
        const normalizedY = (y + 0.5) / height;
        const latitudeFactor = 1 - Math.abs(normalizedY - 0.5) * 2;
        const elevationAboveSea = Math.max(elevationValue - seaLevel, 0);
        const elevationCooling = clamp(1 - elevationAboveSea * 3.5, 0, 1);
        const approximateTemperature = clamp(
          latitudeFactor * 0.75 + elevationCooling * 0.25,
          0,
          1
        );
        const relativeElevation = elevationValue - seaLevel;
        let biomeTendency = 'grassland';
        if (relativeElevation < 0.05) {
          if (blendedMoisture > 0.7) {
            biomeTendency = 'marsh';
          } else if (blendedMoisture > 0.54 && approximateTemperature > 0.52) {
            biomeTendency = 'forest';
          }
        } else if (blendedMoisture < 0.3) {
          biomeTendency = 'badlands';
        } else if (approximateTemperature < 0.3) {
          biomeTendency = 'tundra';
        } else if (blendedMoisture > 0.72) {
          biomeTendency = 'marsh';
        } else if (blendedMoisture > 0.52 && approximateTemperature > 0.55) {
          biomeTendency = 'forest';
        }
        let grassPreference = clamp(
          1 - humidityExcess * 1.4 - swampPressure * 1.25 - aridPressure * 1.05 - poorDrainage * 0.55,
          0,
          1
        );
        if (biomeTendency === 'forest') {
          grassPreference *= 0.12;
        } else if (biomeTendency === 'marsh') {
          grassPreference *= 0.08;
        } else if (biomeTendency === 'tundra' || biomeTendency === 'badlands') {
          grassPreference *= 0.35;
        }
        if (!baseIsSnow && grassPreference < 0.22) {
          continue;
        }
        let riverAdjacency = 0;
        for (let i = 0; i < cardinalOffsets.length; i += 1) {
          const nx = x + cardinalOffsets[i][0];
          const ny = y + cardinalOffsets[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const neighborTile = tiles[ny][nx];
          if (neighborTile && neighborTile.river) {
            riverAdjacency += 1;
          }
        }
        const riverScore = riverAdjacency > 0 ? clamp(0.18 + riverAdjacency * 0.06, 0, 0.32) : 0;
        const biomePenalty =
          biomeTendency === 'forest'
            ? 0.24
            : biomeTendency === 'marsh'
            ? 0.18
            : biomeTendency === 'tundra' || biomeTendency === 'badlands'
            ? 0.08
            : 0;
        const score =
          elevationScore * 0.35 +
          slopeScore * 0.2 +
          edgeScore * 0.12 +
          riverScore +
          grassPreference * 0.32 -
          biomePenalty +
          rng() * 0.12;
        townCandidates.push({ x, y, score, grassPreference, baseIsSnow });
      }
    }

    if (townCandidates.length > 0) {
      townCandidates.sort((a, b) => b.score - a.score);
      const area = width * height;
      const baseTarget = Math.max(2, Math.round(area / 4800));
      const maxTowns = computeStructurePlacementLimit(baseTarget, 36, humanSettlementMultiplier);
      const baseMinDistance = Math.max(6, Math.round(Math.min(width, height) / 12));
      const minDistance = adjustMinDistance(baseMinDistance, humanSettlementFrequencyNormalized);
      const minDistanceSq = minDistance * minDistance;
      const placed = [];

      for (let i = 0; i < townCandidates.length; i += 1) {
        if (placed.length >= maxTowns) {
          break;
        }
        const candidate = townCandidates[i];
        if (
          !candidate.baseIsSnow &&
          candidate.grassPreference != null &&
          candidate.grassPreference < 0.25
        ) {
          continue;
        }
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < minDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (tooClose) {
          continue;
        }
        const tile = tiles[candidate.y][candidate.x];
        if (!tile || !isLandBaseTile(tile.base) || tile.overlay || tile.structure || tile.river) {
          continue;
        }
        const baseIsSnowPlacement = hasSnowTile && tile.base === snowTileKey;
        const name = baseIsSnowPlacement ? generateSnowVillageName(rng) : generateTownName(rng);
        let details = generateTownDetails(name, rng, { snowVillage: baseIsSnowPlacement });
        const isSmallVillage = details.type === 'village' && details.population < 100;
        if (baseIsSnowPlacement && !isSmallVillage) {
          continue;
        }
        let structureKey = townKey;
        if (portTownKey) {
          let touchesWater = false;
          for (let i = 0; i < neighborOffsets8.length; i += 1) {
            const nx = candidate.x + neighborOffsets8[i][0];
            const ny = candidate.y + neighborOffsets8[i][1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            const nIdx = ny * width + nx;
            if (waterMask[nIdx]) {
              touchesWater = true;
              break;
            }
          }
          if (touchesWater) {
            structureKey = portTownKey;
          }
        }
        let isHamletStructure = false;
        if (isSmallVillage) {
          if (baseIsSnowPlacement) {
            const snowHamletChance = 0.5;
            if (hamletSnowKey && rng() < snowHamletChance) {
              structureKey = hamletSnowKey;
              isHamletStructure = true;
            } else if (!hamletSnowKey && hamletKey && rng() < snowHamletChance) {
              structureKey = hamletKey;
              isHamletStructure = true;
            }
          } else if (hamletKey) {
            structureKey = hamletKey;
            isHamletStructure = true;
          }
        }
        if (isHamletStructure) {
          details = generateHamletDetails(name, rng, { snowHamlet: baseIsSnowPlacement });
        }
        tile.structure = structureKey;
        tile.structureName = name;
        tile.structureDetails = details;
        towns.push({ x: candidate.x, y: candidate.y, ...details });
        if (isHamletStructure) {
          recordHamletPlacement(candidate.x, candidate.y, baseIsSnowPlacement);
        }
        placed.push(candidate);
      }
    }
  }

  if (hamletKey) {
    const totalTiles = width * height;
    const hamletExpansionNoiseSeed = (seedNumber + 0x62bd3e45) >>> 0;
    const baseGrassHamlets = hamletPlacementStats.grass;
    const desiredGrassHamlets = Math.max(
      baseGrassHamlets * 6,
      Math.round((totalTiles / 12000) * humanSettlementMultiplier)
    );
    const additionalHamletsNeeded = Math.max(0, desiredGrassHamlets - baseGrassHamlets);
    if (additionalHamletsNeeded > 0) {
      const hamletCandidates = [];
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (waterMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          if (!tile || tile.structure || tile.river) {
            continue;
          }
          if (tile.base !== grassTileKey) {
            continue;
          }
          if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
            continue;
          }
          if (isTreeOverlayKey(tile.overlay)) {
            continue;
          }
          const settlementDistSq = computeNearestDistanceSq(x, y, towns);
          if (settlementDistSq < 25) {
            continue;
          }
          const hamletDistSq = computeNearestDistanceSq(x, y, hamletPoints);
          if (hamletDistSq < 25) {
            continue;
          }
          const rainfallValue = rainfallField[idx];
          const drainageValue = drainageField[idx];
          const moisture = clamp(rainfallValue * 0.7 + (1 - drainageValue) * 0.3, 0, 1);
          const moistureScore = clamp(1 - Math.abs(moisture - 0.55) * 2.2, 0, 1) * 0.24;
          let grassNeighbors = 0;
          let neighborSamples = 0;
          let waterAdjacency = 0;
          for (let i = 0; i < neighborOffsets8.length; i += 1) {
            const nx = x + neighborOffsets8[i][0];
            const ny = y + neighborOffsets8[i][1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            const nIdx = ny * width + nx;
            if (waterMask[nIdx]) {
              waterAdjacency += 1;
              continue;
            }
            const neighborTile = tiles[ny][nx];
            if (!neighborTile) {
              continue;
            }
            if (neighborTile.river) {
              waterAdjacency += 1;
            }
            if (neighborTile.base === grassTileKey) {
              grassNeighbors += 1;
            }
            neighborSamples += 1;
          }
          const adjacencyScore = neighborSamples > 0 ? (grassNeighbors / neighborSamples) * 0.18 : 0;
          const waterScore = clamp(waterAdjacency * 0.04, 0, 0.18);
          const settlementDistance = Number.isFinite(settlementDistSq)
            ? Math.sqrt(settlementDistSq)
            : Math.max(width, height);
          const proximityScore = clamp((settlementDistance - 6) / 14, 0, 1) * 0.2;
          const latitude = (y + 0.5) / height;
          const latitudeWave = Math.sin((latitude + 0.15) * Math.PI * 2);
          const latitudeScore = Math.abs(latitudeWave) * 0.08;
          const noise = hashCoords(x, y, hamletExpansionNoiseSeed) - 0.5;
          const score =
            0.28 +
            moistureScore +
            adjacencyScore +
            waterScore +
            proximityScore +
            latitudeScore +
            noise * 0.18 +
            rng() * 0.08;
          hamletCandidates.push({ x, y, score });
        }
      }

      if (hamletCandidates.length > 0) {
        hamletCandidates.sort((a, b) => b.score - a.score);
        const minDistance = 5;
        const minDistanceSq = minDistance * minDistance;
        let placed = 0;
        for (let i = 0; i < hamletCandidates.length; i += 1) {
          if (placed >= additionalHamletsNeeded) {
            break;
          }
          const candidate = hamletCandidates[i];
          if (candidate.score < 0.24) {
            continue;
          }
          const distanceToExistingHamletSq = computeNearestDistanceSq(
            candidate.x,
            candidate.y,
            hamletPoints
          );
          if (distanceToExistingHamletSq < minDistanceSq) {
            continue;
          }
          const distanceToTownsSq = computeNearestDistanceSq(candidate.x, candidate.y, towns);
          if (distanceToTownsSq < 20) {
            continue;
          }
          const tile = tiles[candidate.y][candidate.x];
          if (!tile || tile.structure || tile.river) {
            continue;
          }
          if (tile.base !== grassTileKey) {
            continue;
          }
          if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
            continue;
          }
          if (isTreeOverlayKey(tile.overlay)) {
            continue;
          }
          const name = generateTownName(rng);
          const details = generateHamletDetails(name, rng, { snowHamlet: false });
          tile.structure = hamletKey;
          tile.structureName = name;
          tile.structureDetails = details;
          towns.push({ x: candidate.x, y: candidate.y, ...details });
          recordHamletPlacement(candidate.x, candidate.y, false);
          placed += 1;
        }
      }
    }
  }

  const baseHillOverlayOptions = ['HILLS', 'HILLS_VARIANT_A', 'HILLS_VARIANT_B'].filter((key) =>
    tileLookup.has(key)
  );
  const primaryHillOverlayKey = tileLookup.has('HILLS') ? 'HILLS' : baseHillOverlayOptions[0] || null;
  const snowHillOverlayKey = tileLookup.has('HILLS_SNOW') ? 'HILLS_SNOW' : primaryHillOverlayKey;
  const badlandsHillOverlayKey = tileLookup.has('HILLS_BADLANDS')
    ? 'HILLS_BADLANDS'
    : primaryHillOverlayKey;
  const hillOverlayPresenceKeys = [
    ...baseHillOverlayOptions,
    snowHillOverlayKey,
    badlandsHillOverlayKey
  ].filter(Boolean);
  const hillOverlayPresenceKeySet = new Set(hillOverlayPresenceKeys);
  const hillOverlayKeys = Array.from(hillOverlayPresenceKeySet);
  const hillVariantSelectionSeed = (seedNumber + 0x3ab41d7f) >>> 0;
  const selectBaseHillOverlayKey = (x, y) => {
    if (baseHillOverlayOptions.length === 0) {
      return null;
    }
    if (baseHillOverlayOptions.length === 1) {
      return baseHillOverlayOptions[0];
    }
    const noise = hashCoords(x, y, hillVariantSelectionSeed);
    const index = Math.min(
      Math.floor(noise * baseHillOverlayOptions.length),
      baseHillOverlayOptions.length - 1
    );
    return baseHillOverlayOptions[index];
  };
  const isHillOverlay = (overlayKey) => overlayKey != null && hillOverlayPresenceKeySet.has(overlayKey);
  const normalizeHillOverlayKey = (tile, key) => {
    if (!tile || !key || !hillOverlayPresenceKeySet.has(key)) {
      return null;
    }
    if (
      badlandsHillOverlayKey &&
      hasBadlandsTile &&
      tile.base === badlandsTileKey &&
      key !== badlandsHillOverlayKey
    ) {
      return badlandsHillOverlayKey;
    }
    if (
      snowHillOverlayKey &&
      tile.base === snowTileKey &&
      key !== snowHillOverlayKey &&
      key !== badlandsHillOverlayKey
    ) {
      return snowHillOverlayKey;
    }
    return key;
  };
  const getHillOverlayKeyForTile = (tile) => {
    if (!tile) {
      return null;
    }
    const hillOverlayKey = normalizeHillOverlayKey(tile, tile.hillOverlay);
    if (hillOverlayKey) {
      return hillOverlayKey;
    }
    const overlayKey = normalizeHillOverlayKey(tile, tile.overlay);
    if (overlayKey) {
      return overlayKey;
    }
    return null;
  };
  if (hillOverlayPresenceKeySet.size > 0 && (primaryHillOverlayKey || snowHillOverlayKey)) {
    const hillUpperThreshold = hasMountainTile
      ? mountainBaseThreshold
      : Math.min(0.92, seaLevel + 0.32);
    const hillLowerBaseline = hasMountainTile
      ? mountainBaseThreshold - Math.max(0.16, mountainRange * 0.9)
      : seaLevel + 0.12;
    const hillLowerThreshold = clamp(
      hillLowerBaseline,
      seaLevel + 0.08,
      hillUpperThreshold - 0.04
    );
    if (hillUpperThreshold - hillLowerThreshold > 0.015) {
      const hillRange = Math.max(hillUpperThreshold - hillLowerThreshold, 0.0001);
      const hillPresenceSeed = (seedNumber + 0x0d4d0015) >>> 0;
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (waterMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          if (
            !tile ||
            tile.overlay ||
            tile.structure ||
            tile.river
          ) {
            continue;
          }
          const baseIsGrass = tile.base === grassTileKey;
          const baseIsSnow = tile.base === snowTileKey;
          const baseIsBadlands = hasBadlandsTile && tile.base === badlandsTileKey;
          if (!baseIsGrass && !baseIsSnow && !baseIsBadlands) {
            continue;
          }
          const heightValue = elevationField[idx];
          if (heightValue < hillLowerThreshold || heightValue >= hillUpperThreshold) {
            continue;
          }
          let slopeSum = 0;
          let neighborCount = 0;
          let hasMountainNeighbor = false;
          for (let i = 0; i < neighborOffsets8.length; i += 1) {
            const nx = x + neighborOffsets8[i][0];
            const ny = y + neighborOffsets8[i][1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            const nIdx = ny * width + nx;
            const neighborHeight = elevationField[nIdx];
            slopeSum += Math.abs(heightValue - neighborHeight);
            neighborCount += 1;
            if (!hasMountainNeighbor) {
              if (mountainMask && mountainMask[nIdx]) {
                hasMountainNeighbor = true;
              } else {
                const neighborTile = tiles[ny][nx];
                if (
                  neighborTile &&
                  mountainOverlayKey &&
                  isMountainOverlay(neighborTile.overlay)
                ) {
                  hasMountainNeighbor = true;
                }
              }
            }
          }
          const averageSlope = neighborCount > 0 ? slopeSum / neighborCount : 0;
          const slopeScore = clamp((averageSlope - 0.01) * 32, 0, 1);
          if (slopeScore < 0.08 && !hasMountainNeighbor) {
            continue;
          }
          const heightScore = clamp((heightValue - hillLowerThreshold) / hillRange, 0, 1);
          let mountainBonus = hasMountainNeighbor ? 0.25 : 0;
          if (!hasMountainNeighbor && mountainScores) {
            mountainBonus = Math.max(mountainBonus, clamp(mountainScores[idx] * 0.2, 0, 0.2));
          }
          const noiseValue = hashCoords(x, y, hillPresenceSeed) - 0.5;
          const compositeScore =
            heightScore * 0.6 +
            slopeScore * 0.3 +
            mountainBonus +
            noiseValue * 0.12;
          const threshold = 0.5 - mountainBonus * 0.18;
          if (compositeScore > threshold) {
            const overlayKey = baseIsSnow
              ? snowHillOverlayKey
              : baseIsBadlands
              ? badlandsHillOverlayKey
              : selectBaseHillOverlayKey(x, y);
            if (overlayKey) {
              tile.hillOverlay = overlayKey;
            }
          }
        }
      }
    }
  }

  if (hillOverlayPresenceKeySet.size > 0 || hasMountainTile) {
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const tile = tiles[y][x];
        if (!tile) {
          continue;
        }
        const baseKey = typeof tile.base === 'string' ? tile.base : null;
        const baseIsValid = baseKey && tileLookup.has(baseKey);
        if (baseIsValid && isLandBaseTile(baseKey)) {
          continue;
        }
        if (tile.overlay && (isMountainOverlay(tile.overlay) || isHillOverlay(tile.overlay))) {
          tile.overlay = null;
        }
        if (tile.hillOverlay && (isMountainOverlay(tile.hillOverlay) || isHillOverlay(tile.hillOverlay))) {
          tile.hillOverlay = null;
        }
        if (Number.isFinite(tile.mountainRuggedness)) {
          tile.mountainRuggedness = 0;
        }
        if (mountainMask) {
          mountainMask[y * width + x] = 0;
        }
      }
    }
  }

  const caveKey = tileLookup.has('CAVE') ? 'CAVE' : null;
  if (caveKey) {
    const caveCandidates = [];
    const caveNoiseSeed = (seedNumber + 0x21f0e1eb) >>> 0;
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = tile.base === snowTileKey;
        if (!baseIsGrass && !baseIsSnow) {
          continue;
        }
        const overlayIsHill =
          isHillOverlay(tile.overlay) || isHillOverlay(tile.hillOverlay);
        if (tile.overlay && !isHillOverlay(tile.overlay)) {
          continue;
        }
        const heightValue = elevationField[idx];
        let slopeSum = 0;
        let neighborCount = 0;
        let mountainNeighbors = 0;
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            continue;
          }
          slopeSum += Math.abs(heightValue - elevationField[nIdx]);
          neighborCount += 1;
          if (mountainMask && mountainMask[nIdx]) {
            mountainNeighbors += 1;
          } else {
            const neighborTile = tiles[ny][nx];
            if (neighborTile && mountainOverlayKey && isMountainOverlay(neighborTile.overlay)) {
              mountainNeighbors += 1;
            }
          }
        }
        const averageSlope = neighborCount > 0 ? slopeSum / neighborCount : 0;
        const slopeScore = clamp((averageSlope - 0.009) * 36, 0, 1);
        const hillBonus = overlayIsHill ? 0.35 : 0;
        const mountainBonus = Math.min(0.25, mountainNeighbors * 0.08);
        const elevationScore = clamp((heightValue - seaLevel) * 1.9, 0, 1);
        const noise = hashCoords(x, y, caveNoiseSeed) - 0.5;
        const compositeScore =
          hillBonus + slopeScore * 0.45 + mountainBonus + elevationScore * 0.2 + noise * 0.15;
        if (compositeScore > 0.22) {
          caveCandidates.push({ x, y, score: compositeScore, hill: overlayIsHill });
        }
      }
    }

    if (caveCandidates.length > 0) {
      caveCandidates.sort((a, b) => b.score - a.score);
      const area = width * height;
      const baseTarget = Math.max(1, Math.round(area / 9000));
      const maxCaves = computeStructurePlacementLimit(baseTarget, 22, 1);
      const minDistanceBase = 6;
      const minDistance = Math.max(3, minDistanceBase);
      const placed = [];

      for (let i = 0; i < caveCandidates.length; i += 1) {
        if (placed.length >= maxCaves) {
          break;
        }
        const candidate = caveCandidates[i];
        if (candidate.score < 0.28) {
          continue;
        }
        const requiredDistance = candidate.hill ? Math.max(3, minDistance - 1) : minDistance;
        const requiredDistanceSq = requiredDistance * requiredDistance;
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < requiredDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (tooClose) {
          continue;
        }
        const tile = tiles[candidate.y][candidate.x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        const overlay = tile.overlay;
        const overlayIsHill = isHillOverlay(overlay) || isHillOverlay(tile.hillOverlay);
        if (overlay && !isHillOverlay(overlay)) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = tile.base === snowTileKey;
        if (!baseIsGrass && !baseIsSnow) {
          continue;
        }
        const details = generateCaveDetails(rng);
        tile.structure = caveKey;
        tile.structureName = details?.name || 'Cave';
        tile.structureDetails = details;
        placed.push(candidate);
        const caveRecord = { x: candidate.x, y: candidate.y };
        if (details && typeof details === 'object') {
          Object.assign(caveRecord, details);
        }
        caves.push(caveRecord);
      }
    }
  }

  const hasTreeTile = tileLookup.has('TREE');
  const treeOverlayKey = hasTreeTile ? 'TREE' : null;
  const treeSnowOverlayKey = hasTreeTile && tileLookup.has('TREE_SNOW') ? 'TREE_SNOW' : treeOverlayKey;
  const treeJungleOverlayKey = hasTreeTile && tileLookup.has('JUNGLE_TREE') ? 'JUNGLE_TREE' : null;
  const treeLoneOverlayKey = hasTreeTile && tileLookup.has('TREE_LONE') ? 'TREE_LONE' : null;
  let jungleMask = null;
  const treeOverlayKeys = [
    treeOverlayKey,
    treeSnowOverlayKey,
    treeJungleOverlayKey,
    treeLoneOverlayKey
  ].filter(
    (key, index, array) => key && array.indexOf(key) === index
  );
  const isTreeOverlayKeyForGeneration = (overlayKey) =>
    hasTreeTile && overlayKey != null && treeOverlayKeys.includes(overlayKey);
  const isDesertBaseTile = (baseKey) =>
    hasSandTile && (baseKey === sandTileKey || (hasBadlandsTile && baseKey === badlandsTileKey));
  const selectTreeOverlayForTile = (tile, idx) => {
    if (!tile || !treeOverlayKey) {
      return treeOverlayKey;
    }
    if (tile.base === snowTileKey && treeSnowOverlayKey) {
      return treeSnowOverlayKey;
    }
    if (treeJungleOverlayKey && jungleMask && jungleMask[idx]) {
      return treeJungleOverlayKey;
    }
    return treeOverlayKey;
  };
  let treeDensityField = null;

  if (hasTreeTile) {
    const treeBaseSeed = (seedNumber + 0x27d4eb2f) >>> 0;
    const treeDetailSeed = (seedNumber + 0x165667b1) >>> 0;
    const treeBaseScale = (isFirstAge ? 2.4 : 3.3) + rng() * (isFirstAge ? 1.6 : 2.6);
    const treeDetailScale = (isFirstAge ? 6.6 : 8.4) + rng() * (isFirstAge ? 4.6 : 5.6);
    const treeBaseOffsetX = rng() * 4096;
    const treeBaseOffsetY = rng() * 4096;
    const treeDetailOffsetX = rng() * 8192;
    const treeDetailOffsetY = rng() * 8192;
    const treeClusterSeed = isFirstAge ? 0 : (seedNumber + 0x4f1bbcd1) >>> 0;
    const treeClusterScale = isFirstAge ? 1 : 8.2 + rng() * 4.8;
    const treeClusterOffsetX = isFirstAge ? 0 : rng() * 8192;
    const treeClusterOffsetY = isFirstAge ? 0 : rng() * 8192;
    treeDensityField = new Float32Array(width * height);
    const treeMask = new Uint8Array(width * height);
    if (treeJungleOverlayKey) {
      jungleMask = new Uint8Array(width * height);
      const jungleBaseSeed = (seedNumber + 0x4b9c1fcb) >>> 0;
      const jungleDetailSeed = (seedNumber + 0x1e35a9bd) >>> 0;
      const jungleBaseScale = 1.65 + rng() * 1.15;
      const jungleDetailScale = 5.1 + rng() * 2.9;
      const jungleBaseOffsetX = rng() * 4096;
      const jungleBaseOffsetY = rng() * 4096;
      const jungleDetailOffsetX = rng() * 8192;
      const jungleDetailOffsetY = rng() * 8192;
      const jungleSnowBufferSq = 100 * 100;
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (waterMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          if (!tile || !isLandBaseTile(tile.base)) {
            continue;
          }
          if (hasSnowTile && tile.base === snowTileKey) {
            continue;
          }
          if (hasSandTile && tile.base === sandTileKey) {
            continue;
          }
          if (hasBadlandsTile && tile.base === badlandsTileKey) {
            continue;
          }
          if (snowDistanceField && snowDistanceField[idx] < jungleSnowBufferSq) {
            continue;
          }
          const normalizedX = (x + 0.5) / width;
          const normalizedY = (y + 0.5) / height;
          const baseNoise = octaveNoise(
            (normalizedX + jungleBaseOffsetX) * jungleBaseScale,
            (normalizedY + jungleBaseOffsetY) * jungleBaseScale,
            jungleBaseSeed,
            3,
            0.6,
            1.95
          );
          const detailNoise = octaveNoise(
            (normalizedX + jungleDetailOffsetX) * jungleDetailScale,
            (normalizedY + jungleDetailOffsetY) * jungleDetailScale,
            jungleDetailSeed,
            4,
            0.5,
            2.35
          );
          const noiseValue = baseNoise * 0.68 + detailNoise * 0.32;
          const rainfallValue = rainfallField[idx];
          const drainageValue = drainageField[idx];
          const humidity = clamp(rainfallValue * 0.82 + (1 - drainageValue) * 0.18, 0, 1);
          const equatorialAlignment = clamp(1 - Math.abs(normalizedY - 0.5) * 3.4, 0, 1);
          const elevationValue = elevationField[idx];
          const elevationAboveSea = Math.max(0, elevationValue - seaLevel);
          const elevationScore = clamp(0.28 - elevationAboveSea, 0, 1);
          const elevationPenalty = clamp(elevationAboveSea * 3.1, 0, 1);
          const heat = clamp(equatorialAlignment * 0.85 + (1 - elevationPenalty) * 0.25, 0, 1);
          if (heat < 0.68 || humidity < 0.74 || equatorialAlignment < 0.45) {
            continue;
          }
          const drainageScore = clamp(0.55 - drainageValue, 0, 1);
          const combinedScore =
            (heat - 0.68) * 0.35 +
            (humidity - 0.74) * 0.45 +
            (equatorialAlignment - 0.45) * 0.25 +
            drainageScore * 0.2 +
            elevationScore * 0.3 +
            (noiseValue - 0.55) * 0.25;
          if (combinedScore > 0.12) {
            jungleMask[idx] = 1;
          }
        }
      }
    }
    const clusterNeighborOffsets = [
      [-1, -1],
      [0, -1],
      [1, -1],
      [-1, 0],
      [1, 0],
      [-1, 1],
      [0, 1],
      [1, 1]
    ];
    const baseSeedThreshold = isFirstAge ? 0.66 : 0.6;
    const baseSoftSeedThreshold = isFirstAge ? 0.56 : 0.5;
    const baseGrowthBaseline = isFirstAge ? 0.48 : 0.42;
    const baseNeighborBonus = isFirstAge ? 0.08 : 0.085;
    const baseDensityAlwaysAdd = isFirstAge ? 0.6 : 0.58;
    const baseSoftSeedMultiplier = isFirstAge ? 1.8 : 1.85;
    const growthSpeedModifier = clamp(
      (isFirstAge ? 0.45 : 0.35) + forestBias * 0.2,
      isFirstAge ? 0.35 : 0.28,
      isFirstAge ? 0.8 : 0.65
    );
    const growthIterationModifier = clamp(
      (isFirstAge ? 0.5 : 0.38) + forestBias * 0.25,
      isFirstAge ? 0.5 : 0.35,
      isFirstAge ? 0.95 : 0.75
    );
    const seedThreshold = clamp(
      baseSeedThreshold - forestBias * (isFirstAge ? 0.18 : 0.13),
      0.35,
      0.92
    );
    const softSeedThreshold = clamp(
      baseSoftSeedThreshold - forestBias * (isFirstAge ? 0.16 : 0.13),
      0.25,
      0.88
    );
    const growthBaseline = clamp(
      baseGrowthBaseline - forestBias * (isFirstAge ? 0.14 : 0.12),
      0.2,
      0.72
    );
    const neighborBonus = clamp(
      baseNeighborBonus + forestBias * (isFirstAge ? 0.04 : 0.035),
      0.02,
      0.12
    );
    const densityAlwaysAddThreshold = clamp(
      baseDensityAlwaysAdd - forestBias * (isFirstAge ? 0.12 : 0.08) + (1 - growthSpeedModifier) * 0.1,
      0.45,
      0.84
    );
    const softSeedMultiplier = clamp(
      baseSoftSeedMultiplier + forestBias * (isFirstAge ? 0.6 : 0.55),
      0.8,
      2.2
    );
    const maxGrowthIterations = Math.max(1, Math.round((isFirstAge ? 2 : 1.5) * growthIterationModifier));

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const normalizedX = (x + 0.5) / width;
        const normalizedY = (y + 0.5) / height;
        const baseNoise = octaveNoise(
          (normalizedX + treeBaseOffsetX) * treeBaseScale,
          (normalizedY + treeBaseOffsetY) * treeBaseScale,
          treeBaseSeed,
          3,
          0.55,
          2.05
        );
        const detailNoise = octaveNoise(
          (normalizedX + treeDetailOffsetX) * treeDetailScale,
          (normalizedY + treeDetailOffsetY) * treeDetailScale,
          treeDetailSeed,
          4,
          0.5,
          2.3
        );
        const elevationValue = elevationField[idx];
        const elevationPreference = clamp(1 - Math.abs(elevationValue - (seaLevel + 0.12)) * 2.6, 0, 1);
        let density = baseNoise * 0.68 + detailNoise * 0.32;
        density = clamp(density * 0.6 + elevationPreference * 0.4, 0, 1);
        const rainfallValue = rainfallField[idx];
        density = clamp(density * 0.55 + rainfallValue * 0.45, 0, 1);
        const biasMultiplier = isFirstAge ? 1 + forestBias * 0.25 : 1 + forestBias * 0.2;
        density = clamp(density * biasMultiplier, 0, 1);
        // Apply a small additive push so that the highest slider values can still create forests
        // even when the multiplicative bias is already clamped by rainfall or elevation limits.
        density = clamp(density + forestBias * 0.08, 0, 1);
        if (!isFirstAge) {
          const clusterNoise = octaveNoise(
            (normalizedX + treeClusterOffsetX) * treeClusterScale,
            (normalizedY + treeClusterOffsetY) * treeClusterScale,
            treeClusterSeed,
            3,
            0.55,
            2.2
          );
          const clusterWeight = clamp((clusterNoise - 0.35) * 1.6, 0, 1);
          density = clamp(density * (0.55 + clusterWeight * 0.65), 0, 1);
        }
        treeDensityField[idx] = density;
      }
    }

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        const hillOverlayKeyForTile = getHillOverlayKeyForTile(tile);
        const overlay = tile.overlay;
        const overlayBlocksTree = overlay && (!hillOverlayKeyForTile || overlay !== hillOverlayKeyForTile);
        if (
          overlayBlocksTree ||
          !isLandBaseTile(tile.base) ||
          tile.structure ||
          tile.river ||
          isDesertBaseTile(tile.base)
        ) {
          continue;
        }
        const density = treeDensityField[idx];
        if (
          density >= seedThreshold ||
          (density > softSeedThreshold && rng() < (density - softSeedThreshold) * softSeedMultiplier)
        ) {
          treeMask[idx] = 1;
          if (tile.base === marshTileKey) {
            tile.base = grassTileKey;
          }
          if (hillOverlayKeyForTile) {
            tile.hillOverlay = hillOverlayKeyForTile;
          }
          tile.overlay = selectTreeOverlayForTile(tile, idx);
        }
      }
    }

    for (let iteration = 0; iteration < maxGrowthIterations; iteration += 1) {
      const additions = [];
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (waterMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          const hillOverlayKeyForTile = getHillOverlayKeyForTile(tile);
          const overlay = tile.overlay;
          const overlayBlocksTree = overlay && (!hillOverlayKeyForTile || overlay !== hillOverlayKeyForTile);
          if (
            overlayBlocksTree ||
            !isLandBaseTile(tile.base) ||
            tile.structure ||
            tile.river ||
            isDesertBaseTile(tile.base)
          ) {
            continue;
          }
          let neighborTrees = 0;
          for (let i = 0; i < clusterNeighborOffsets.length; i += 1) {
            const nx = x + clusterNeighborOffsets[i][0];
            const ny = y + clusterNeighborOffsets[i][1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            const nIdx = ny * width + nx;
            if (treeMask[nIdx]) {
              neighborTrees += 1;
            }
          }
          if (neighborTrees < 2) {
            continue;
          }
          const density = treeDensityField[idx];
          const baseGrowthChance =
            (density - growthBaseline) / 0.52 + neighborTrees * neighborBonus;
          const probability = clamp(baseGrowthChance * growthSpeedModifier, 0, 1);
          if (density > densityAlwaysAddThreshold || rng() < probability) {
            additions.push(idx);
          }
        }
      }

      if (additions.length === 0) {
        break;
      }

      for (let i = 0; i < additions.length; i += 1) {
        const idx = additions[i];
        if (treeMask[idx]) {
          continue;
        }
        if (waterMask[idx]) {
          continue;
        }
        const y = Math.floor(idx / width);
        const x = idx % width;
        const tile = tiles[y][x];
        const hillOverlayKeyForTile = getHillOverlayKeyForTile(tile);
        const overlay = tile.overlay;
        const overlayBlocksTree = overlay && (!hillOverlayKeyForTile || overlay !== hillOverlayKeyForTile);
        if (
          overlayBlocksTree ||
          !isLandBaseTile(tile.base) ||
          tile.structure ||
          tile.river ||
          isDesertBaseTile(tile.base)
        ) {
          continue;
        }
        treeMask[idx] = 1;
        if (tile.base === marshTileKey) {
          tile.base = grassTileKey;
        }
        if (hillOverlayKeyForTile) {
          tile.hillOverlay = hillOverlayKeyForTile;
        }
        tile.overlay = selectTreeOverlayForTile(tile, idx);
      }
    }

    if ((hasSandTile || hasBadlandsTile) && treeOverlayKeys.length > 0) {
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (!treeMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          if (!tile || !isTreeOverlayKey(tile.overlay)) {
            continue;
          }
          let adjacentToDesert = false;
          for (let i = 0; i < neighborOffsets8.length; i += 1) {
            const nx = x + neighborOffsets8[i][0];
            const ny = y + neighborOffsets8[i][1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            const neighborTile = tiles[ny][nx];
            if (neighborTile && isDesertBaseTile(neighborTile.base)) {
              adjacentToDesert = true;
              break;
            }
          }
          if (!adjacentToDesert) {
            continue;
          }
          treeMask[idx] = 0;
          tile.overlay = null;
        }
      }
    }

    if (treeOverlayKey && treeLoneOverlayKey) {
      const loneTreeVariantChance = 0.5;
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (!treeMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          if (!tile || tile.overlay !== treeOverlayKey) {
            continue;
          }
          let hasNeighborTree = false;
          for (let i = 0; i < neighborOffsets8.length; i += 1) {
            const nx = x + neighborOffsets8[i][0];
            const ny = y + neighborOffsets8[i][1];
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
              continue;
            }
            const neighborTile = tiles[ny][nx];
            if (tileHasTreeOverlay(neighborTile)) {
              hasNeighborTree = true;
              break;
            }
          }
          if (!hasNeighborTree && rng() < loneTreeVariantChance) {
            tile.overlay = treeLoneOverlayKey;
          }
        }
      }
    }

  const woodElfGroveBaseKey = tileLookup.has('WOOD_ELF_GROVES') ? 'WOOD_ELF_GROVES' : null;
  const woodElfGroveLargeKey = tileLookup.has('WOOD_ELF_GROVES_LARGE') ? 'WOOD_ELF_GROVES_LARGE' : null;
  const woodElfGroveGrandKey = tileLookup.has('WOOD_ELF_GROVES_GRAND') ? 'WOOD_ELF_GROVES_GRAND' : null;
  if (woodElfGroveBaseKey) {
      const getOceanMask = (() => {
        let computed = false;
        return () => {
          if (computed) {
            return oceanMask && oceanMask.length === width * height ? oceanMask : null;
          }
          computed = true;
          if (!oceanMask || !waterMask || waterMask.length !== width * height) {
            return null;
          }
          oceanMask.fill(0);
          const queue = new Int32Array(width * height);
          let head = 0;
          let tail = 0;
          const enqueue = (idx) => {
            if (oceanMask[idx]) {
              return;
            }
            oceanMask[idx] = 1;
            queue[tail] = idx;
            tail += 1;
          };
          for (let x = 0; x < width; x += 1) {
            const topIdx = x;
            if (waterMask[topIdx]) {
              enqueue(topIdx);
            }
            const bottomIdx = (height - 1) * width + x;
            if (waterMask[bottomIdx]) {
              enqueue(bottomIdx);
            }
          }
          for (let y = 1; y < height - 1; y += 1) {
            const leftIdx = y * width;
            if (waterMask[leftIdx]) {
              enqueue(leftIdx);
            }
            const rightIdx = y * width + (width - 1);
            if (waterMask[rightIdx]) {
              enqueue(rightIdx);
            }
          }
          while (head < tail) {
            const current = queue[head];
            head += 1;
            const cx = current % width;
            const cy = Math.floor(current / width);
            for (let i = 0; i < neighborOffsets8.length; i += 1) {
              const nx = cx + neighborOffsets8[i][0];
              const ny = cy + neighborOffsets8[i][1];
              if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
                continue;
              }
              const nIdx = ny * width + nx;
              if (!waterMask[nIdx] || oceanMask[nIdx]) {
                continue;
              }
              enqueue(nIdx);
            }
          }
          return oceanMask;
        };
      })();

      const isTileNearOcean = (x, y) => {
        if (x < 0 || y < 0 || x >= width || y >= height) {
          return true;
        }
        const mask = getOceanMask();
        if (!mask) {
          return false;
        }
        const idx = y * width + x;
        if (mask[idx]) {
          return true;
        }
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (mask[nIdx]) {
            return true;
          }
        }
        return false;
      };
      const groveCandidates = [];
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          const tile = tiles[y][x];
          if (
            !tile ||
            !tileHasTreeOverlay(tile) ||
            tileHasJungleOverlay(tile) ||
            tile.structure ||
            (hasSnowTile && tile.base === snowTileKey)
          ) {
            continue;
          }
          if (isTileNearOcean(x, y)) {
            continue;
          }
          const score = treeDensityField ? treeDensityField[idx] : 0;
          groveCandidates.push({ x, y, score });
        }
      }

      if (groveCandidates.length > 0) {
        groveCandidates.sort((a, b) => b.score - a.score);
        const baseTarget = Math.max(1, Math.round(groveCandidates.length / 1350));
        const maxGroves = computeStructurePlacementLimit(
          baseTarget,
          28,
          woodElfSettlementMultiplier
        );
        // Increase the base separation so wood elf groves feel rare and distinct.
        const minDistanceBase = 14;
        const minDistance = adjustMinDistance(minDistanceBase, woodElfSettlementFrequencyNormalized);
        const minDistanceSq = minDistance * minDistance;
        const placed = [];

        for (let i = 0; i < groveCandidates.length; i += 1) {
          if (placed.length >= maxGroves) {
            break;
          }
          const candidate = groveCandidates[i];
          if (candidate.score < 0.32) {
            continue;
          }
          let tooClose = false;
          for (let j = 0; j < placed.length; j += 1) {
            const other = placed[j];
            const dx = candidate.x - other.x;
            const dy = candidate.y - other.y;
            if (dx * dx + dy * dy < minDistanceSq) {
              tooClose = true;
              break;
            }
          }
          if (tooClose) {
            continue;
          }
          const tile = tiles[candidate.y][candidate.x];
          if (
            !tile ||
            !tileHasTreeOverlay(tile) ||
            tileHasJungleOverlay(tile) ||
            tile.structure ||
            (hasSnowTile && tile.base === snowTileKey) ||
            isTileNearOcean(candidate.x, candidate.y)
          ) {
            continue;
          }
          const name = generateWoodElfGroveName(rng);
          const details = generateWoodElfGroveDetails(name, rng);
          let structureKey = woodElfGroveBaseKey;
          const populationMax = Number.isFinite(details?.populationMax) ? details.populationMax : null;
          const populationValue = Number.isFinite(details?.population) ? details.population : null;
          if (populationMax && populationMax > 0 && populationValue != null) {
            const populationRatio = populationValue / populationMax;
            if (woodElfGroveGrandKey && populationRatio >= 0.9) {
              structureKey = woodElfGroveGrandKey;
            } else if (woodElfGroveLargeKey && populationRatio >= 0.8) {
              structureKey = woodElfGroveLargeKey;
            }
          }

          tile.structure = structureKey;
          tile.structureName = details.name || name;
          tile.structureDetails = details;
          placed.push(candidate);
          woodElfGroves.push({ x: candidate.x, y: candidate.y, ...details });
        }
      }
    }
  }

  const lizardmenCityKey =
    tileLookup.has('LIZARDMEN_CITY') && treeJungleOverlayKey ? 'LIZARDMEN_CITY' : null;
  if (lizardmenCityKey && treeJungleOverlayKey) {
    const cityCandidates = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const tile = tiles[y][x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (!tileHasJungleOverlay(tile)) {
          continue;
        }
        const rainfallValue = rainfallField[idx];
        const drainageValue = drainageField[idx];
        const normalizedY = (y + 0.5) / height;
        const equatorialAlignment = clamp(1 - Math.abs(normalizedY - 0.5) * 2, 0, 1);
        const humidity = clamp(rainfallValue * 0.7 + (1 - drainageValue) * 0.3, 0, 1);
        const elevationValue = elevationField[idx];
        const elevationPreference = clamp(1 - Math.abs(elevationValue - (seaLevel + 0.08)) * 3, 0, 1);
        const density = treeDensityField ? treeDensityField[idx] : 0;
        const score =
          density * 0.45 + humidity * 0.25 + equatorialAlignment * 0.15 + elevationPreference * 0.15;
        cityCandidates.push({ x, y, score });
      }
    }

    if (cityCandidates.length > 0) {
      cityCandidates.sort((a, b) => b.score - a.score);
      const baseTarget = Math.max(1, Math.round(cityCandidates.length / 1650));
      const maxCities = computeStructurePlacementLimit(baseTarget, 18, lizardmenSettlementMultiplier);
      const minDistanceBase = 18;
      const minDistance = adjustMinDistance(minDistanceBase, lizardmenSettlementFrequencyNormalized);
      const minDistanceSq = minDistance * minDistance;
      const placed = [];

      for (let i = 0; i < cityCandidates.length; i += 1) {
        if (placed.length >= maxCities) {
          break;
        }
        const candidate = cityCandidates[i];
        if (candidate.score < 0.33) {
          continue;
        }
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < minDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (tooClose) {
          continue;
        }
        const tile = tiles[candidate.y][candidate.x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (!tileHasJungleOverlay(tile)) {
          continue;
        }
        const name = generateLizardmenCityName(rng);
        const details = generateLizardmenCityDetails(name, rng);
        tile.structure = lizardmenCityKey;
        tile.structureName = details.name || name;
        tile.structureDetails = details;
        placed.push(candidate);
        lizardmenCities.push({ x: candidate.x, y: candidate.y, ...details });
      }
    }
  }

  const roadReplaceableOverlays = new Set([...treeOverlayKeys, ...hillOverlayKeys]);

  if (towns.length > 1) {
    connectTownsWithinRange(tiles, towns, {
      maxDistance: 25,
      overlayKey: TOWN_ROAD_OVERLAY_KEY,
      width,
      height,
      isLandBaseTile,
      waterMask,
      treeOverlayKey,
      treeSnowOverlayKey,
      treeOverlayKeys,
      isMountainOverlay,
      replaceableOverlays: roadReplaceableOverlays
    });
  }

  const evilWizardTowerKey = tileLookup.has('EVIL_WIZARDS_TOWER') ? 'EVIL_WIZARDS_TOWER' : null;
  if (evilWizardTowerKey) {
    const towerCandidates = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (treeOverlayKeys.length > 0 && isTreeOverlayKeyForGeneration(tile.overlay)) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        if (tile.overlay) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = tile.base === snowTileKey;
        if (!baseIsGrass && !baseIsSnow) {
          continue;
        }
        const heightValue = elevationField[idx];
        const elevationScore = clamp((heightValue - seaLevel) * 3.1, 0, 1);
        const rainfallValue = rainfallField[idx];
        const drynessScore = clamp(1 - rainfallValue, 0, 1);
        let terrainBonus = 0;
        if (baseIsSnow) {
          terrainBonus += 0.18;
        } else if (baseIsGrass) {
          terrainBonus += 0.12;
        }
        const edgeDistance = Math.min(x, width - 1 - x, y, height - 1 - y);
        const maxEdgeDistance = Math.max(1, Math.min(width, height) / 2.2);
        const edgeScore = clamp(edgeDistance / maxEdgeDistance, 0, 1);
        const score =
          elevationScore * 0.35 + drynessScore * 0.2 + terrainBonus + edgeScore * 0.15 + rng() * 0.3;
        towerCandidates.push({ x, y, score });
      }
    }

    if (towerCandidates.length > 0) {
      towerCandidates.sort((a, b) => b.score - a.score);
      const area = width * height;
      const baseTarget = Math.max(1, Math.round(area / 20000));
      const maxTowers = computeStructurePlacementLimit(baseTarget, 18, towerSettlementMultiplier);
      const baseMinDistance = Math.max(5, Math.round(Math.min(width, height) / 14));
      const minDistance = adjustMinDistance(baseMinDistance, towerSettlementFrequencyNormalized);
      const minDistanceSq = minDistance * minDistance;
      const placed = [];

      for (let i = 0; i < towerCandidates.length; i += 1) {
        if (placed.length >= maxTowers) {
          break;
        }
        const candidate = towerCandidates[i];
        if (candidate.score < 0.22) {
          continue;
        }
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < minDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (!tooClose) {
          for (let j = 0; j < towerProximityPoints.length; j += 1) {
            const other = towerProximityPoints[j];
            if (!other) {
              continue;
            }
            const dx = candidate.x - other.x;
            const dy = candidate.y - other.y;
            if (dx * dx + dy * dy < minDistanceSq) {
              tooClose = true;
              break;
            }
          }
        }
        if (tooClose) {
          continue;
        }
        const tile = tiles[candidate.y][candidate.x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (treeOverlayKeys.length > 0 && isTreeOverlayKeyForGeneration(tile.overlay)) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        if (tile.overlay) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = tile.base === snowTileKey;
        if (!baseIsGrass && !baseIsSnow) {
          continue;
        }
        const name = `Evil Wizard's ${generateTowerName(rng)}`;
        const details = generateEvilWizardTowerDetails(name, rng);
        tile.structure = evilWizardTowerKey;
        tile.structureName = name;
        tile.structureDetails = details;
        placed.push(candidate);
        recordTowerProximityPoint(candidate.x, candidate.y);
        evilWizardTowers.push({ x: candidate.x, y: candidate.y, ...details });
      }
    }
  }

  const towerKey = tileLookup.has('TOWER') ? 'TOWER' : null;
  if (towerKey) {
    const towerCandidates = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (treeOverlayKeys.length > 0 && isTreeOverlayKeyForGeneration(tile.overlay)) {
          continue;
        }
        if (tile.overlay) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = tile.base === snowTileKey;
        if (!baseIsGrass && !baseIsSnow) {
          continue;
        }
        const heightValue = elevationField[idx];
        const elevationScore = clamp((heightValue - seaLevel) * 3.1, 0, 1);
        const rainfallValue = rainfallField[idx];
        const drynessScore = clamp(1 - rainfallValue, 0, 1);
        let terrainBonus = 0;
        if (baseIsSnow) {
          terrainBonus += 0.18;
        } else if (baseIsGrass) {
          terrainBonus += 0.12;
        }
        const edgeDistance = Math.min(x, width - 1 - x, y, height - 1 - y);
        const maxEdgeDistance = Math.max(1, Math.min(width, height) / 2.2);
        const edgeScore = clamp(edgeDistance / maxEdgeDistance, 0, 1);
        const score =
          elevationScore * 0.35 + drynessScore * 0.2 + terrainBonus + edgeScore * 0.15 + rng() * 0.3;
        towerCandidates.push({ x, y, score });
      }
    }

    if (towerCandidates.length > 0) {
      towerCandidates.sort((a, b) => b.score - a.score);
      const area = width * height;
      const baseTarget = Math.max(1, Math.round(area / 20000));
      const maxTowers = computeStructurePlacementLimit(baseTarget, 18, towerSettlementMultiplier);
      const baseMinDistance = Math.max(5, Math.round(Math.min(width, height) / 14));
      const minDistance = adjustMinDistance(baseMinDistance, towerSettlementFrequencyNormalized);
      const minDistanceSq = minDistance * minDistance;
      const placed = [];

      for (let i = 0; i < towerCandidates.length; i += 1) {
        if (placed.length >= maxTowers) {
          break;
        }
        const candidate = towerCandidates[i];
        if (candidate.score < 0.22) {
          continue;
        }
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < minDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (!tooClose) {
          for (let j = 0; j < towerProximityPoints.length; j += 1) {
            const other = towerProximityPoints[j];
            if (!other) {
              continue;
            }
            const dx = candidate.x - other.x;
            const dy = candidate.y - other.y;
            if (dx * dx + dy * dy < minDistanceSq) {
              tooClose = true;
              break;
            }
          }
        }
        if (tooClose) {
          continue;
        }
        const tile = tiles[candidate.y][candidate.x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (treeOverlayKeys.length > 0 && isTreeOverlayKeyForGeneration(tile.overlay)) {
          continue;
        }
        if (tile.overlay) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = tile.base === snowTileKey;
        if (!baseIsGrass && !baseIsSnow) {
          continue;
        }
        const name = generateTowerName(rng);
        const details = generateTowerDetails(name, rng);
        tile.structure = towerKey;
        tile.structureName = name;
        tile.structureDetails = details;
        placed.push(candidate);
        recordTowerProximityPoint(candidate.x, candidate.y);
        towers.push({ x: candidate.x, y: candidate.y, ...details });
      }
    }
  }

  const dwarvenSettlements = [...dwarfholds, ...hillholds, ...mines];
  const majorSettlementPoints = [
    ...dwarvenSettlements,
    ...towns,
    ...woodElfGroves,
    ...lizardmenCities,
    ...towers,
    ...evilWizardTowers
  ];
  const hillOverlayKeysForStructures = new Set(
    ['HILLS', 'HILLS_VARIANT_A', 'HILLS_VARIANT_B', 'HILLS_SNOW', 'HILLS_BADLANDS'].filter((key) =>
      tileLookup.has(key)
    )
  );
  const isHillOverlayForStructures = (overlayKey) =>
    overlayKey != null && hillOverlayKeysForStructures.has(overlayKey);
  const mapArea = width * height;
  const orcCampNoiseSeed = (seedNumber + 0x4a1d2b7f) >>> 0;
  const centaurEncampmentNoiseSeed = (seedNumber + 0x53d1c87b) >>> 0;
  const travelerCampNoiseSeed = (seedNumber + 0x579c3d11) >>> 0;
  const dungeonNoiseSeed = (seedNumber + 0x5c8d3a1f) >>> 0;
  const monasteryNoiseSeed = (seedNumber + 0x6f12c43d) >>> 0;
  const monasteryLatitudeSeed = (seedNumber + 0x71c2d9a7) >>> 0;
  const castleNoiseSeed = (seedNumber + 0x7be21a59) >>> 0;
  const shrineNoiseSeed = (seedNumber + 0x8cf43123) >>> 0;
  const shrineLatitudeSeed = (seedNumber + 0x90a2f4c1) >>> 0;
  const tavernNoiseSeed = (seedNumber + 0x9324f8b1) >>> 0;

  const orcCampKey = tileLookup.has('ORC_CAMP') ? 'ORC_CAMP' : null;
  const gnollCampKey = tileLookup.has('GNOLL_CAMP') ? 'GNOLL_CAMP' : null;
  const trollCampKey = tileLookup.has('TROLL_CAMP') ? 'TROLL_CAMP' : null;
  const ogreCampKey = tileLookup.has('OGRE_CAMP') ? 'OGRE_CAMP' : null;
  const banditCampKey = tileLookup.has('BANDIT_CAMP') ? 'BANDIT_CAMP' : null;
  const warCampStructureKeys = {
    orcCamp: orcCampKey,
    gnollCamp: gnollCampKey || orcCampKey,
    trollCamp: trollCampKey || orcCampKey,
    ogreCamp: ogreCampKey || orcCampKey,
    banditCamp: banditCampKey || orcCampKey
  };
  const availableWarCampTypes = Object.entries(warCampStructureKeys)
    .filter(([, key]) => key)
    .map(([type]) => type);
  if (availableWarCampTypes.length > 0) {
    const resolvedWarCampStructureKeys = availableWarCampTypes.reduce((acc, type) => {
      acc[type] = warCampStructureKeys[type];
      return acc;
    }, {});
    const allowedOrcBases = new Set(
      [grassTileKey, sandTileKey, marshTileKey, badlandsTileKey].filter((key) => typeof key === 'string')
    );
    const orcCampCandidates = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (!allowedOrcBases.has(tile.base)) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        const settlementDistSq = computeNearestDistanceSq(x, y, majorSettlementPoints);
        if (settlementDistSq < 36) {
          continue;
        }
        const rainfallValue = rainfallField[idx];
        const dryness = clamp(1 - rainfallValue, 0, 1);
        let baseScore = 0.2;
        if (tile.base === badlandsTileKey) {
          baseScore += 0.45;
        } else if (tile.base === sandTileKey) {
          baseScore += 0.36;
        } else if (tile.base === marshTileKey) {
          baseScore += 0.28;
        } else {
          baseScore += 0.24;
        }
        const hillPresent =
          (isHillOverlayForStructures(tile.overlay) || isHillOverlayForStructures(tile.hillOverlay)) &&
          tile.base !== marshTileKey;
        const hillBonus = hillPresent ? 0.16 : 0;
        let waterAdjacency = 0;
        for (let i = 0; i < cardinalOffsets.length; i += 1) {
          const nx = x + cardinalOffsets[i][0];
          const ny = y + cardinalOffsets[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            waterAdjacency += 1;
          }
        }
        const waterScore = clamp(waterAdjacency * 0.08, 0, 0.18);
        let settlementPenalty = 0;
        let settlementDistance = Infinity;
        if (settlementDistSq !== Infinity) {
          settlementDistance = Math.sqrt(settlementDistSq);
          settlementPenalty = clamp((10 - settlementDistance) * 0.05, 0, 0.35);
        }
        const borderDistance = Math.min(x, width - 1 - x, y, height - 1 - y);
        const edgeScore = clamp(borderDistance / Math.max(6, Math.min(width, height) / 3.2), 0, 1) * 0.12;
        const noise = hashCoords(x, y, orcCampNoiseSeed) - 0.5;
        const score =
          baseScore +
          dryness * 0.35 +
          hillBonus +
          waterScore +
          edgeScore +
          noise * 0.22 +
          rng() * 0.18 -
          settlementPenalty;
        if (score > 0.28) {
          const baseKey = tile.base;
          orcCampCandidates.push({
            x,
            y,
            score,
            dryness,
            waterAdjacency,
            hill: hillPresent,
            settlementDistance,
            base: baseKey,
            isSand: baseKey === sandTileKey,
            isBadlands: baseKey === badlandsTileKey,
            isMarsh: baseKey === marshTileKey,
            isSnow: baseKey === snowTileKey,
            isGrass: baseKey === grassTileKey
          });
        }
      }
    }

    if (orcCampCandidates.length > 0) {
      orcCampCandidates.sort((a, b) => b.score - a.score);
      const baseTarget = Math.max(1, Math.round(mapArea / 14000));
      const maxCamps = computeStructurePlacementLimit(baseTarget, 16, 1);
      const minDistance = 8;
      const minDistanceSq = minDistance * minDistance;
      const placed = [];

      for (let i = 0; i < orcCampCandidates.length; i += 1) {
        if (placed.length >= maxCamps) {
          break;
        }
        const candidate = orcCampCandidates[i];
        if (candidate.score < 0.3) {
          continue;
        }
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < minDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (tooClose) {
          continue;
        }
        const tile = tiles[candidate.y][candidate.x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        const settlementDistSq = computeNearestDistanceSq(candidate.x, candidate.y, majorSettlementPoints);
        if (settlementDistSq < 36) {
          continue;
        }
        const campType = selectWarCampType(rng, candidate, availableWarCampTypes);
        const structureKey = resolvedWarCampStructureKeys[campType];
        if (!structureKey) {
          continue;
        }
        const warCampContext = {
          terrain: resolveWarCampTerrainDescriptor(candidate),
          targetHint: resolveWarCampTargetHint(candidate),
          settlementDistance: candidate.settlementDistance
        };
        const { name, details } = generateWarCampForType(campType, rng, warCampContext);
        tile.structure = structureKey;
        tile.structureName = name;
        tile.structureDetails = details;
        placed.push(candidate);
        const record = { x: candidate.x, y: candidate.y, ...details };
        hostileWarCamps.push(record);
        switch (campType) {
          case 'orcCamp':
            orcCamps.push(record);
            break;
          case 'gnollCamp':
            gnollCamps.push(record);
            break;
          case 'trollCamp':
            trollCamps.push(record);
            break;
          case 'ogreCamp':
            ogreCamps.push(record);
            break;
          case 'banditCamp':
            banditCamps.push(record);
            break;
          default:
            orcCamps.push(record);
            break;
        }
      }
    }
  }

  const centaurEncampmentKey = tileLookup.has('CENTAUR_ENCAMPMENT') ? 'CENTAUR_ENCAMPMENT' : null;
  if (centaurEncampmentKey) {
    const allowedCentaurBases = new Set(
      [grassTileKey, badlandsTileKey, snowTileKey].filter((key) => typeof key === 'string')
    );
    let centaurGrassDistanceField = null;
    if (allowedCentaurBases.size > 0) {
      const grassMask = new Uint8Array(width * height);
      let hasGrass = false;
      for (let y = 0; y < height; y += 1) {
        const row = tiles[y];
        if (!row) {
          continue;
        }
        for (let x = 0; x < width; x += 1) {
          const tile = row[x];
          if (tile && tile.base === grassTileKey) {
            grassMask[y * width + x] = 1;
            hasGrass = true;
          }
        }
      }
      if (hasGrass) {
        centaurGrassDistanceField = computeEuclideanDistanceField(grassMask, width, height);
      }
    }

    if (centaurGrassDistanceField) {
      const centaurEncampmentCandidates = [];
      const requiredGrassDistanceSq = 15 * 15;
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (waterMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          if (!tile || tile.structure || tile.river) {
            continue;
          }
          if (!allowedCentaurBases.has(tile.base)) {
            continue;
          }
          if (centaurGrassDistanceField[idx] > requiredGrassDistanceSq) {
            continue;
          }
          if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
            continue;
          }
          const settlementDistSq = computeNearestDistanceSq(x, y, majorSettlementPoints);
          if (settlementDistSq < 49) {
            continue;
          }
          const distanceToOrcsSq = computeNearestDistanceSq(x, y, hostileWarCamps);
          if (distanceToOrcsSq < 64) {
            continue;
          }
          const rainfallValue = clamp(rainfallField[idx], 0, 1);
          const rainfallScore = clamp(1 - Math.abs(rainfallValue - 0.55) * 1.6, 0, 1);
          const canopyDensity = clamp(tile.forestCanopyDensity || 0, 0, 1);
          const opennessScore = clamp(1 - canopyDensity, 0, 1);
          const distanceToGrass = Math.sqrt(centaurGrassDistanceField[idx]);
          const grassProximity = clamp(1 - Math.min(distanceToGrass, 15) / 15, 0, 1);
          const baseScore =
            tile.base === grassTileKey ? 0.43 : tile.base === badlandsTileKey ? 0.41 : 0.38;
          const hillPenalty =
            isHillOverlayForStructures(tile.overlay) || isHillOverlayForStructures(tile.hillOverlay)
              ? 0.12
              : 0;
          const noise = hashCoords(x, y, centaurEncampmentNoiseSeed) - 0.5;
          const score =
            baseScore +
            grassProximity * 0.35 +
            rainfallScore * 0.25 +
            opennessScore * 0.2 -
            hillPenalty +
            noise * 0.18;
          if (score > 0.3) {
            centaurEncampmentCandidates.push({ x, y, score });
          }
        }
      }

      if (centaurEncampmentCandidates.length > 0) {
        centaurEncampmentCandidates.sort((a, b) => b.score - a.score);
        const baseTarget = Math.max(1, Math.round(mapArea / 15000));
        const maxEncampments = computeStructurePlacementLimit(baseTarget, 14, 1);
        const minDistance = 9;
        const minDistanceSq = minDistance * minDistance;
        const placed = [];

        for (let i = 0; i < centaurEncampmentCandidates.length; i += 1) {
          if (placed.length >= maxEncampments) {
            break;
          }
          const candidate = centaurEncampmentCandidates[i];
          if (candidate.score < 0.32) {
            continue;
          }
          let tooClose = false;
          for (let j = 0; j < placed.length; j += 1) {
            const other = placed[j];
            const dx = candidate.x - other.x;
            const dy = candidate.y - other.y;
            if (dx * dx + dy * dy < minDistanceSq) {
              tooClose = true;
              break;
            }
          }
          if (tooClose) {
            continue;
          }
          const tile = tiles[candidate.y][candidate.x];
          if (!tile || tile.structure || tile.river) {
            continue;
          }
          if (!allowedCentaurBases.has(tile.base)) {
            continue;
          }
          if (centaurGrassDistanceField[candidate.y * width + candidate.x] > requiredGrassDistanceSq) {
            continue;
          }
          const name = generateCentaurEncampmentName(rng);
          const details = generateCentaurEncampmentDetails(name, rng);
          tile.structure = centaurEncampmentKey;
          tile.structureName = name;
          tile.structureDetails = details;
          placed.push(candidate);
          centaurEncampments.push({ x: candidate.x, y: candidate.y, ...details });
        }
      }
    }
  }

  const travelerCampKey = tileLookup.has('TRAVELERS_CAMP') ? 'TRAVELERS_CAMP' : null;
  if (travelerCampKey) {
    const travelerCampCandidates = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSand = tile.base === sandTileKey;
        const baseIsBadlands = hasBadlandsTile && tile.base === badlandsTileKey;
        const baseIsMarsh = tile.base === marshTileKey;
        if (!baseIsGrass && !baseIsSand && !baseIsBadlands && !baseIsMarsh) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        const nearestSettlement = findNearestPointWithDetails(x, y, majorSettlementPoints);
        if (!nearestSettlement || !Number.isFinite(nearestSettlement.distance)) {
          continue;
        }
        const distance = nearestSettlement.distance;
        if (distance < 4 || distance > 26) {
          continue;
        }
        const distanceToOrcsSq = computeNearestDistanceSq(x, y, hostileWarCamps);
        if (distanceToOrcsSq < 49) {
          continue;
        }
        const distanceToCentaurSq = computeNearestDistanceSq(x, y, centaurEncampments);
        if (distanceToCentaurSq < 64) {
          continue;
        }
        let waterAdjacency = 0;
        for (let i = 0; i < cardinalOffsets.length; i += 1) {
          const nx = x + cardinalOffsets[i][0];
          const ny = y + cardinalOffsets[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            waterAdjacency += 1;
            continue;
          }
          const neighborTile = tiles[ny][nx];
          if (neighborTile && neighborTile.river) {
            waterAdjacency += 1;
          }
        }
        const rainfallValue = rainfallField[idx];
        const drainageValue = drainageField[idx];
        const dryness = clamp(1 - rainfallValue, 0, 1);
        const soilSoftness = clamp(1 - drainageValue, 0, 1);
        const hillBonus =
          isHillOverlayForStructures(tile.overlay) || isHillOverlayForStructures(tile.hillOverlay) ? 0.08 : 0;
        const distanceScore = clamp(1 - Math.abs(distance - 10) / 9, 0, 1) * 0.32;
        const waterScore = clamp(waterAdjacency * 0.07, 0, 0.2);
        const drynessScore = dryness * 0.18;
        const comfortScore = soilSoftness * 0.12;
        const noise = hashCoords(x, y, travelerCampNoiseSeed) - 0.5;
        const score =
          0.24 +
          distanceScore +
          hillBonus +
          waterScore +
          drynessScore +
          comfortScore +
          noise * 0.18 +
          rng() * 0.12;
        if (score > 0.3) {
          travelerCampCandidates.push({ x, y, score, nearestSettlement });
        }
      }
    }

    if (travelerCampCandidates.length > 0) {
      travelerCampCandidates.sort((a, b) => b.score - a.score);
      const baseTarget = Math.max(1, Math.round(mapArea / 20000));
      const maxCamps = computeStructurePlacementLimit(baseTarget, 14, 1);
      const minDistance = 7;
      const minDistanceSq = minDistance * minDistance;
      const placed = [];

      for (let i = 0; i < travelerCampCandidates.length; i += 1) {
        if (placed.length >= maxCamps) {
          break;
        }
        const candidate = travelerCampCandidates[i];
        if (candidate.score < 0.31) {
          continue;
        }
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < minDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (tooClose) {
          continue;
        }
        const tile = tiles[candidate.y][candidate.x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        const nearest =
          candidate.nearestSettlement || findNearestPointWithDetails(candidate.x, candidate.y, majorSettlementPoints);
        const name = generateTravelerCampName(rng);
        const details = generateTravelerCampDetails(name, rng, {
          nearbySettlement: nearest ? nearest.point : null,
          settlementDistance: nearest ? nearest.distance : null
        });
        tile.structure = travelerCampKey;
        tile.structureName = name;
        tile.structureDetails = details;
        placed.push(candidate);
        travelerCamps.push({ x: candidate.x, y: candidate.y, ...details });
      }
    }
  }

  const tavernKey = tileLookup.has('ROADSIDE_TAVERN') ? 'ROADSIDE_TAVERN' : null;
  if (tavernKey) {
    const civilSettlements = [...towns, ...dwarfholds, ...hillholds, ...woodElfGroves, ...castles];
    const tavernCandidates = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSand = tile.base === sandTileKey;
        const baseIsBadlands = hasBadlandsTile && tile.base === badlandsTileKey;
        if (!baseIsGrass && !baseIsSand && !baseIsBadlands) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        const nearestCivil = findNearestPointWithDetails(x, y, civilSettlements);
        if (!nearestCivil || !Number.isFinite(nearestCivil.distance)) {
          continue;
        }
        const distance = nearestCivil.distance;
        if (distance < 3 || distance > 20) {
          continue;
        }
        let riverAdjacency = 0;
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            riverAdjacency += 1;
            continue;
          }
          const neighborTile = tiles[ny][nx];
          if (neighborTile && neighborTile.river) {
            riverAdjacency += 1;
          }
        }
        const rainfallValue = rainfallField[idx];
        const drainageValue = drainageField[idx];
        const fertility = clamp(rainfallValue * 0.6 + (1 - drainageValue) * 0.4, 0, 1);
        const distanceScore = clamp(1 - Math.abs(distance - 8) / 6.5, 0, 1) * 0.36;
        const riverScore = clamp(riverAdjacency * 0.09, 0, 0.24);
        const fertilityScore = fertility * 0.18;
        const noise = hashCoords(x, y, tavernNoiseSeed) - 0.5;
        const score = 0.26 + distanceScore + riverScore + fertilityScore + noise * 0.18 + rng() * 0.1;
        if (score > 0.24) {
          tavernCandidates.push({ x, y, score, nearestCivil });
        }
      }
    }

    if (tavernCandidates.length > 0) {
      tavernCandidates.sort((a, b) => b.score - a.score);
      const baseTarget = Math.max(1, Math.round(mapArea / 18000));
      const maxTaverns = computeStructurePlacementLimit(baseTarget, 12, 1);
      const minDistance = 4;
      const minDistanceSq = minDistance * minDistance;
      const placed = [];

      for (let i = 0; i < tavernCandidates.length; i += 1) {
        if (placed.length >= maxTaverns) {
          break;
        }
        const candidate = tavernCandidates[i];
        if (candidate.score < 0.26) {
          continue;
        }
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < minDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (!tooClose) {
          const distanceToCampSq = computeNearestDistanceSq(candidate.x, candidate.y, travelerCamps);
          if (distanceToCampSq < 25) {
            tooClose = true;
          }
        }
        if (!tooClose) {
          const distanceToOrcSq = computeNearestDistanceSq(candidate.x, candidate.y, hostileWarCamps);
          if (distanceToOrcSq < 64) {
            tooClose = true;
          }
        }
        if (!tooClose) {
          const distanceToCentaurSq = computeNearestDistanceSq(candidate.x, candidate.y, centaurEncampments);
          if (distanceToCentaurSq < 49) {
            tooClose = true;
          }
        }
        if (tooClose) {
          continue;
        }
        const tile = tiles[candidate.y][candidate.x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        const nearest =
          candidate.nearestCivil || findNearestPointWithDetails(candidate.x, candidate.y, civilSettlements);
        const name = generateRoadsideTavernName(rng);
        const details = generateRoadsideTavernDetails(name, rng, {
          nearbySettlement: nearest ? nearest.point : null,
          settlementDistance: nearest ? nearest.distance : null
        });
        tile.structure = tavernKey;
        tile.structureName = name;
        tile.structureDetails = details;
        placed.push(candidate);
        roadsideTaverns.push({ x: candidate.x, y: candidate.y, ...details });
      }

      if (placed.length === 0) {
        const fallbackCandidate = tavernCandidates[0];
        const tile = tiles[fallbackCandidate.y][fallbackCandidate.x];
        if (tile && !tile.structure && !tile.river) {
          if (!(mountainOverlayKey && isMountainOverlay(tile.overlay))) {
            const nearest =
              fallbackCandidate.nearestCivil ||
              findNearestPointWithDetails(fallbackCandidate.x, fallbackCandidate.y, civilSettlements);
            const name = generateRoadsideTavernName(rng);
            const details = generateRoadsideTavernDetails(name, rng, {
              nearbySettlement: nearest ? nearest.point : null,
              settlementDistance: nearest ? nearest.distance : null
            });
            tile.structure = tavernKey;
            tile.structureName = name;
            tile.structureDetails = details;
            placed.push(fallbackCandidate);
            roadsideTaverns.push({ x: fallbackCandidate.x, y: fallbackCandidate.y, ...details });
          }
        }
      }
    }
  }

  const pathEligibleSettlements = [
    ...towns,
    ...castles,
    ...roadsideTaverns,
    ...travelerCamps,
    ...orcCamps,
    ...towers,
    ...evilWizardTowers
  ];

  if (pathEligibleSettlements.length > 1) {
    connectTownsWithinRange(tiles, pathEligibleSettlements, {
      maxDistance: 25,
      overlayKey: TOWN_ROAD_OVERLAY_KEY,
      width,
      height,
      isLandBaseTile,
      waterMask,
      treeOverlayKey,
      treeSnowOverlayKey,
      treeOverlayKeys,
      isMountainOverlay,
      replaceableOverlays: roadReplaceableOverlays
    });
  }

  const dungeonKey = tileLookup.has('DUNGEON') ? 'DUNGEON' : null;
  if (dungeonKey) {
    const dungeonCandidates = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (!isLandBaseTile(tile.base)) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        const settlementDistSq = computeNearestDistanceSq(x, y, majorSettlementPoints);
        if (settlementDistSq < 49) {
          continue;
        }
        const heightValue = elevationField[idx];
        let slopeSum = 0;
        let neighborCount = 0;
        let mountainNeighbors = 0;
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            continue;
          }
          slopeSum += Math.abs(heightValue - elevationField[nIdx]);
          neighborCount += 1;
          if (mountainMask && mountainMask[nIdx]) {
            mountainNeighbors += 1;
          } else {
            const neighborTile = tiles[ny][nx];
            if (neighborTile && mountainOverlayKey && isMountainOverlay(neighborTile.overlay)) {
              mountainNeighbors += 1;
            }
          }
        }
        const averageSlope = neighborCount > 0 ? slopeSum / neighborCount : 0;
        const slopeScore = clamp((averageSlope - 0.008) * 38, 0, 1);
        const hillBonus =
          isHillOverlayForStructures(tile.overlay) || isHillOverlayForStructures(tile.hillOverlay) ? 0.12 : 0;
        const mountainBonus = Math.min(0.3, mountainNeighbors * 0.08);
        const moisture = clamp(rainfallField[idx] * 0.55 + (1 - drainageField[idx]) * 0.45, 0, 1);
        const dampBonus = clamp(moisture * 0.25, 0, 0.18);
        const noise = hashCoords(x, y, dungeonNoiseSeed) - 0.5;
        const score = slopeScore * 0.45 + mountainBonus + hillBonus + dampBonus + noise * 0.3 + rng() * 0.15;
        if (score > 0.2) {
          dungeonCandidates.push({ x, y, score });
        }
      }
    }

    if (dungeonCandidates.length > 0) {
      dungeonCandidates.sort((a, b) => b.score - a.score);
      const baseTarget = Math.max(1, Math.round(mapArea / 21000));
      const maxDungeons = computeStructurePlacementLimit(baseTarget, 14, 1);
      const minDistance = 9;
      const minDistanceSq = minDistance * minDistance;
      const placed = [];

      for (let i = 0; i < dungeonCandidates.length; i += 1) {
        if (placed.length >= maxDungeons) {
          break;
        }
        const candidate = dungeonCandidates[i];
        if (candidate.score < 0.22) {
          continue;
        }
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < minDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (tooClose) {
          continue;
        }
        const tile = tiles[candidate.y][candidate.x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (!isLandBaseTile(tile.base)) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        const name = generateDungeonName(rng);
        const details = generateDungeonDetails(name, rng);
        tile.structure = dungeonKey;
        tile.structureName = name;
        tile.structureDetails = details;
        placed.push(candidate);
        dungeons.push({ x: candidate.x, y: candidate.y, ...details });
      }
    }
  }

  const monasteryKey = tileLookup.has('MONASTERY') ? 'MONASTERY' : null;
  if (monasteryKey) {
    const monasteryCandidates = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = hasSnowTile && tile.base === snowTileKey;
        const baseIsMarsh = hasMarshTile && tile.base === marshTileKey;
        if (baseIsSnow) {
          continue;
        }
        if (!baseIsGrass && !baseIsMarsh) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        const distanceToTownSq = computeNearestDistanceSq(x, y, towns);
        const distanceToHoldSq = computeNearestDistanceSq(x, y, dwarvenSettlements);
        const settlementDistanceSq = Math.min(distanceToTownSq, distanceToHoldSq);
        if (settlementDistanceSq === Infinity) {
          continue;
        }
        const settlementDistance = Math.sqrt(settlementDistanceSq);
        if (settlementDistance < 4 || settlementDistance > 46) {
          continue;
        }
        const distanceToOrcsSq = computeNearestDistanceSq(x, y, hostileWarCamps);
        if (distanceToOrcsSq < 49) {
          continue;
        }
        const distanceToCentaurSq = computeNearestDistanceSq(x, y, centaurEncampments);
        if (distanceToCentaurSq < 64) {
          continue;
        }
        let riverAdjacency = 0;
        for (let i = 0; i < cardinalOffsets.length; i += 1) {
          const nx = x + cardinalOffsets[i][0];
          const ny = y + cardinalOffsets[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const neighborTile = tiles[ny][nx];
          if (neighborTile && neighborTile.river) {
            riverAdjacency += 1;
          }
        }
        const hillBonus =
          isHillOverlayForStructures(tile.overlay) || isHillOverlayForStructures(tile.hillOverlay) ? 0.18 : 0;
        const riverScore = riverAdjacency > 0 ? clamp(0.18 + riverAdjacency * 0.08, 0, 0.3) : 0;
        const noise = hashCoords(x, y, monasteryNoiseSeed) - 0.5;
        const distanceScore = clamp((settlementDistance - 4) / 18, 0, 1) * 0.22;
        const elevationValue = elevationField[idx];
        const elevationScore = clamp((elevationValue - seaLevel) * 2, 0, 1) * 0.18;
        const baseSuitability = baseIsGrass ? 0.18 : baseIsMarsh ? 0.08 : 0;
        const latitude = (y + 0.5) / height;
        const latitudeNoise =
          hashCoords(x, Math.floor(latitude * 1024), monasteryLatitudeSeed) - 0.5;
        const latitudeWave = Math.sin((latitude + latitudeNoise * 0.35) * Math.PI * 2);
        const latitudeScore = Math.abs(latitudeWave) * 0.14;
        const score =
          0.28 +
          hillBonus +
          riverScore +
          distanceScore +
          elevationScore +
          baseSuitability +
          latitudeScore +
          noise * 0.2 +
          rng() * 0.12;
        monasteryCandidates.push({ x, y, score });
      }
    }

    if (monasteryCandidates.length > 0) {
      monasteryCandidates.sort((a, b) => b.score - a.score);
      const baseTarget = Math.max(1, Math.round(mapArea / 24000));
      const maxMonasteries = computeStructurePlacementLimit(baseTarget, 12, 1);
      const minDistance = 11;
      const minDistanceSq = minDistance * minDistance;
      const placed = [];

      for (let i = 0; i < monasteryCandidates.length; i += 1) {
        if (placed.length >= maxMonasteries) {
          break;
        }
        const candidate = monasteryCandidates[i];
        if (candidate.score < 0.32) {
          continue;
        }
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < minDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (tooClose) {
          continue;
        }
        const tile = tiles[candidate.y][candidate.x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = hasSnowTile && tile.base === snowTileKey;
        const baseIsMarsh = hasMarshTile && tile.base === marshTileKey;
        if (baseIsSnow) {
          continue;
        }
        if (!baseIsGrass && !baseIsMarsh) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        const name = generateMonasteryName(rng);
        const details = generateMonasteryDetails(name, rng);
        tile.structure = monasteryKey;
        tile.structureName = name;
        tile.structureDetails = details;
        placed.push(candidate);
        monasteries.push({ x: candidate.x, y: candidate.y, ...details });
      }
    }
  }

  const castleKey = tileLookup.has('CASTLE') ? 'CASTLE' : null;
  if (castleKey) {
    const castleCandidates = [];
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (isTreeOverlayKey(tile.overlay)) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = tile.base === snowTileKey;
        if (!baseIsGrass && !baseIsSnow) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        const hillBonus =
          isHillOverlayForStructures(tile.overlay) || isHillOverlayForStructures(tile.hillOverlay) ? 0.24 : 0;
        const distanceToTownSq = computeNearestDistanceSq(x, y, towns);
        const distanceToHoldSq = computeNearestDistanceSq(x, y, dwarvenSettlements);
        const settlementDistanceSq = Math.min(distanceToTownSq, distanceToHoldSq);
        if (settlementDistanceSq === Infinity) {
          continue;
        }
        const settlementDistance = Math.sqrt(settlementDistanceSq);
        if (settlementDistance < 6) {
          continue;
        }
        const edgeDistance = Math.min(x, width - 1 - x, y, height - 1 - y);
        const edgeScore = clamp(edgeDistance / Math.max(8, Math.min(width, height) / 2.6), 0, 1) * 0.18;
        const heightValue = elevationField[idx];
        let slopeSum = 0;
        let neighborCount = 0;
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            continue;
          }
          slopeSum += Math.abs(heightValue - elevationField[nIdx]);
          neighborCount += 1;
        }
        const averageSlope = neighborCount > 0 ? slopeSum / neighborCount : 0;
        const slopeScore = clamp(averageSlope * 42, 0, 0.35);
        const settlementScore = clamp((settlementDistance - 6) / 20, 0, 1) * 0.28;
        const noise = hashCoords(x, y, castleNoiseSeed) - 0.5;
        const score = hillBonus + edgeScore + slopeScore + settlementScore + noise * 0.22 + rng() * 0.12;
        if (score > 0.32) {
          castleCandidates.push({ x, y, score });
        }
      }
    }

    if (castleCandidates.length > 0) {
      castleCandidates.sort((a, b) => b.score - a.score);
      const baseTarget = Math.max(1, Math.round(mapArea / 26000));
      const maxCastles = computeStructurePlacementLimit(baseTarget, 10, 1);
      const minDistance = 12;
      const minDistanceSq = minDistance * minDistance;
      const placed = [];

      for (let i = 0; i < castleCandidates.length; i += 1) {
        if (placed.length >= maxCastles) {
          break;
        }
        const candidate = castleCandidates[i];
        if (candidate.score < 0.34) {
          continue;
        }
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < minDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (tooClose) {
          continue;
        }
        const tile = tiles[candidate.y][candidate.x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        if (isTreeOverlayKey(tile.overlay)) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = tile.base === snowTileKey;
        if (!baseIsGrass && !baseIsSnow) {
          continue;
        }
        const name = generateCastleName(rng);
        const details = generateCastleDetails(name, rng);
        tile.structure = castleKey;
        tile.structureName = name;
        tile.structureDetails = details;
        placed.push(candidate);
        castles.push({ x: candidate.x, y: candidate.y, ...details });
      }
    }
  }

  const saintShrineKey = tileLookup.has('SAINT_SHRINE') ? 'SAINT_SHRINE' : null;
  if (saintShrineKey) {
    const shrineCandidates = [];
    const monasteryPoints = monasteries.slice();
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (waterMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = tile.base === snowTileKey;
        const baseIsMarsh = tile.base === marshTileKey;
        if (!baseIsGrass && !baseIsSnow && !baseIsMarsh) {
          continue;
        }
        if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
          continue;
        }
        const distanceToMonasterySq = computeNearestDistanceSq(x, y, monasteryPoints);
        if (distanceToMonasterySq === Infinity || distanceToMonasterySq < 25 || distanceToMonasterySq > 1600) {
          continue;
        }
        const distanceToSettlementSq = computeNearestDistanceSq(x, y, majorSettlementPoints);
        if (distanceToSettlementSq < 25) {
          continue;
        }
        let waterAdjacency = 0;
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (waterMask[nIdx]) {
            waterAdjacency += 1;
          } else {
            const neighborTile = tiles[ny][nx];
            if (neighborTile && neighborTile.river) {
              waterAdjacency += 1;
            }
          }
        }
        if (waterAdjacency === 0) {
          continue;
        }
        const moisture = clamp(rainfallField[idx] * 0.6 + (1 - drainageField[idx]) * 0.4, 0, 1);
        const moistureScore = clamp(moisture * 0.4, 0, 0.28);
        const hillBonus =
          isHillOverlayForStructures(tile.overlay) || isHillOverlayForStructures(tile.hillOverlay) ? 0.12 : 0;
        const monasteryDistance = Math.sqrt(distanceToMonasterySq);
        const devotionScore = clamp((monasteryDistance - 5) / 18, 0, 1) * 0.22;
        const noise = hashCoords(x, y, shrineNoiseSeed) - 0.5;
        const baseSuitability = baseIsGrass ? 0.16 : baseIsSnow ? 0.12 : 0.1;
        const latitude = (y + 0.5) / height;
        const latitudeNoise =
          hashCoords(x, Math.floor(latitude * 1024), shrineLatitudeSeed) - 0.5;
        const latitudeWave = Math.sin((latitude + latitudeNoise * 0.3) * Math.PI * 2);
        const latitudeScore = Math.abs(latitudeWave) * 0.12;
        const score =
          0.25 +
          moistureScore +
          hillBonus +
          devotionScore +
          waterAdjacency * 0.05 +
          baseSuitability +
          latitudeScore +
          noise * 0.22 +
          rng() * 0.12;
        shrineCandidates.push({ x, y, score });
      }
    }

    if (shrineCandidates.length > 0) {
      shrineCandidates.sort((a, b) => b.score - a.score);
      const baseTarget = Math.max(1, Math.round(mapArea / 24000));
      const maxShrines = computeStructurePlacementLimit(baseTarget, 14, 1);
      const minDistance = 9;
      const minDistanceSq = minDistance * minDistance;
      const placed = [];

      for (let i = 0; i < shrineCandidates.length; i += 1) {
        if (placed.length >= maxShrines) {
          break;
        }
        const candidate = shrineCandidates[i];
        if (candidate.score < 0.3) {
          continue;
        }
        let tooClose = false;
        for (let j = 0; j < placed.length; j += 1) {
          const other = placed[j];
          const dx = candidate.x - other.x;
          const dy = candidate.y - other.y;
          if (dx * dx + dy * dy < minDistanceSq) {
            tooClose = true;
            break;
          }
        }
        if (tooClose) {
          continue;
        }
        const tile = tiles[candidate.y][candidate.x];
        if (!tile || tile.structure || tile.river) {
          continue;
        }
        const baseIsGrass = tile.base === grassTileKey;
        const baseIsSnow = tile.base === snowTileKey;
        const baseIsMarsh = tile.base === marshTileKey;
        if (!baseIsGrass && !baseIsSnow && !baseIsMarsh) {
          continue;
        }
        const name = generateSaintShrineName(rng);
        const details = generateSaintShrineDetails(name, rng);
        tile.structure = saintShrineKey;
        tile.structureName = name;
        tile.structureDetails = details;
        placed.push(candidate);
        saintShrines.push({ x: candidate.x, y: candidate.y, ...details });
      }
    }
  }

  if (
    mountainOverlayKey &&
    mountainMask &&
    (mountainTopVariantKeys.length > 0 || mountainBottomVariantKeys.length > 0)
  ) {
    const selectVariant = (keys, x, y) => {
      if (!keys || keys.length === 0) {
        return null;
      }
      const hash = ((x + 1) * 73856093) ^ ((y + 1) * 19349663);
      const index = Math.abs(hash) % keys.length;
      return keys[index];
    };

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (!mountainMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile || !isMountainOverlay(tile.overlay)) {
          continue;
        }
        if (isVolcanoOverlayKey(tile.overlay)) {
          continue;
        }
        if (mountainPeakKey && tile.overlay === mountainPeakKey) {
          continue;
        }
        const normalizedHeight = mountainHeightField ? mountainHeightField[idx] : 0;
        if (mountainPeakKey && normalizedHeight >= mountainPeakHeightThreshold) {
          tile.overlay = mountainPeakKey;
          continue;
        }
        const hasMountainAbove = y > 0 && mountainMask[(y - 1) * width + x];
        const hasMountainBelow = y < height - 1 && mountainMask[(y + 1) * width + x];
        if (!hasMountainAbove && hasMountainBelow) {
          const variant = selectVariant(mountainTopVariantKeys, x, y);
          if (variant) {
            tile.overlay = variant;
            continue;
          }
        }
        if (!hasMountainBelow && hasMountainAbove) {
          const variant = selectVariant(mountainBottomVariantKeys, x, y);
          if (variant) {
            tile.overlay = variant;
            continue;
          }
        }
        tile.overlay = mountainOverlayKey;
      }
    }
  }

  const treeProximityRadius = 3;
  const hasTreeWithinRadius = (x, y, radius = treeProximityRadius) => {
    const clampedRadius = Math.max(0, Math.floor(radius));
    for (let dy = -clampedRadius; dy <= clampedRadius; dy += 1) {
      const ny = y + dy;
      if (ny < 0 || ny >= height) {
        continue;
      }
      for (let dx = -clampedRadius; dx <= clampedRadius; dx += 1) {
        const nx = x + dx;
        if (nx < 0 || nx >= width) {
          continue;
        }
        const neighborTile = tiles[ny][nx];
        if (tileHasTreeOverlay(neighborTile)) {
          return true;
        }
      }
    }
    return false;
  };

  const biomeRandom = mulberry32((seedNumber + 0x4c95e6d9) >>> 0);
  const temperatureNoiseSeed = (seedNumber + 0x52f6af13) >>> 0;
  const temperatureNoiseScale = 2.7 + biomeRandom() * 1.8;
  const temperatureNoiseOffsetX = biomeRandom() * 8192;
  const temperatureNoiseOffsetY = biomeRandom() * 8192;
  const moistureNoiseSeed = (seedNumber + 0x6a4b5c27) >>> 0;
  const moistureNoiseScale = 3.1 + biomeRandom() * 2.3;
  const moistureNoiseOffsetX = biomeRandom() * 8192;
  const moistureNoiseOffsetY = biomeRandom() * 8192;
  const temperatureField = new Float32Array(width * height);
  const moistureField = new Float32Array(width * height);

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      const normalizedX = (x + 0.5) / width;
      const normalizedY = (y + 0.5) / height;
      const tile = tiles[y][x];
      const latitudeFactor = 1 - Math.abs(normalizedY - 0.5) * 2;
      const elevationValue = elevationField[idx];
      const elevationAboveSea = Math.max(elevationValue - seaLevel, 0);
      const elevationCooling = clamp(1 - elevationAboveSea * 3.5, 0, 1);
      const temperatureNoise = octaveNoise(
        (normalizedX + temperatureNoiseOffsetX) * temperatureNoiseScale,
        (normalizedY + temperatureNoiseOffsetY) * temperatureNoiseScale,
        temperatureNoiseSeed,
        3,
        0.55,
        2.1
      );
      const baseTemperature = clamp(latitudeFactor * 0.75 + elevationCooling * 0.25, 0, 1);
      temperatureField[idx] = clamp(baseTemperature + (temperatureNoise - 0.5) * 0.18, 0, 1);

      const rainfallValue = rainfallField[idx];
      const drainageValue = drainageField[idx];
      const baseMoisture = clamp(rainfallValue * 0.7 + (1 - drainageValue) * 0.3, 0, 1);
      const moistureNoise = octaveNoise(
        (normalizedX + moistureNoiseOffsetX) * moistureNoiseScale,
        (normalizedY + moistureNoiseOffsetY) * moistureNoiseScale,
        moistureNoiseSeed,
        3,
        0.55,
        2.2
      );
      moistureField[idx] = clamp(baseMoisture + (moistureNoise - 0.5) * 0.14, 0, 1);
      if (tile) {
        tile.temperature = temperatureField[idx];
        tile.moisture = moistureField[idx];
      }
    }
  }

  const initialBiomeField = new Array(width * height);

  const computeInitialBiome = (tile, idx, x, y) => {
    if (!tile) {
      return waterMask[idx] ? 'water' : null;
    }
    if (waterMask[idx] || tile.base === waterTileKey) {
      return 'water';
    }
    if (tileHasTownSettlement(tile)) {
      return 'grassland';
    }
    if (mountainOverlayKey && isMountainOverlay(tile.overlay)) {
      return 'mountain';
    }
    if (hasMarshTile && tile.base === marshTileKey) {
      return 'marsh';
    }
    if (hasBadlandsTile && tile.base === badlandsTileKey) {
      return 'badlands';
    }
    if (hasSandTile && tile.base === sandTileKey) {
      return 'desert';
    }
    if (hasSnowTile && tile.base === snowTileKey) {
      if (tileHasTreeOverlay(tile)) {
        return temperatureField[idx] > 0.35 ? 'forest' : 'tundra';
      }
      return 'tundra';
    }
    if (tileHasJungleOverlay(tile)) {
      if (temperatureField[idx] > 0.38 && moistureField[idx] > 0.55) {
        return 'jungle';
      }
      return temperatureField[idx] < 0.22 ? 'tundra' : 'forest';
    }
    if (tileHasTreeOverlay(tile)) {
      return temperatureField[idx] < 0.22 ? 'tundra' : 'forest';
    }

    const temperature = temperatureField[idx];
    const moisture = moistureField[idx];
    const dryness = 1 - moisture;
    const relativeElevation = elevationField[idx] - seaLevel;

    let nearbyWaterTiles = 0;
    for (let i = 0; i < neighborOffsets8.length; i += 1) {
      const nx = x + neighborOffsets8[i][0];
      const ny = y + neighborOffsets8[i][1];
      if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
        continue;
      }
      const nIdx = ny * width + nx;
      if (waterMask[nIdx]) {
        nearbyWaterTiles += 1;
      }
    }

    if (moisture > 0.78 && (relativeElevation < 0.06 || nearbyWaterTiles >= 3)) {
      return 'marsh';
    }
    if (temperature < 0.2) {
      return 'tundra';
    }
    if (dryness > 0.64 && temperature > 0.32) {
      return 'desert';
    }
    if (dryness > 0.52 && temperature > 0.35) {
      return 'badlands';
    }
    if (moisture > 0.62 || (moisture > 0.52 && nearbyWaterTiles >= 2)) {
      return hasTreeWithinRadius(x, y) ? 'forest' : 'grassland';
    }
    if (moisture > 0.5 && temperature > 0.55) {
      return hasTreeWithinRadius(x, y) ? 'forest' : 'grassland';
    }
    return 'grassland';
  };

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      const tile = tiles[y][x];
      const biomeType = computeInitialBiome(tile, idx, x, y);
      initialBiomeField[idx] = biomeType;
      if (tile) {
        tile.biomeType = null;
        tile.biomeClusterId = null;
        tile.areaName = null;
      }
    }
  }

  let biomeField = initialBiomeField.slice();
  let biomeBuffer = new Array(width * height);
  const biomeSmoothingIterations = 2;

  for (let iteration = 0; iteration < biomeSmoothingIterations; iteration += 1) {
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const currentType = biomeField[idx];
        biomeBuffer[idx] = currentType;
        const tile = tiles[y][x];
        if (tileHasTownSettlement(tile)) {
          continue;
        }
        if (!currentType || currentType === 'water' || currentType === 'mountain') {
          continue;
        }
        const neighborCounts = new Map();
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = x + neighborOffsets8[i][0];
          const ny = y + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const neighborType = biomeField[ny * width + nx];
          if (!neighborType || neighborType === 'water') {
            continue;
          }
          neighborCounts.set(neighborType, (neighborCounts.get(neighborType) || 0) + 1);
        }
        let bestType = currentType;
        let bestCount = 0;
        neighborCounts.forEach((count, type) => {
          if (count > bestCount || (count === bestCount && type === currentType)) {
            bestType = type;
            bestCount = count;
          }
        });
        if (bestType === currentType) {
          continue;
        }
        const bestIsMarsh = bestType === 'marsh';
        const currentIsMarsh = currentType === 'marsh';
        if (currentIsMarsh) {
          const marshSupport = neighborCounts.get('marsh') || 0;
          if (marshSupport >= 2 && bestCount < 6) {
            continue;
          }
        }
        const requiredNeighbors = bestIsMarsh ? 4 : 5;
        if (bestCount >= requiredNeighbors) {
          biomeBuffer[idx] = bestType;
        }
      }
    }
    const swap = biomeField;
    biomeField = biomeBuffer;
    biomeBuffer = swap;
  }

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      if (biomeField[idx] !== 'forest') {
        continue;
      }
      if (!hasTreeWithinRadius(x, y)) {
        biomeField[idx] = 'grassland';
      }
    }
  }

  const biomeVisited = new Uint8Array(width * height);
  const biomeClusters = [];
  const clusterIndexMap = new Int32Array(width * height);
  clusterIndexMap.fill(-1);

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      if (biomeVisited[idx]) {
        continue;
      }
      const baseBiome = biomeField[idx];
      const tile = tiles[y][x];
      if (!baseBiome) {
        biomeVisited[idx] = 1;
        if (tile) {
          tile.biomeType = null;
          tile.biomeClusterId = null;
          tile.areaName = null;
        }
        continue;
      }
      const stack = [idx];
      biomeVisited[idx] = 1;
      const members = [];
      let touchesEdge = x === 0 || y === 0 || x === width - 1 || y === height - 1;
      while (stack.length > 0) {
        const current = stack.pop();
        const cx = current % width;
        const cy = Math.floor(current / width);
        members.push(current);
        if (cx === 0 || cy === 0 || cx === width - 1 || cy === height - 1) {
          touchesEdge = true;
        }
        for (let i = 0; i < neighborOffsets8.length; i += 1) {
          const nx = cx + neighborOffsets8[i][0];
          const ny = cy + neighborOffsets8[i][1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          const nIdx = ny * width + nx;
          if (biomeVisited[nIdx]) {
            continue;
          }
          const neighborBiome = biomeField[nIdx];
          if (neighborBiome === baseBiome) {
            biomeVisited[nIdx] = 1;
            stack.push(nIdx);
          }
        }
      }
      const clusterIndex = biomeClusters.length;
      for (let i = 0; i < members.length; i += 1) {
        clusterIndexMap[members[i]] = clusterIndex;
      }
      biomeClusters.push({ type: baseBiome, indices: members, touchesEdge, size: members.length });
    }
  }

  const clusterAdjacency = new Array(biomeClusters.length);
  for (let i = 0; i < clusterAdjacency.length; i += 1) {
    clusterAdjacency[i] = new Set();
  }

  for (let i = 0; i < biomeClusters.length; i += 1) {
    const cluster = biomeClusters[i];
    for (let j = 0; j < cluster.indices.length; j += 1) {
      const clusterIdx = cluster.indices[j];
      const cx = clusterIdx % width;
      const cy = Math.floor(clusterIdx / width);
      for (let k = 0; k < cardinalOffsets.length; k += 1) {
        const nx = cx + cardinalOffsets[k][0];
        const ny = cy + cardinalOffsets[k][1];
        if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
          continue;
        }
        const neighborClusterIndex = clusterIndexMap[ny * width + nx];
        if (neighborClusterIndex === -1 || neighborClusterIndex === i) {
          continue;
        }
        clusterAdjacency[i].add(neighborClusterIndex);
        clusterAdjacency[neighborClusterIndex].add(i);
      }
    }
  }

  for (let i = 0; i < biomeClusters.length; i += 1) {
    const cluster = biomeClusters[i];
    if (cluster.type !== 'grassland') {
      continue;
    }
    let hasDesertNeighbor = false;
    let hasBlockingNeighbor = false;
    for (let j = 0; j < cluster.indices.length && !hasBlockingNeighbor; j += 1) {
      const clusterIdx = cluster.indices[j];
      const cx = clusterIdx % width;
      const cy = Math.floor(clusterIdx / width);
      for (let k = 0; k < neighborOffsets8.length; k += 1) {
        const nx = cx + neighborOffsets8[k][0];
        const ny = cy + neighborOffsets8[k][1];
        if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
          continue;
        }
        const neighborType = biomeField[ny * width + nx];
        if (!neighborType || neighborType === 'grassland') {
          continue;
        }
        if (neighborType === 'desert') {
          hasDesertNeighbor = true;
        } else {
          hasBlockingNeighbor = true;
          break;
        }
      }
    }
    if (hasDesertNeighbor && !hasBlockingNeighbor) {
      cluster.type = 'desert';
      for (let j = 0; j < cluster.indices.length; j += 1) {
        const clusterIdx = cluster.indices[j];
        biomeField[clusterIdx] = 'desert';
      }
    }
  }

  const reachableNonBadlands = new Uint8Array(biomeClusters.length);
  const queue = [];
  for (let i = 0; i < biomeClusters.length; i += 1) {
    const cluster = biomeClusters[i];
    if (cluster.type === 'badlands') {
      continue;
    }
    if (cluster.touchesEdge) {
      reachableNonBadlands[i] = 1;
      queue.push(i);
    }
  }

  let queueIndex = 0;
  while (queueIndex < queue.length) {
    const current = queue[queueIndex];
    queueIndex += 1;
    const neighbors = clusterAdjacency[current];
    neighbors.forEach((neighbor) => {
      if (reachableNonBadlands[neighbor]) {
        return;
      }
      const neighborCluster = biomeClusters[neighbor];
      if (neighborCluster.type === 'badlands') {
        return;
      }
      reachableNonBadlands[neighbor] = 1;
      queue.push(neighbor);
    });
  }

  for (let i = 0; i < biomeClusters.length; i += 1) {
    const cluster = biomeClusters[i];
    if (cluster.type === 'badlands' || cluster.type === 'water' || cluster.type === 'mountain') {
      continue;
    }
    if (reachableNonBadlands[i]) {
      continue;
    }
    cluster.type = 'badlands';
    for (let j = 0; j < cluster.indices.length; j += 1) {
      const clusterIdx = cluster.indices[j];
      biomeField[clusterIdx] = 'badlands';
    }
  }

  const convertBadlandsClusterToNeighbor = (clusterIndex) => {
    const cluster = biomeClusters[clusterIndex];
    if (!cluster || cluster.type !== 'badlands') {
      return;
    }
    const neighborCounts = new Map();
    clusterAdjacency[clusterIndex].forEach((neighborIndex) => {
      const neighborCluster = biomeClusters[neighborIndex];
      if (!neighborCluster) {
        return;
      }
      const neighborType = neighborCluster.type;
      if (!neighborType || neighborType === 'badlands') {
        return;
      }
      neighborCounts.set(neighborType, (neighborCounts.get(neighborType) || 0) + 1);
    });
    let replacementType = null;
    let replacementCount = -1;
    neighborCounts.forEach((count, type) => {
      if (count > replacementCount) {
        replacementType = type;
        replacementCount = count;
      }
    });
    if (!replacementType) {
      replacementType = 'grassland';
    }
    cluster.type = replacementType;
    for (let j = 0; j < cluster.indices.length; j += 1) {
      const clusterIdx = cluster.indices[j];
      biomeField[clusterIdx] = replacementType;
    }
  };

  const badlandsMinimumSize = 10;
  for (let i = 0; i < biomeClusters.length; i += 1) {
    const cluster = biomeClusters[i];
    if (cluster.type !== 'badlands' || cluster.size >= badlandsMinimumSize) {
      continue;
    }
    const neighborCounts = new Map();
    clusterAdjacency[i].forEach((neighborIndex) => {
      const neighborCluster = biomeClusters[neighborIndex];
      if (!neighborCluster) {
        return;
      }
      const neighborType = neighborCluster.type;
      if (!neighborType || neighborType === 'badlands') {
        return;
      }
      neighborCounts.set(neighborType, (neighborCounts.get(neighborType) || 0) + 1);
    });
    if (!neighborCounts.size) {
      continue;
    }
    let replacementType = null;
    let replacementCount = -1;
    neighborCounts.forEach((count, type) => {
      if (count > replacementCount) {
        replacementType = type;
        replacementCount = count;
      }
    });
    if (!replacementType) {
      continue;
    }
    cluster.type = replacementType;
    for (let j = 0; j < cluster.indices.length; j += 1) {
      const clusterIdx = cluster.indices[j];
      biomeField[clusterIdx] = replacementType;
    }
  }

  const badlandsClusterIndices = [];
  for (let i = 0; i < biomeClusters.length; i += 1) {
    if (biomeClusters[i].type === 'badlands') {
      badlandsClusterIndices.push(i);
    }
  }
  badlandsClusterIndices.sort((a, b) => biomeClusters[b].size - biomeClusters[a].size);

  const reservedBadlandsClusters = new Set();
  for (let i = 0; i < badlandsClusterIndices.length; i += 1) {
    const clusterIndex = badlandsClusterIndices[i];
    const cluster = biomeClusters[clusterIndex];
    if (!cluster || cluster.type !== 'badlands') {
      continue;
    }
    let conflictsWithReserved = false;
    clusterAdjacency[clusterIndex].forEach((neighborIndex) => {
      if (reservedBadlandsClusters.has(neighborIndex)) {
        conflictsWithReserved = true;
      }
    });
    if (conflictsWithReserved) {
      convertBadlandsClusterToNeighbor(clusterIndex);
      continue;
    }
    reservedBadlandsClusters.add(clusterIndex);
  }

  const oceanSizeThreshold = Math.max(80, Math.round((width * height) / 80));

  for (let i = 0; i < biomeClusters.length; i += 1) {
    const cluster = biomeClusters[i];
    let resolvedType = cluster.type;
    if (resolvedType === 'water') {
      const qualifiesAsOcean = cluster.touchesEdge || cluster.size >= oceanSizeThreshold;
      resolvedType = qualifiesAsOcean ? 'ocean' : 'lake';
    }
    const definition = biomeTypeDefinitions[resolvedType] || null;
    const context = { size: cluster.size, touchesEdge: cluster.touchesEdge };
    const generatedName = generateBiomeAreaName(resolvedType, rng, context);
    const fallbackLabel = definition ? definition.label : null;
    const resolvedName = generatedName || (fallbackLabel ? `Unnamed ${fallbackLabel}` : null);
    for (let j = 0; j < cluster.indices.length; j += 1) {
      const clusterIdx = cluster.indices[j];
      const cx = clusterIdx % width;
      const cy = Math.floor(clusterIdx / width);
      const clusterTile = tiles[cy][cx];
      if (!clusterTile) {
        continue;
      }
      if (resolvedType === 'ocean' && oceanMask) {
        oceanMask[clusterIdx] = 1;
      }
      clusterTile.biomeType = resolvedType;
      clusterTile.biomeClusterId = i;
      clusterTile.areaName = resolvedName;
      if (hasBadlandsTile && resolvedType === 'badlands') {
        const isWaterTile =
          (waterMask && waterMask[clusterIdx]) || clusterTile.base === waterTileKey;
        if (!isWaterTile) {
          clusterTile.base = badlandsTileKey;
          if (badlandsMask) {
            badlandsMask[clusterIdx] = 1;
          }
          if (desertMask) {
            desertMask[clusterIdx] = 1;
          }
        } else {
          if (badlandsMask) {
            badlandsMask[clusterIdx] = 0;
          }
          if (desertMask) {
            desertMask[clusterIdx] = 0;
          }
        }
      }
    }
  }

  if (oceanMask) {
    let hasOcean = false;
    for (let i = 0; i < oceanMask.length; i += 1) {
      if (oceanMask[i]) {
        hasOcean = true;
        break;
      }
    }
    if (hasOcean) {
      const oceanDistanceField = computeEuclideanDistanceField(oceanMask, width, height);
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          const tile = tiles[y][x];
          if (!tile) {
            continue;
          }
          if (waterMask[idx]) {
            tile.coastProximity = 0;
            tile.marshProximity = 0;
            continue;
          }
          const distanceToOcean = Math.sqrt(oceanDistanceField[idx]);
          const proximity = clamp(1 - distanceToOcean / coastlineFalloff, 0, 1);
          tile.coastProximity = proximity;
        }
      }
    } else {
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (waterMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          if (tile) {
            tile.coastProximity = 0;
          }
        }
      }
    }
  }

  const forestMask = new Uint8Array(width * height);
  let forestTileCount = 0;
  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      const tile = tiles[y][x];
      if (!tile) {
        continue;
      }
      if (tile.base === grassTileKey && tile.biomeType === 'forest') {
        forestMask[idx] = 1;
        forestTileCount += 1;
      } else {
        tile.forestCanopyDensity = 0;
      }
    }
  }

  if (forestTileCount > 0) {
    const nonForestMask = new Uint8Array(width * height);
    for (let i = 0; i < nonForestMask.length; i += 1) {
      nonForestMask[i] = forestMask[i] ? 0 : 1;
    }
    const forestEdgeDistanceField = computeEuclideanDistanceField(
      nonForestMask,
      width,
      height
    );
    const forestShadeFalloff = 4.2;
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        if (!forestMask[idx]) {
          continue;
        }
        const tile = tiles[y][x];
        if (!tile) {
          continue;
        }
        const distanceToEdge = Math.sqrt(forestEdgeDistanceField[idx]);
        const density = clamp(distanceToEdge / forestShadeFalloff, 0, 1);
        tile.forestCanopyDensity = density;
      }
    }
  }

  if (volcanoOverlayKeys.length > 0) {
    const volcanoMask = new Uint8Array(width * height);
    let hasVolcanoTile = false;
    const volcanoEligibleBases = new Set(
      [grassTileKey, stoneTileKey, sandTileKey, snowTileKey, lavaTileKey].filter(
        (key) => typeof key === 'string'
      )
    );
    const volcanoStoneConversionThreshold = 0.45;

    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = y * width + x;
        const tile = tiles[y][x];
        if (!tile) {
          continue;
        }
        if (isVolcanoOverlayKey(tile.overlay)) {
          volcanoMask[idx] = 1;
          hasVolcanoTile = true;
          tile.volcanoProximity = 1;
          maybeConvertBaseToStoneNearVolcano(tile, x, y, 1);
        } else if (!volcanoEligibleBases.has(tile.base) || waterMask[idx]) {
          tile.volcanoProximity = 0;
        }
      }
    }

    if (hasVolcanoTile) {
      const volcanoDistanceField = computeEuclideanDistanceField(volcanoMask, width, height);
      const volcanoStoneConversionFalloff = 6.4;
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const idx = y * width + x;
          if (volcanoMask[idx]) {
            continue;
          }
          const tile = tiles[y][x];
          if (!tile || !volcanoEligibleBases.has(tile.base) || waterMask[idx]) {
            if (tile) {
              tile.volcanoProximity = 0;
            }
            continue;
          }
          const distanceToVolcano = Math.sqrt(volcanoDistanceField[idx]);
          const proximity = clamp(
            1 - distanceToVolcano / volcanoStoneConversionFalloff,
            0,
            1
          );
          tile.volcanoProximity = proximity;
          if (proximity >= volcanoStoneConversionThreshold) {
            maybeConvertBaseToStoneNearVolcano(tile, x, y, proximity);
          }
        }
      }
    } else {
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const tile = tiles[y][x];
          if (tile) {
            tile.volcanoProximity = 0;
          }
        }
      }
    }
  } else {
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const tile = tiles[y][x];
        if (tile) {
          tile.volcanoProximity = 0;
        }
      }
    }
  }

  const finalSeed = seedString && seedString.trim().length ? seedString.trim() : generateSeedString(seedNumber);
  const settlementSeeds = [
    ...dwarfholds.map((hold) => ({
      x: hold.x,
      y: hold.y,
      label: hold.name || hold.structureName || 'Hold',
      type: 'dwarfhold',
      population: Number.isFinite(hold?.population) ? hold.population : null,
      settlementKind: typeof hold?.type === 'string' ? hold.type : null
    })),
    ...hillholds.map((hold) => ({
      x: hold.x,
      y: hold.y,
      label: hold.name || hold.structureName || 'Hillhold',
      type: 'hillhold',
      population: Number.isFinite(hold?.population) ? hold.population : null,
      settlementKind: typeof hold?.type === 'string' ? hold.type : null
    })),
    ...towns.map((town) => ({
      x: town.x,
      y: town.y,
      label: town.name || town.structureName || 'Town',
      type: 'town',
      population: Number.isFinite(town?.population) ? town.population : null,
      settlementKind: typeof town?.type === 'string' ? town.type : null
    })),
    ...towers.map((tower) => ({
      x: tower.x,
      y: tower.y,
      label: tower.name || tower.structureName || 'Tower',
      type: 'tower',
      population: Number.isFinite(tower?.population) ? tower.population : null,
      settlementKind: typeof tower?.type === 'string' ? tower.type : null
    })),
    ...evilWizardTowers.map((tower) => ({
      x: tower.x,
      y: tower.y,
      label: tower.name || tower.structureName || "Wizard's Tower",
      type: 'evilWizardTower',
      population: Number.isFinite(tower?.population) ? tower.population : null,
      settlementKind: typeof tower?.type === 'string' ? tower.type : null
    })),
    ...lizardmenCities.map((city) => ({
      x: city.x,
      y: city.y,
      label: city.name || 'Temple City',
      type: 'lizardmenCity',
      population: Number.isFinite(city?.population) ? city.population : null,
      settlementKind: typeof city?.type === 'string' ? city.type : null
    })),
    ...woodElfGroves.map((grove) => ({
      x: grove.x,
      y: grove.y,
      label: grove.name || grove.structureName || 'Grove',
      type: 'woodElfGrove',
      population: Number.isFinite(grove?.population) ? grove.population : null,
      settlementKind: typeof grove?.type === 'string' ? grove.type : null
    })),
    ...monasteries.map((monastery) => ({
      x: monastery.x,
      y: monastery.y,
      label: monastery.name || monastery.structureName || 'Monastery',
      type: 'monastery',
      population: Number.isFinite(monastery?.population) ? monastery.population : null,
      settlementKind: typeof monastery?.type === 'string' ? monastery.type : null
    })),
    ...castles.map((castle) => ({
      x: castle.x,
      y: castle.y,
      label: castle.name || castle.structureName || 'Castle',
      type: 'castle',
      population: Number.isFinite(castle?.garrison) ? castle.garrison : null,
      settlementKind: typeof castle?.type === 'string' ? castle.type : null
    }))
  ];

  const politicalData = generatePoliticalLandscape({
    width,
    height,
    tiles,
    waterMask,
    random: rng,
    settlements: settlementSeeds
  });
  const factions = politicalData.factions || [];

  const woodElfTerritoryInfo = createWoodElfTerritoryInfo({
    tiles,
    width,
    height,
    factions,
    radius: 3
  });

  if (saintShrines.length > 0 && factions.length > 0) {
    const factionById = new Map(factions.map((faction) => [faction.id, faction]));
    const saintShrineAttachmentTypes = new Set(['village', 'town', 'city']);
    const candidateSettlements = [];

    towns.forEach((town) => {
      if (!town || !Number.isFinite(town.x) || !Number.isFinite(town.y)) {
        return;
      }
      const settlementType = typeof town?.type === 'string' ? town.type : null;
      if (settlementType && saintShrineAttachmentTypes.has(settlementType)) {
        candidateSettlements.push(town);
      }
    });

    castles.forEach((castle) => {
      if (!castle || !Number.isFinite(castle.x) || !Number.isFinite(castle.y)) {
        return;
      }
      candidateSettlements.push(castle);
    });

    if (candidateSettlements.length > 0) {
      const saintShrineAttachmentRadius = 12;
      const saintShrineAttachmentRadiusSq = saintShrineAttachmentRadius * saintShrineAttachmentRadius;

      const findNearestCandidate = (x, y) => {
        let best = null;
        let bestDistanceSq = Infinity;
        for (let i = 0; i < candidateSettlements.length; i += 1) {
          const candidate = candidateSettlements[i];
          const dx = x - candidate.x;
          const dy = y - candidate.y;
          const distanceSq = dx * dx + dy * dy;
          if (distanceSq < bestDistanceSq && distanceSq <= saintShrineAttachmentRadiusSq) {
            bestDistanceSq = distanceSq;
            best = candidate;
          }
        }
        return best;
      };

      for (let i = 0; i < saintShrines.length; i += 1) {
        const shrine = saintShrines[i];
        if (!shrine || !Number.isFinite(shrine.x) || !Number.isFinite(shrine.y)) {
          continue;
        }
        const nearest = findNearestCandidate(shrine.x, shrine.y);
        if (!nearest) {
          continue;
        }
        const parentRow = tiles[nearest.y];
        const parentTile = parentRow ? parentRow[nearest.x] : null;
        const parentFactionId = parentTile ? parentTile.factionId : null;
        if (parentFactionId === null || parentFactionId === undefined) {
          continue;
        }
        const shrineRow = tiles[shrine.y];
        const shrineTile = shrineRow ? shrineRow[shrine.x] : null;
        if (!shrineTile) {
          continue;
        }
        shrineTile.factionId = parentFactionId;
        shrineTile.factionInfluence = Math.max(shrineTile.factionInfluence || 0, 0.85);
      }

      factions.forEach((faction) => {
        faction.territory = 0;
      });

      for (let y = 0; y < height; y += 1) {
        const row = tiles[y];
        if (!row) {
          continue;
        }
        for (let x = 0; x < width; x += 1) {
          const tile = row[x];
          if (!tile || tile.factionId === null || tile.factionId === undefined) {
            continue;
          }
          const faction = factionById.get(tile.factionId);
          if (faction) {
            faction.territory += 1;
          }
        }
      }
    }
  }

  applyCulturalInfluence({
    width,
    height,
    tiles,
    settlements: [
      ...dwarfholds,
      ...hillholds,
      ...towns,
      ...towers,
      ...evilWizardTowers,
      ...lizardmenCities,
      ...woodElfGroves,
      ...monasteries,
      ...mines,
      ...castles,
      ...orcCamps,
      ...gnollCamps,
      ...trollCamps,
      ...ogreCamps,
      ...banditCamps,
      ...centaurEncampments,
      ...caves,
      ...roadsideTaverns,
      ...saintShrines
    ],
    factions,
    isLandBaseTile,
    seedNumber,
    woodElfTerritoryInfo
  });
  const ambientStructures = spawnAmbientStructures({
    tiles,
    width,
    height,
    grassTileKey,
    seedNumber,
    woodElfTerritoryInfo
  });
  return {
    tiles,
    grassTileKey,
    waterTileKey,
    snowTileKey,
    sandTileKey,
    badlandsTileKey,
    width,
    height,
    seaLevel,
    elevationField,
    temperatureField,
    moistureField,
    biomeField,
    seedString: finalSeed,
    dwarfholds,
    mines,
    hillholds,
    towns,
    towers,
    caves,
    evilWizardTowers,
    lizardmenCities,
    woodElfGroves,
    orcCamps,
    gnollCamps,
    trollCamps,
    ogreCamps,
    banditCamps,
    hostileWarCamps,
    centaurEncampments,
    travelerCamps,
    dungeons,
    monasteries,
    castles,
    saintShrines,
    roadsideTaverns,
    ambientStructures,
    factions
  };
}

function createWorldWithDimensions(seedString, width, height) {
  const originalWidth = state.settings.width;
  const originalHeight = state.settings.height;
  const originalMapSize = state.settings.mapSize;

  const safeWidth = Number.isFinite(width) && width > 0 ? Math.floor(width) : originalWidth;
  const safeHeight = Number.isFinite(height) && height > 0 ? Math.floor(height) : originalHeight;

  state.settings.width = safeWidth;
  state.settings.height = safeHeight;
  state.settings.mapSize = `${safeWidth}x${safeHeight}`;

  try {
    return createWorld(seedString);
  } finally {
    state.settings.width = originalWidth;
    state.settings.height = originalHeight;
    state.settings.mapSize = originalMapSize;
  }
}

function generateSeedString(seedNumber) {
  return seedNumber.toString(16).padStart(8, '0');
}

function drawRiverSegment(ctx, river, x, y, tileSize = drawSize) {
  if (!river) {
    return;
  }
  const definition = tileLookup.get(river.tileKey || river.key);
  if (!definition) {
    return;
  }
  const sheet = state.tileSheets[definition.sheet];
  if (!sheet || !sheet.image) {
    return;
  }
  ctx.drawImage(
    sheet.image,
    definition.sx,
    definition.sy,
    definition.size,
    definition.size,
    x * tileSize,
    y * tileSize,
    tileSize,
    tileSize
  );
}

function computeRoadNeighborMask(x, y, overlayKey = TOWN_ROAD_OVERLAY_KEY, tilesOverride = null) {
  let tiles = null;
  if (Array.isArray(tilesOverride)) {
    tiles = tilesOverride;
  } else {
    const world = state.currentWorld;
    if (!world || !Array.isArray(world.tiles)) {
      return 0;
    }
    tiles = world.tiles;
  }

  const height = tiles.length;
  if (!Number.isFinite(x) || !Number.isFinite(y) || y < 0 || y >= height) {
    return 0;
  }

  const row = tiles[y];
  if (!Array.isArray(row) || x < 0 || x >= row.length) {
    return 0;
  }

  let mask = 0;
  const directions = [
    { bit: ROAD_DIRECTION_BITS.NORTH, dx: 0, dy: -1 },
    { bit: ROAD_DIRECTION_BITS.EAST, dx: 1, dy: 0 },
    { bit: ROAD_DIRECTION_BITS.SOUTH, dx: 0, dy: 1 },
    { bit: ROAD_DIRECTION_BITS.WEST, dx: -1, dy: 0 }
  ];

  for (let i = 0; i < directions.length; i += 1) {
    const { bit, dx, dy } = directions[i];
    const nx = x + dx;
    const ny = y + dy;
    if (ny < 0 || ny >= height) {
      continue;
    }
    const neighborRow = tiles[ny];
    if (!Array.isArray(neighborRow) || nx < 0 || nx >= neighborRow.length) {
      continue;
    }
    const neighbor = neighborRow[nx];
    if (neighbor && neighbor.overlay === overlayKey) {
      mask |= bit;
    }
  }

  return mask;
}

function selectRoadTileSprite(mask) {
  if (!roadTileSpriteDefinitions) {
    return null;
  }

  const { NORTH, EAST, SOUTH, WEST } = ROAD_DIRECTION_BITS;

  if (mask === 0) {
    return { definition: roadTileSpriteDefinitions.isolated, rotation: 0 };
  }

  const singleDirectionRotations = {
    [WEST]: 0,
    [NORTH]: 1,
    [EAST]: 2,
    [SOUTH]: 3
  };
  if (singleDirectionRotations[mask] !== undefined) {
    return {
      definition: roadTileSpriteDefinitions.deadEndWest,
      rotation: singleDirectionRotations[mask]
    };
  }

  if (mask === (EAST | WEST)) {
    return { definition: roadTileSpriteDefinitions.straightEastWest, rotation: 0 };
  }
  if (mask === (NORTH | SOUTH)) {
    return { definition: roadTileSpriteDefinitions.straightEastWest, rotation: 1 };
  }

  const cornerDefinition = {
    [NORTH | EAST]: roadTileSpriteDefinitions.cornerNorthEast,
    [EAST | SOUTH]: roadTileSpriteDefinitions.cornerSouthEast,
    [SOUTH | WEST]: roadTileSpriteDefinitions.cornerSouthWest,
    [WEST | NORTH]: roadTileSpriteDefinitions.cornerNorthWest
  }[mask];
  if (cornerDefinition) {
    return { definition: cornerDefinition, rotation: 0 };
  }

  if (mask === (NORTH | EAST | SOUTH)) {
    return { definition: roadTileSpriteDefinitions.teeMissingWest, rotation: 0 };
  }
  if (mask === (EAST | SOUTH | WEST)) {
    return { definition: roadTileSpriteDefinitions.teeMissingNorth, rotation: 0 };
  }
  if (mask === (SOUTH | WEST | NORTH)) {
    return { definition: roadTileSpriteDefinitions.teeMissingEast, rotation: 0 };
  }
  if (mask === (WEST | NORTH | EAST)) {
    return { definition: roadTileSpriteDefinitions.teeMissingSouth, rotation: 0 };
  }

  if (mask === (NORTH | EAST | SOUTH | WEST)) {
    return { definition: roadTileSpriteDefinitions.cross, rotation: 0 };
  }

  return { definition: roadTileSpriteDefinitions.cross, rotation: 0 };
}

function drawRoadSprite(ctx, definition, x, y, rotationSteps = 0, tileSize = drawSize) {
  if (!ctx || !definition) {
    return false;
  }

  const sheet = state.tileSheets[definition.sheetKey];
  if (!sheet || !sheet.image) {
    return false;
  }

  const normalizedRotation = ((Number.isFinite(rotationSteps) ? rotationSteps : 0) % 4 + 4) % 4;
  const pixelX = x * tileSize;
  const pixelY = y * tileSize;

  if (normalizedRotation === 0) {
    ctx.drawImage(
      sheet.image,
      definition.sx,
      definition.sy,
      definition.size,
      definition.size,
      pixelX,
      pixelY,
      tileSize,
      tileSize
    );
    return true;
  }

  ctx.save();
  ctx.translate(pixelX + tileSize / 2, pixelY + tileSize / 2);
  ctx.rotate((Math.PI / 2) * normalizedRotation);
  ctx.drawImage(
    sheet.image,
    definition.sx,
    definition.sy,
    definition.size,
    definition.size,
    -tileSize / 2,
    -tileSize / 2,
    tileSize,
    tileSize
  );
  ctx.restore();
  return true;
}

function drawRoadOverlay(ctx, x, y, tilesOverride = null, tileSize = drawSize) {
  if (!ctx || !roadTileSpriteDefinitions) {
    return false;
  }

  const mask = computeRoadNeighborMask(x, y, TOWN_ROAD_OVERLAY_KEY, tilesOverride);
  const selection = selectRoadTileSprite(mask);
  if (!selection || !selection.definition) {
    return false;
  }

  return drawRoadSprite(
    ctx,
    selection.definition,
    x,
    y,
    selection.rotation || 0,
    tileSize
  );
}

function drawCustomOverlay(ctx, overlayKey, x, y, tilesOverride = null, tileSize = drawSize) {
  if (overlayKey === TOWN_ROAD_OVERLAY_KEY) {
    return drawRoadOverlay(ctx, x, y, tilesOverride, tileSize);
  }
  return false;
}

function drawOverlayCell(ctx, x, y, color, alpha = 0.3, tileSize = drawSize) {
  if (!ctx || !color) {
    return;
  }
  const clampedAlpha = clamp(Number.isFinite(alpha) ? alpha : 0.3, 0, 1);
  if (clampedAlpha <= 0) {
    return;
  }
  ctx.save();
  ctx.globalAlpha = clampedAlpha;
  ctx.fillStyle = color;
  ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
  ctx.restore();
}

function mixColors(colorA, colorB, t) {
  const factor = clamp(Number.isFinite(t) ? t : 0, 0, 1);
  return {
    r: Math.round(colorA.r + (colorB.r - colorA.r) * factor),
    g: Math.round(colorA.g + (colorB.g - colorA.g) * factor),
    b: Math.round(colorA.b + (colorB.b - colorA.b) * factor)
  };
}

function rgbToCss({ r, g, b }) {
  const red = Math.round(Number.isFinite(r) ? r : 0);
  const green = Math.round(Number.isFinite(g) ? g : 0);
  const blue = Math.round(Number.isFinite(b) ? b : 0);
  return `rgb(${red}, ${green}, ${blue})`;
}

function getElevationOverlayColor(value, seaLevel) {
  if (!Number.isFinite(value)) {
    return null;
  }
  const safeSeaLevel = Number.isFinite(seaLevel) ? clamp(seaLevel, 0, 1) : 0.5;
  const clampedValue = clamp(value, 0, 1);
  if (clampedValue <= safeSeaLevel) {
    const ratio = safeSeaLevel <= 0 ? 0 : clamp(clampedValue / safeSeaLevel, 0, 1);
    const deep = { r: 23, g: 63, b: 140 };
    const shallow = { r: 88, g: 164, b: 218 };
    return rgbToCss(mixColors(deep, shallow, ratio));
  }
  const landSpan = Math.max(1 - safeSeaLevel, 0.0001);
  const landRatio = clamp((clampedValue - safeSeaLevel) / landSpan, 0, 1);
  const foothills = { r: 96, g: 158, b: 94 };
  const highlands = { r: 168, g: 124, b: 80 };
  const peaks = { r: 236, g: 230, b: 220 };
  if (landRatio < 0.5) {
    return rgbToCss(mixColors(foothills, highlands, landRatio * 2));
  }
  return rgbToCss(mixColors(highlands, peaks, (landRatio - 0.5) * 2));
}

function getTemperatureOverlayColor(value) {
  if (!Number.isFinite(value)) {
    return null;
  }
  const t = clamp(value, 0, 1);
  const cold = { r: 32, g: 74, b: 135 };
  const temperate = { r: 245, g: 208, b: 112 };
  const hot = { r: 204, g: 65, b: 52 };
  if (t < 0.5) {
    return rgbToCss(mixColors(cold, temperate, t * 2));
  }
  return rgbToCss(mixColors(temperate, hot, (t - 0.5) * 2));
}

const biomeOverlayColors = {
  forest: '#2f855a',
  jungle: '#0f766e',
  mountain: '#9c6644',
  desert: '#f4a261',
  badlands: '#d97706',
  tundra: '#94a3b8',
  grassland: '#65a30d',
  marsh: '#1d948a',
  ocean: '#2563eb',
  lake: '#38bdf8',
  water: '#38bdf8'
};

function getBiomeOverlayColor(type) {
  if (typeof type !== 'string' || type.length === 0) {
    return null;
  }
  const normalized = type.toLowerCase();
  return biomeOverlayColors[normalized] || null;
}

function applySurfaceNoiseShading(
  ctx,
  cell,
  x,
  y,
  tileSize = drawSize,
  baseKeys = {}
) {
  if (!ctx || !cell || typeof cell.base !== 'string') {
    return;
  }

  const { snowTileKey = null, sandTileKey = null, badlandsTileKey = null } = baseKeys;
  const baseKey = cell.base;
  if (baseKey !== snowTileKey && baseKey !== sandTileKey && baseKey !== badlandsTileKey) {
    return;
  }

  const variation = clamp(
    Number.isFinite(cell.surfaceVariation) ? cell.surfaceVariation : 0,
    -1,
    1
  );
  if (Math.abs(variation) < 0.01) {
    return;
  }

  const pixelX = x * tileSize;
  const pixelY = y * tileSize;
  const lighten = variation > 0;
  const intensity = Math.min(1, Math.abs(variation));

  let colorComponents = null;
  let alpha = 0;

  if (baseKey === snowTileKey) {
    if (lighten) {
      colorComponents = '255, 255, 255';
      alpha = 0.1 + intensity * 0.28;
    } else {
      colorComponents = '120, 146, 182';
      alpha = 0.08 + intensity * 0.26;
    }
  } else if (baseKey === sandTileKey) {
    if (lighten) {
      colorComponents = '255, 236, 192';
      alpha = 0.08 + intensity * 0.24;
    } else {
      colorComponents = '184, 140, 78';
      alpha = 0.08 + intensity * 0.22;
    }
  } else if (baseKey === badlandsTileKey) {
    if (lighten) {
      colorComponents = '235, 206, 168';
      alpha = 0.08 + intensity * 0.22;
    } else {
      colorComponents = '143, 102, 66';
      alpha = 0.08 + intensity * 0.24;
    }
  }

  if (!colorComponents || alpha <= 0) {
    return;
  }

  const clampedAlpha = clamp(alpha, 0, 0.55);
  ctx.save();
  ctx.globalCompositeOperation = 'source-atop';
  ctx.fillStyle = `rgba(${colorComponents}, ${clampedAlpha})`;
  ctx.fillRect(pixelX, pixelY, tileSize, tileSize);
  ctx.restore();
}

function applyCoastalShading(ctx, cell, x, y, waterTileKey, grassTileKey, tileSize = drawSize) {
  if (!ctx || !cell) {
    return;
  }
  const pixelX = x * tileSize;
  const pixelY = y * tileSize;
  const hasDistinctWaterTile = Boolean(waterTileKey) && waterTileKey !== grassTileKey;
  const isWaterTile = hasDistinctWaterTile && cell.base === waterTileKey;
  if (isWaterTile) {
    const depth = clamp(Number.isFinite(cell.waterDepth) ? cell.waterDepth : 0, 0, 1);
    const shallowFactor = clamp(1 - depth, 0, 1);
    if (shallowFactor > 0.01) {
      const alpha = shallowFactor * 0.32;
      ctx.fillStyle = `rgba(88, 164, 218, ${alpha})`;
      ctx.fillRect(pixelX, pixelY, tileSize, tileSize);
    }
    return;
  }
  if (!grassTileKey || cell.base !== grassTileKey) {
    return;
  }
  const coastProximity = clamp(
    Number.isFinite(cell.coastProximity) ? cell.coastProximity : 0,
    0,
    1
  );
  if (coastProximity > 0.01) {
    const lightenAlpha = coastProximity * 0.32;
    ctx.save();
    ctx.globalCompositeOperation = 'source-atop';
    ctx.fillStyle = `rgba(148, 205, 184, ${lightenAlpha})`;
    ctx.fillRect(pixelX, pixelY, tileSize, tileSize);
    ctx.restore();
  }
  const marshProximity = clamp(
    Number.isFinite(cell.marshProximity) ? cell.marshProximity : 0,
    0,
    1
  );
  if (marshProximity > 0.01) {
    const alpha = marshProximity * 0.55;
    ctx.save();
    ctx.globalCompositeOperation = 'source-atop';
    ctx.fillStyle = `rgba(82, 64, 40, ${alpha})`;
    ctx.fillRect(pixelX, pixelY, tileSize, tileSize);
    ctx.restore();
  }
  const forestDensity = clamp(
    Number.isFinite(cell.forestCanopyDensity) ? cell.forestCanopyDensity : 0,
    0,
    1
  );
  if (cell.biomeType === 'forest' && forestDensity > 0.01) {
    const forestAlpha = forestDensity * 0.55;
    ctx.save();
    ctx.globalCompositeOperation = 'source-atop';
    ctx.fillStyle = `rgba(26, 74, 36, ${forestAlpha})`;
    ctx.fillRect(pixelX, pixelY, tileSize, tileSize);
    ctx.restore();
  }
  const desertProximity = clamp(
    Number.isFinite(cell.desertProximity) ? cell.desertProximity : 0,
    0,
    1
  );
  if (desertProximity > 0.01) {
    const desertAlpha = desertProximity * 0.4;
    ctx.save();
    ctx.globalCompositeOperation = 'source-atop';
    ctx.fillStyle = `rgba(228, 202, 146, ${desertAlpha})`;
    ctx.fillRect(pixelX, pixelY, tileSize, tileSize);
    ctx.restore();
  }
}

function applyVolcanoShading(ctx, cell, x, y, tileSize = drawSize) {
  if (!ctx || !cell) {
    return;
  }

  const overlayKey = typeof cell.overlay === 'string' ? cell.overlay : null;
  const hillOverlayKey = typeof cell.hillOverlay === 'string' ? cell.hillOverlay : null;

  if (isMountainOverlayKey(overlayKey) || isMountainOverlayKey(hillOverlayKey)) {
    // Mountain tiles handle volcano shading separately to avoid double-darkening.
    return;
  }

  const proximity = clamp(Number.isFinite(cell.volcanoProximity) ? cell.volcanoProximity : 0, 0, 1);
  if (proximity <= 0.01) {
    return;
  }

  const pixelX = x * tileSize;
  const pixelY = y * tileSize;
  const alpha = proximity * 0.4;
  ctx.save();
  ctx.globalCompositeOperation = 'source-atop';
  ctx.fillStyle = `rgba(28, 14, 10, ${alpha})`;
  ctx.fillRect(pixelX, pixelY, tileSize, tileSize);
  ctx.restore();
}

function applyMountainShading(ctx, cell, x, y, tileSize = drawSize) {
  if (!ctx || !cell) {
    return;
  }

  const overlayKey = typeof cell.overlay === 'string' ? cell.overlay : null;
  const hillOverlayKey = typeof cell.hillOverlay === 'string' ? cell.hillOverlay : null;
  if (!isMountainOverlayKey(overlayKey) && !isMountainOverlayKey(hillOverlayKey)) {
    return;
  }

  // Previously mountain tiles were darkened to create a shaded effect. This made
  // grass bases appear unintentionally darker wherever a mountain overlay was
  // present. By returning early, we avoid applying any additional shading while
  // keeping the function signature intact for future adjustments.
  return;
}

function applyBadlandsHillTint(ctx, cell, x, y, tileSize = drawSize) {
  if (!ctx || !cell) {
    return;
  }

  const baseKey = typeof cell.base === 'string' ? cell.base : null;
  if (baseKey !== 'BADLANDS') {
    return;
  }

  const overlayKey = typeof cell.overlay === 'string' ? cell.overlay : null;
  const hillOverlayKey = typeof cell.hillOverlay === 'string' ? cell.hillOverlay : null;
  const hasHillOverlay =
    (overlayKey && isHillOverlayKey(overlayKey)) || (hillOverlayKey && isHillOverlayKey(hillOverlayKey));

  if (!hasHillOverlay) {
    return;
  }

  const variationValue = Number(cell.surfaceVariation);
  const variation = clamp(Number.isFinite(variationValue) ? Math.abs(variationValue) : 0, 0, 1);
  const alpha = clamp(0.2 + variation * 0.22, 0.18, 0.42);

  ctx.save();
  ctx.globalCompositeOperation = 'source-atop';
  ctx.globalAlpha = alpha;
  ctx.fillStyle = '#b34723';
  ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
  ctx.restore();
}

function applyDesertMountainTint(ctx, cell, x, y, tileSize = drawSize) {
  if (!ctx || !cell) {
    return;
  }

  const overlayKey = typeof cell.overlay === 'string' ? cell.overlay : null;
  if (!overlayKey || !isMountainOverlayKey(overlayKey)) {
    return;
  }

  const baseKey = typeof cell.base === 'string' ? cell.base : '';
  const isSandBase = baseKey === 'SAND';
  const isBadlandsBase = baseKey === 'BADLANDS';
  if (!isSandBase && !isBadlandsBase) {
    return;
  }

  ctx.save();
  ctx.globalCompositeOperation = 'source-atop';
  ctx.globalAlpha = isBadlandsBase ? 0.35 : 0.45;
  ctx.fillStyle = isBadlandsBase ? '#b38a5c' : '#dcbf7e';
  ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
  ctx.restore();
}

const locationLabelStylesByCategory = {
  capital: {
    fontSize: 22,
    fontWeight: '700',
    fill: '#29190e',
    outline: 'rgba(252, 243, 224, 0.9)',
    innerOutline: 'rgba(80, 48, 24, 0.6)',
    shadowColor: 'rgba(28, 15, 8, 0.4)'
  },
  city: {
    fontSize: 18,
    fontWeight: '700',
    fill: '#2d1b10',
    outline: 'rgba(250, 240, 219, 0.85)',
    innerOutline: 'rgba(84, 50, 28, 0.55)'
  },
  dwarfhold: {
    fontSize: 19,
    fontWeight: '700',
    fill: '#271d17',
    outline: 'rgba(246, 235, 213, 0.85)',
    innerOutline: 'rgba(76, 56, 32, 0.58)'
  },
  hillhold: {
    fontSize: 18,
    fontWeight: '700',
    fill: '#2a1e16',
    outline: 'rgba(246, 234, 208, 0.82)',
    innerOutline: 'rgba(74, 51, 30, 0.55)'
  },
  castle: {
    fontSize: 17,
    fontWeight: '700',
    fill: '#2b1c12',
    outline: 'rgba(245, 234, 210, 0.82)',
    innerOutline: 'rgba(78, 52, 30, 0.54)'
  },
  town: {
    fontSize: 16,
    fontWeight: '600',
    fill: '#2b1f15',
    outline: 'rgba(244, 233, 208, 0.8)',
    innerOutline: 'rgba(80, 56, 34, 0.52)'
  },
  village: {
    fontSize: 15,
    fontWeight: '600',
    fill: '#2d2116',
    outline: 'rgba(242, 231, 205, 0.78)',
    innerOutline: 'rgba(82, 58, 36, 0.5)'
  },
  temple: {
    fontSize: 15,
    fontWeight: '600',
    fill: '#2a1c12',
    outline: 'rgba(244, 232, 209, 0.78)',
    innerOutline: 'rgba(78, 54, 32, 0.52)'
  },
  monastery: {
    fontSize: 15,
    fontWeight: '600',
    fill: '#281d12',
    outline: 'rgba(244, 232, 208, 0.78)',
    innerOutline: 'rgba(76, 54, 33, 0.5)'
  },
  grove: {
    fontSize: 15,
    fontWeight: '600',
    fill: '#241e13',
    outline: 'rgba(242, 232, 212, 0.78)',
    innerOutline: 'rgba(68, 52, 30, 0.48)'
  },
  tower: {
    fontSize: 14,
    fontWeight: '600',
    fill: '#281d14',
    outline: 'rgba(240, 229, 205, 0.76)',
    innerOutline: 'rgba(70, 50, 32, 0.46)'
  },
  shrine: {
    fontSize: 14,
    fontWeight: '600',
    fill: '#281d13',
    outline: 'rgba(240, 229, 206, 0.76)',
    innerOutline: 'rgba(68, 49, 30, 0.45)'
  },
  mine: {
    fontSize: 14,
    fontWeight: '600',
    fill: '#261d14',
    outline: 'rgba(238, 227, 204, 0.74)',
    innerOutline: 'rgba(68, 50, 32, 0.44)'
  },
  dungeon: {
    fontSize: 14,
    fontWeight: '600',
    fill: '#261c17',
    outline: 'rgba(237, 226, 205, 0.74)',
    innerOutline: 'rgba(70, 51, 34, 0.44)'
  }
};

const locationLabelImportanceByCategory = {
  capital: 6,
  city: 5,
  dwarfhold: 5,
  hillhold: 4,
  castle: 4,
  temple: 3,
  monastery: 3,
  town: 3,
  grove: 2,
  village: 2,
  tower: 2,
  shrine: 2,
  mine: 2,
  dungeon: 2
};

function resolveLocationLabelCategory(...values) {
  const descriptors = values
    .filter((value) => typeof value === 'string' && value.trim())
    .map((value) =>
      value
        .replace(/[_-]+/g, ' ')
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .toLowerCase()
    );
  if (descriptors.length === 0) {
    return 'location';
  }
  const combined = descriptors.join(' ');
  if (combined.includes('capital')) {
    return 'capital';
  }
  if (combined.includes('great dwarfhold') || combined.includes('dwarfhold')) {
    return 'dwarfhold';
  }
  if (combined.includes('hillhold')) {
    return 'hillhold';
  }
  if (combined.includes('metropolis') || combined.includes('city')) {
    return 'city';
  }
  if (combined.includes('large town') || combined.includes('town')) {
    return 'town';
  }
  if (combined.includes('village') || combined.includes('hamlet')) {
    return 'village';
  }
  if (combined.includes('castle') || combined.includes('citadel') || combined.includes('keep')) {
    return 'castle';
  }
  if (combined.includes('temple city')) {
    return 'temple';
  }
  if (combined.includes('temple')) {
    return 'temple';
  }
  if (combined.includes('monastery') || combined.includes('abbey')) {
    return 'monastery';
  }
  if (combined.includes('grove')) {
    return 'grove';
  }
  if (combined.includes('tower')) {
    return 'tower';
  }
  if (combined.includes('shrine')) {
    return 'shrine';
  }
  if (combined.includes('mine')) {
    return 'mine';
  }
  if (combined.includes('dungeon')) {
    return 'dungeon';
  }
  if (combined.includes('camp')) {
    return 'camp';
  }
  return descriptors[0];
}

function resolveLocationLabelStyle(category) {
  const defaultStyle = {
    fontSize: 14,
    fontWeight: '600',
    fontFamily: '"Georgia", "Times New Roman", serif',
    fill: '#281d13',
    outline: 'rgba(240, 228, 206, 0.75)',
    innerOutline: 'rgba(70, 50, 32, 0.45)',
    shadowColor: 'rgba(20, 12, 6, 0.35)'
  };
  if (!category) {
    return defaultStyle;
  }
  const style = locationLabelStylesByCategory[category];
  if (!style) {
    return defaultStyle;
  }
  return {
    ...defaultStyle,
    ...style
  };
}

function rectanglesOverlap(a, b) {
  if (!a || !b) {
    return false;
  }
  return a.left < b.right && a.right > b.left && a.top < b.bottom && a.bottom > b.top;
}

function collectLocationLabelEntries(world) {
  if (!world) {
    return [];
  }
  const entries = [];
  const seen = new Set();

  const register = (item, fallbackType) => {
    if (!item) {
      return;
    }
    const x = Number(item.x);
    const y = Number(item.y);
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      return;
    }
    const labelCandidate = [item.name, item.label, item.structureName]
      .find((value) => typeof value === 'string' && value.trim());
    if (!labelCandidate) {
      return;
    }
    const label = labelCandidate.trim();
    if (!label) {
      return;
    }
    const category = resolveLocationLabelCategory(
      item.type,
      item.classification,
      item.settlementKind,
      fallbackType
    );
    const importance = locationLabelImportanceByCategory[category] || 1;
    if (importance < 2) {
      return;
    }
    const key = `${Math.round(x)}:${Math.round(y)}:${label.toLowerCase()}`;
    if (seen.has(key)) {
      return;
    }
    seen.add(key);
    entries.push({
      x,
      y,
      label,
      category,
      importance,
      population: Number.isFinite(item.population) ? item.population : null
    });
  };

  const registerAll = (items, fallbackType) => {
    if (!Array.isArray(items)) {
      return;
    }
    items.forEach((item) => register(item, fallbackType));
  };

  registerAll(world.dwarfholds, 'dwarfhold');
  registerAll(world.hillholds, 'hillhold');
  registerAll(world.towns, 'town');
  registerAll(world.castles, 'castle');
  registerAll(world.towers, 'tower');
  registerAll(world.monasteries, 'monastery');
  registerAll(world.lizardmenCities, 'temple');
  registerAll(world.woodElfGroves, 'grove');
  registerAll(world.saintShrines, 'shrine');
  registerAll(world.mines, 'mine');
  registerAll(world.dungeons, 'dungeon');

  return entries;
}

function applyIllustratedMapEffect(ctx, width, height, drawSizeValue) {
  if (!ctx) {
    return;
  }
  const spacing = Math.max(Math.round(drawSizeValue * 3.5), 96);
  ctx.save();
  ctx.globalCompositeOperation = 'soft-light';
  ctx.fillStyle = 'rgba(248, 238, 216, 0.35)';
  ctx.fillRect(0, 0, width, height);
  ctx.globalCompositeOperation = 'color-burn';
  ctx.fillStyle = 'rgba(94, 72, 46, 0.09)';
  ctx.fillRect(0, 0, width, height);
  ctx.globalCompositeOperation = 'multiply';
  ctx.strokeStyle = 'rgba(90, 72, 50, 0.08)';
  ctx.lineWidth = 1;
  ctx.setLineDash([12, spacing - 12]);
  ctx.beginPath();
  for (let y = -height; y < height * 2; y += spacing) {
    ctx.moveTo(-width, y);
    ctx.lineTo(width * 2, y + width);
  }
  ctx.stroke();
  ctx.restore();
}

function drawLocationLabels(ctx, world, options = {}) {
  if (!ctx || !world) {
    return;
  }
  const drawSizeValue = Number.isFinite(options.drawSize) ? options.drawSize : drawSize;
  const pixelWidth = Number.isFinite(options.pixelWidth) ? options.pixelWidth : ctx.canvas.width;
  const pixelHeight = Number.isFinite(options.pixelHeight) ? options.pixelHeight : ctx.canvas.height;
  const entries = collectLocationLabelEntries(world);
  if (entries.length === 0) {
    return;
  }

  const sortedEntries = entries.slice().sort((a, b) => {
    if (b.importance !== a.importance) {
      return b.importance - a.importance;
    }
    const populationA = Number.isFinite(a.population) ? a.population : 0;
    const populationB = Number.isFinite(b.population) ? b.population : 0;
    return populationB - populationA;
  });

  const placements = [];
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.miterLimit = 2;

  sortedEntries.forEach((entry) => {
    const style = resolveLocationLabelStyle(entry.category);
    const fontSpec = `${style.fontWeight || '600'} ${style.fontSize}px ${style.fontFamily || '"Georgia", serif'}`;
    ctx.font = fontSpec;
    const metrics = ctx.measureText(entry.label);
    const textWidth = metrics.width;
    const ascent = metrics.actualBoundingBoxAscent || style.fontSize * 0.8;
    const descent = metrics.actualBoundingBoxDescent || style.fontSize * 0.25;
    const textHeight = ascent + descent;
    const paddingX = style.paddingX || style.fontSize * 0.5;
    const paddingY = style.paddingY || style.fontSize * 0.35;
    const halfWidth = textWidth / 2 + paddingX;
    const halfHeight = textHeight / 2 + paddingY;
    const anchorX = entry.x * drawSizeValue + drawSizeValue / 2;
    const anchorY = entry.y * drawSizeValue + drawSizeValue / 2;
    const offsetDistance = Math.max(drawSizeValue * 0.9, style.offsetDistance || style.fontSize * 2.2);
    const candidateOffsets = style.offsets || [
      [0, -offsetDistance * 0.75],
      [0, offsetDistance * 0.75],
      [offsetDistance, 0],
      [-offsetDistance, 0],
      [offsetDistance * 0.85, -offsetDistance * 0.45],
      [-offsetDistance * 0.85, -offsetDistance * 0.45],
      [offsetDistance * 0.85, offsetDistance * 0.45],
      [-offsetDistance * 0.85, offsetDistance * 0.45],
      [0, -offsetDistance * 1.35]
    ];

    let placement = null;
    for (let i = 0; i < candidateOffsets.length; i += 1) {
      const offset = candidateOffsets[i];
      const px = anchorX + offset[0];
      const py = anchorY + offset[1];
      const rect = {
        left: px - halfWidth,
        right: px + halfWidth,
        top: py - halfHeight,
        bottom: py + halfHeight
      };
      if (rect.left < 0 || rect.right > pixelWidth || rect.top < 0 || rect.bottom > pixelHeight) {
        continue;
      }
      let overlap = false;
      for (let j = 0; j < placements.length; j += 1) {
        if (rectanglesOverlap(rect, placements[j].rect)) {
          overlap = true;
          break;
        }
      }
      if (!overlap) {
        placement = { x: px, y: py, rect };
        break;
      }
    }

    if (!placement) {
      const px = clamp(anchorX, halfWidth, pixelWidth - halfWidth);
      const py = clamp(anchorY, halfHeight, pixelHeight - halfHeight);
      placement = {
        x: px,
        y: py,
        rect: {
          left: px - halfWidth,
          right: px + halfWidth,
          top: py - halfHeight,
          bottom: py + halfHeight
        }
      };
    }

    placements.push({ rect: placement.rect });

    ctx.save();
    ctx.font = fontSpec;
    ctx.lineJoin = 'round';
    ctx.shadowColor = style.shadowColor || 'rgba(20, 12, 6, 0.35)';
    ctx.shadowBlur = style.shadowBlur || style.fontSize * 0.4;
    ctx.lineWidth = Math.max(2, Math.round(style.fontSize * 0.18));
    ctx.strokeStyle = style.outline || 'rgba(242, 232, 210, 0.78)';
    ctx.strokeText(entry.label, placement.x, placement.y);
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.lineWidth = Math.max(1, Math.round(style.fontSize * 0.12));
    ctx.strokeStyle = style.innerOutline || 'rgba(76, 54, 32, 0.5)';
    ctx.strokeText(entry.label, placement.x, placement.y);
    ctx.fillStyle = style.fill || '#281d13';
    ctx.fillText(entry.label, placement.x, placement.y);
    ctx.restore();
  });

  ctx.restore();
}

function drawWorld(world, options = {}) {
  const { preserveView = false } = options;
  const { tiles, seedString } = world;
  const factions = Array.isArray(world.factions) ? world.factions : [];
  const showPoliticalBorders = Boolean(state.ui && state.ui.showPoliticalBorders);
  const showPoliticalInfluence = Boolean(state.ui && state.ui.showPoliticalInfluence);
  const showElevation = Boolean(state.ui && state.ui.showElevation);
  const showBiomes = Boolean(state.ui && state.ui.showBiomes);
  const showTemperature = Boolean(state.ui && state.ui.showTemperature);
  const showLocationLabels = Boolean(state.ui && state.ui.showLocationLabels);
  const shouldDrawDataOverlay = showElevation || showBiomes || showTemperature;
  const elevationField = showElevation && world.elevationField ? world.elevationField : null;
  const temperatureField = showTemperature && world.temperatureField ? world.temperatureField : null;
  const seaLevel = Number.isFinite(world.seaLevel) ? world.seaLevel : null;
  const hasBorderOverlay = showPoliticalBorders && factions.length > 0;
  const waterTileKey = world.waterTileKey || resolveTileName('WATER');
  const grassTileKey = world.grassTileKey || resolveTileName('GRASS');
  const highlightState = ensureStructureHighlightState();
  const activeStructureHighlightTypes = structureHighlightTypeKeys.filter(
    (typeKey) => highlightState && Boolean(highlightState[typeKey])
  );
  const hasStructureHighlights = activeStructureHighlightTypes.length > 0;
  hideStructureDetails();
  hideMapTooltip();
  const height = tiles.length;
  const width = tiles[0].length;
  const previousView = preserveView
    ? {
        scale: viewState.scale,
        translateX: viewState.translateX,
        translateY: viewState.translateY,
        hasInteracted: viewState.hasInteracted
      }
    : null;

  const ctx = elements.canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  elements.canvas.width = width * drawSize;
  elements.canvas.height = height * drawSize;
  const pixelWidth = width * drawSize;
  const pixelHeight = height * drawSize;
  elements.canvas.style.width = `${pixelWidth}px`;
  elements.canvas.style.height = `${pixelHeight}px`;
  if (elements.canvasWrapper) {
    elements.canvasWrapper.classList.toggle('canvas-wrapper--illustrated', showLocationLabels);
  }

  if (preserveView && elements.canvasWrapper) {
    const rect = elements.canvasWrapper.getBoundingClientRect();
    viewState.wrapperSize = { width: rect.width, height: rect.height };
    viewState.worldSize = { width: pixelWidth, height: pixelHeight };
    const { contain, cover } = computeViewScales(rect.width, rect.height, pixelWidth, pixelHeight);
    viewState.containScale = contain;
    viewState.coverScale = cover;
    viewState.minScale = Math.min(0.25, contain);
    viewState.maxScale = Math.max(6, cover * 4);
    const targetScale = previousView ? previousView.scale : viewState.scale;
    viewState.scale = clamp(targetScale, viewState.minScale, viewState.maxScale);
    viewState.translateX = previousView ? previousView.translateX : viewState.translateX;
    viewState.translateY = previousView ? previousView.translateY : viewState.translateY;
    viewState.hasInteracted = previousView ? previousView.hasInteracted : viewState.hasInteracted;
    applyViewTransform();
  } else {
    resetView(pixelWidth, pixelHeight);
  }
  refreshOverlayToggleButtons();

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const cell = tiles[y][x];
      const cellIndex = shouldDrawDataOverlay ? y * width + x : null;
      const baseDefinition = tileLookup.get(cell.base) || tileLookup.get('GRASS');
      if (!baseDefinition) {
        continue;
      }
      const baseSheet = state.tileSheets[baseDefinition.sheet];
      if (!baseSheet || !baseSheet.image) {
        continue;
      }
      ctx.drawImage(
        baseSheet.image,
        baseDefinition.sx,
        baseDefinition.sy,
        baseDefinition.size,
        baseDefinition.size,
        x * drawSize,
        y * drawSize,
        drawSize,
        drawSize
      );

      applyCoastalShading(ctx, cell, x, y, waterTileKey, grassTileKey);
      applyVolcanoShading(ctx, cell, x, y);

      if (cell.hillOverlay && cell.hillOverlay !== cell.overlay) {
        const hillDefinition = tileLookup.get(cell.hillOverlay);
        if (hillDefinition) {
          const hillSheet = state.tileSheets[hillDefinition.sheet];
          if (hillSheet && hillSheet.image) {
            ctx.drawImage(
              hillSheet.image,
              hillDefinition.sx,
              hillDefinition.sy,
              hillDefinition.size,
              hillDefinition.size,
              x * drawSize,
              y * drawSize,
              drawSize,
              drawSize
            );
          }
        }
      }

      if (cell.overlay) {
        const overlayDefinition = tileLookup.get(cell.overlay);
        if (!overlayDefinition) {
          drawCustomOverlay(ctx, cell.overlay, x, y);
        } else {
          const overlaySheet = state.tileSheets[overlayDefinition.sheet];
          if (overlaySheet && overlaySheet.image) {
            ctx.drawImage(
              overlaySheet.image,
              overlayDefinition.sx,
              overlayDefinition.sy,
              overlayDefinition.size,
              overlayDefinition.size,
              x * drawSize,
              y * drawSize,
              drawSize,
              drawSize
            );
          }
        }
      }

      applyBadlandsHillTint(ctx, cell, x, y);
      applyDesertMountainTint(ctx, cell, x, y);
      applyMountainShading(ctx, cell, x, y);

      if (showElevation && elevationField && cellIndex !== null) {
        const elevationValue = elevationField[cellIndex];
        const elevationColor = getElevationOverlayColor(elevationValue, seaLevel);
        if (elevationColor) {
          drawOverlayCell(ctx, x, y, elevationColor, 0.55);
        }
      }

      if (showTemperature && temperatureField && cellIndex !== null) {
        const temperatureValue = temperatureField[cellIndex];
        const temperatureColor = getTemperatureOverlayColor(temperatureValue);
        if (temperatureColor) {
          drawOverlayCell(ctx, x, y, temperatureColor, 0.55);
        }
      }

      if (showBiomes) {
        const biomeColor = getBiomeOverlayColor(cell && cell.biomeType);
        if (biomeColor) {
          drawOverlayCell(ctx, x, y, biomeColor, 0.35);
        }
      }

      if (cell.river) {
        drawRiverSegment(ctx, cell.river, x, y);
      }

      if (cell.structure) {
        const structureDefinition = tileLookup.get(cell.structure);
        if (!structureDefinition) {
          continue;
        }
        if (typeof structureDefinition.draw === 'function') {
          structureDefinition.draw(ctx, {
            x,
            y,
            pixelX: x * drawSize,
            pixelY: y * drawSize,
            size: drawSize,
            cell,
            world
          });
        } else {
          const structureSheet = state.tileSheets[structureDefinition.sheet];
          if (!structureSheet || !structureSheet.image) {
            continue;
          }
          ctx.drawImage(
            structureSheet.image,
            structureDefinition.sx,
            structureDefinition.sy,
            structureDefinition.size,
            structureDefinition.size,
            x * drawSize,
            y * drawSize,
            drawSize,
            drawSize
          );
        }
      }

      if (showPoliticalInfluence && cell && cell.culturalInfluence && cell.culturalInfluence.color) {
        const culture = cell.culturalInfluence;
        const influenceStrength = clamp(Number(culture.strength) || 0, 0, 1);
        const overlayAlpha = clamp(0.24 + influenceStrength * 0.45, 0.2, 0.75);
        ctx.save();
        ctx.fillStyle = culture.color;
        ctx.globalAlpha = overlayAlpha;
        ctx.fillRect(x * drawSize, y * drawSize, drawSize, drawSize);
        ctx.restore();
      }

      if (hasBorderOverlay && cell && cell.factionId !== null && cell.factionId !== undefined) {
        const factionIndex = Number(cell.factionId);
        const safeIndex = Number.isFinite(factionIndex) ? Math.floor(factionIndex) : NaN;
        const faction =
          Number.isFinite(safeIndex) && safeIndex >= 0 && safeIndex < factions.length
            ? factions[safeIndex]
            : null;
        if (faction && faction.color) {
          const influenceStrength = clamp(Number(cell.factionInfluence) || 0, 0, 1);
          const overlayAlphaBase = showPoliticalInfluence
            ? clamp(0.1 + influenceStrength * 0.2, 0.08, 0.25)
            : 0.2;
          ctx.save();
          ctx.fillStyle = faction.color;
          ctx.globalAlpha = Math.min(0.35, overlayAlphaBase);
          ctx.fillRect(x * drawSize, y * drawSize, drawSize, drawSize);
          ctx.restore();

          if (showPoliticalBorders) {
            const borderThickness = Math.max(1, Math.round(drawSize / 16));
            const leftNeighbor = x > 0 ? tiles[y][x - 1] : null;
            const rightNeighbor = x < width - 1 ? tiles[y][x + 1] : null;
            const topNeighbor = y > 0 ? tiles[y - 1][x] : null;
            const bottomNeighbor = y < height - 1 ? tiles[y + 1][x] : null;
            ctx.save();
            ctx.fillStyle = '#0f172a';
            ctx.globalAlpha = 0.55;
            if (!topNeighbor || topNeighbor.factionId !== cell.factionId) {
              ctx.fillRect(x * drawSize, y * drawSize, drawSize, borderThickness);
            }
            if (!bottomNeighbor || bottomNeighbor.factionId !== cell.factionId) {
              ctx.fillRect(
                x * drawSize,
                y * drawSize + drawSize - borderThickness,
                drawSize,
                borderThickness
              );
            }
            if (!leftNeighbor || leftNeighbor.factionId !== cell.factionId) {
              ctx.fillRect(x * drawSize, y * drawSize, borderThickness, drawSize);
            }
            if (!rightNeighbor || rightNeighbor.factionId !== cell.factionId) {
              ctx.fillRect(
                x * drawSize + drawSize - borderThickness,
                y * drawSize,
                borderThickness,
                drawSize
              );
            }
            ctx.restore();
          }
        }
      }

      if (hasStructureHighlights) {
        const highlightGroupKey = getHighlightGroupForTile(cell, activeStructureHighlightTypes);
        if (highlightGroupKey) {
          const highlightGroup = structureHighlightGroups[highlightGroupKey];
          if (highlightGroup) {
            drawStructureHighlightOverlay(ctx, x, y, drawSize, highlightGroup);
          }
        }
      }
    }
  }

  if (showLocationLabels) {
    applyIllustratedMapEffect(ctx, pixelWidth, pixelHeight, drawSize);
  }

  drawLocalSelectionOverlay(ctx);

  if (showLocationLabels) {
    drawLocationLabels(ctx, world, { drawSize, pixelWidth, pixelHeight });
  }
  refreshLocalMapPreview();

  state.settings.lastSeedString = seedString;
  state.settings.seedString = seedString;
  if (elements.worldSeedInput) {
    elements.worldSeedInput.value = seedString;
  }
  updateWorldInfoSeedDisplay(seedString);
  if (elements.worldMapSizeSelect) {
    elements.worldMapSizeSelect.value = state.settings.mapSize;
  }
  updateWorldInfoSizeDisplay();
  const worldLabel = state.worldName ? `World: ${state.worldName} | ` : '';
  const chronologyLabel = isChronologyValid(state.worldChronology)
    ? `${formatChronology(state.worldChronology.year, state.worldChronology.age)} | `
    : '';
  elements.seedDisplay.textContent = `${worldLabel}${chronologyLabel}Seed: ${seedString} | ${width}×${height}`;
}

function updateLoadingProgress(value) {
  const numericValue = Number.isFinite(value) ? value : 0;
  loadingProgressValue = clamp(numericValue, 0, 100);
  if (elements.loadingProgressFill) {
    elements.loadingProgressFill.style.width = `${loadingProgressValue}%`;
  }
  if (elements.loadingProgressBar) {
    elements.loadingProgressBar.setAttribute('aria-valuenow', Math.round(loadingProgressValue).toString());
  }
}

function updateLoadingStatus(text) {
  if (!elements.loadingStatus) {
    return;
  }
  const message = text && text.trim().length > 0 ? text : defaultLoadingStatusMessage;
  elements.loadingStatus.textContent = message;
}

function stopLoadingProgressAnimation() {
  if (typeof window !== 'undefined' && loadingProgressIntervalId !== null) {
    window.clearInterval(loadingProgressIntervalId);
  }
  loadingProgressIntervalId = null;
}

function startLoadingProgressAnimation(maxProgress = 92) {
  stopLoadingProgressAnimation();
  updateLoadingProgress(0);
  if (typeof window === 'undefined') {
    return;
  }
  loadingProgressIntervalId = window.setInterval(() => {
    const increment = Math.random() * 9 + 3;
    const nextValue = Math.min(loadingProgressValue + increment, maxProgress);
    updateLoadingProgress(nextValue);
    if (nextValue >= maxProgress) {
      stopLoadingProgressAnimation();
    }
  }, 350);
}

function showLoadingScreen(statusText = defaultLoadingStatusMessage) {
  if (!elements.loadingScreen) {
    return;
  }
  hasManualLoadingProgress = false;
  updateLoadingStatus(statusText);
  elements.loadingScreen.classList.remove('hidden');
  elements.loadingScreen.setAttribute('aria-hidden', 'false');
  elements.loadingScreen.setAttribute('aria-busy', 'true');
  if (elements.loadingPanel && typeof elements.loadingPanel.focus === 'function') {
    elements.loadingPanel.focus();
  }
  startLoadingProgressAnimation();
}

function hideLoadingScreen({ resetStatus = true } = {}) {
  stopLoadingProgressAnimation();
  if (!elements.loadingScreen) {
    return;
  }
  hasManualLoadingProgress = false;
  elements.loadingScreen.classList.add('hidden');
  elements.loadingScreen.setAttribute('aria-hidden', 'true');
  elements.loadingScreen.removeAttribute('aria-busy');
  updateLoadingProgress(0);
  if (resetStatus) {
    updateLoadingStatus(defaultLoadingStatusMessage);
  }
}

function completeLoadingScreen() {
  stopLoadingProgressAnimation();
  updateLoadingProgress(100);
  updateLoadingStatus('World ready!');
  return new Promise((resolve) => {
    if (typeof window === 'undefined') {
      hideLoadingScreen();
      resolve();
      return;
    }
    window.setTimeout(() => {
      hideLoadingScreen();
      resolve();
    }, 400);
  });
}

function setManualLoadingProgress(value, statusText, { force = false, minDelta = 0.5 } = {}) {
  const numericValue = Number.isFinite(value) ? value : 0;
  const clampedValue = clamp(numericValue, 0, 100);
  if (!hasManualLoadingProgress) {
    stopLoadingProgressAnimation();
    hasManualLoadingProgress = true;
  }
  if (!force && Math.abs(clampedValue - loadingProgressValue) < minDelta) {
    if (statusText && elements.loadingStatus && elements.loadingStatus.textContent !== statusText) {
      updateLoadingStatus(statusText);
    }
    return;
  }
  updateLoadingProgress(clampedValue);
  if (statusText) {
    updateLoadingStatus(statusText);
  }
}

function waitForNextFrame() {
  if (typeof window === 'undefined' || typeof window.requestAnimationFrame !== 'function') {
    return Promise.resolve();
  }
  return new Promise((resolve) => {
    window.requestAnimationFrame(() => resolve());
  });
}

async function updateLoadingProgressAndWait(value, statusText, options) {
  setManualLoadingProgress(value, statusText, options);
  await waitForNextFrame();
}

function runWithLoadingScreen(action, { statusText } = {}) {
  showLoadingScreen(statusText);
  return new Promise((resolve, reject) => {
    const execute = () => {
      let result;
      try {
        result = action();
      } catch (error) {
        hideLoadingScreen();
        reject(error);
        return;
      }
      const finalize = (resolvedResult) => {
        completeLoadingScreen().then(() => resolve(resolvedResult));
      };
      if (result && typeof result.then === 'function') {
        result
          .then((asyncResult) => finalize(asyncResult))
          .catch((error) => {
            hideLoadingScreen();
            reject(error);
          });
        return;
      }
      finalize(result);
    };

    if (typeof window === 'undefined' || typeof window.requestAnimationFrame !== 'function') {
      execute();
      return;
    }

    window.requestAnimationFrame(() => {
      window.requestAnimationFrame(execute);
    });
  });
}

function beginGame() {
  closeDwarfCustomizer({ keepWorldInfoHidden: true });
  closeWorldInfoModal({ keepTitleHidden: true });
  if (elements.titleScreen) {
    elements.titleScreen.classList.add('hidden');
  }
  if (elements.gameContainer) {
    elements.gameContainer.classList.remove('hidden');
    elements.gameContainer.classList.add('game-container--loading');
    elements.gameContainer.setAttribute('aria-busy', 'true');
  }
  elements.seedDisplay.textContent = '';
  runWithLoadingScreen(() => generateAndRender(), { statusText: 'Forging your world…' })
    .then(() => {
      if (elements.gameContainer) {
        elements.gameContainer.classList.remove('game-container--loading');
        elements.gameContainer.removeAttribute('aria-busy');
      }
    })
    .catch((error) => {
      console.error('Failed to generate world.', error);
      if (elements.gameContainer) {
        elements.gameContainer.classList.remove('game-container--loading');
        elements.gameContainer.removeAttribute('aria-busy');
      }
      if (elements.titleScreen) {
        elements.titleScreen.classList.remove('hidden');
      }
      openDwarfCustomizer();
    });
}

async function loadTileSheetImages() {
  // Load all tile sheet images if not already loaded
  const sheetKeys = Object.keys(state.tileSheets || {});
  const loadPromises = [];
  
  for (let i = 0; i < sheetKeys.length; i += 1) {
    const key = sheetKeys[i];
    const sheet = state.tileSheets[key];
    if (!sheet || !sheet.path) {
      continue;
    }
    if (sheet.image) {
      // Already loaded
      continue;
    }
    try {
      const imagePromise = loadImage(sheet.path);
      imagePromise.then((img) => {
        if (sheet && img) {
          sheet.image = img;
        }
      }).catch((error) => {
        console.warn(`Failed to load tile sheet image: ${sheet.path}`, error);
      });
      loadPromises.push(imagePromise);
    } catch (error) {
      console.warn(`Error loading tile sheet: ${key}`, error);
    }
  }
  
  if (loadPromises.length > 0) {
    await Promise.all(loadPromises);
  }
}

async function generateAndRender(seedOverride) {
  const seedToUse = typeof seedOverride === 'string' ? seedOverride : state.settings.seedString;
  ensureLandMaskForProfile(state.settings.worldGenerationType);
  hideMapTooltip();
  hideLocalView({ suppressRedraw: true });
  await updateLoadingProgressAndWait(5, 'Loading tile sheets…');
  await loadTileSheetImages();
  await updateLoadingProgressAndWait(12, 'Stabilizing ley lines…');
  await updateLoadingProgressAndWait(28, 'Surveying continental plates…');
  const world = createWorld(seedToUse);
  await updateLoadingProgressAndWait(68, 'Raising civilizations…');
  state.currentWorld = world;
  await updateLoadingProgressAndWait(82, 'Rendering cartography…');
  drawWorld(world);
  await updateLoadingProgressAndWait(92, 'Finalizing expedition briefs…', { force: true });
  if (elements.seedInput) {
    elements.seedInput.value = world.seedString;
  }
  if (elements.worldSeedInput) {
    elements.worldSeedInput.value = world.seedString;
  }
  updateWorldInfoSeedDisplay(world.seedString);
}

function updateOverlayToggleButton(button, isActive, labels) {
  if (!button) {
    return;
  }
  button.classList.toggle('active', Boolean(isActive));
  button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
  if (labels && labels.active && labels.inactive) {
    button.textContent = isActive ? labels.active : labels.inactive;
  }
}

function refreshStructureHighlightControls() {
  const button = elements.structureHighlightToggle;
  const menu = elements.structureHighlightMenu;
  const highlightState = ensureStructureHighlightState();
  const activeTypes = structureHighlightTypeKeys.filter((key) => Boolean(highlightState[key]));
  const activeCount = activeTypes.length;
  const isOpen = Boolean(highlightState.menuOpen);
  const countLabel = activeCount > 0 ? ` (${activeCount})` : '';

  if (button) {
    const showLabel = `Show Highlights${countLabel}`;
    const hideLabel = `Hide Highlights${countLabel}`;
    button.textContent = isOpen ? hideLabel : showLabel;
    button.classList.toggle('has-selection', activeCount > 0);
    button.classList.toggle('is-open', isOpen);
    button.classList.toggle('active', isOpen || activeCount > 0);
    button.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
  }

  if (menu) {
    syncStructureHighlightMenuOptions(menu);
    menu.classList.toggle('is-open', isOpen);
    menu.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    const inputs = menu.querySelectorAll("input[type='checkbox'][data-highlight-type]");
    inputs.forEach((input) => {
      const type = input.getAttribute('data-highlight-type');
      if (!type) {
        return;
      }
      if (Object.prototype.hasOwnProperty.call(highlightState, type)) {
        input.checked = Boolean(highlightState[type]);
      }
    });
  }
}

function refreshOverlayToggleButtons() {
  const showBorders = Boolean(state.ui && state.ui.showPoliticalBorders);
  const showInfluence = Boolean(state.ui && state.ui.showPoliticalInfluence);
  const showElevation = Boolean(state.ui && state.ui.showElevation);
  const showBiomes = Boolean(state.ui && state.ui.showBiomes);
  const showTemperature = Boolean(state.ui && state.ui.showTemperature);
  const showLocationLabels = Boolean(state.ui && state.ui.showLocationLabels);
  updateOverlayToggleButton(elements.politicalBordersToggle, showBorders, {
    active: 'Hide Borders',
    inactive: 'Show Borders'
  });
  updateOverlayToggleButton(elements.politicalInfluenceToggle, showInfluence, {
    active: 'Hide Cultural Influence',
    inactive: 'Show Cultural Influence'
  });
  updateOverlayToggleButton(elements.elevationToggle, showElevation, {
    active: 'Hide Elevation',
    inactive: 'Show Elevation'
  });
  updateOverlayToggleButton(elements.biomeToggle, showBiomes, {
    active: 'Hide Biomes',
    inactive: 'Show Biomes'
  });
  updateOverlayToggleButton(elements.temperatureToggle, showTemperature, {
    active: 'Hide Temperature',
    inactive: 'Show Temperature'
  });
  updateOverlayToggleButton(elements.locationLabelToggle, showLocationLabels, {
    active: 'Hide Location Labels',
    inactive: 'Show Location Labels'
  });
  refreshStructureHighlightControls();
}

function randomSeedString() {
  return Math.random().toString(36).slice(2, 10);
}

function handleRegenerate() {
  const randomSeed = randomSeedString();
  state.settings.seedString = randomSeed;
  if (elements.seedInput) {
    elements.seedInput.value = randomSeed;
  }
  if (elements.worldSeedInput) {
    elements.worldSeedInput.value = randomSeed;
  }
  updateWorldInfoSeedDisplay(randomSeed);
  return runWithLoadingScreen(
    () => generateAndRender(randomSeed),
    { statusText: 'Forging a new world…' }
  ).catch((error) => {
    console.error('Failed to regenerate world.', error);
  });
}

let optionsVisible = false;
let optionsSource = null;
let lastFocusedBeforeOptions = null;

function focusFirstOptionsControl() {
  if (!elements.optionsScreen || typeof elements.optionsScreen.querySelector !== 'function') {
    return;
  }

  const explicitInitialFocus = elements.optionsScreen.querySelector('[data-initial-focus="true"]');
  const candidate =
    explicitInitialFocus ||
    elements.closeOptions ||
    elements.optionsScreen.querySelector(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );

  if (candidate && typeof candidate.focus === 'function') {
    try {
      candidate.focus({ preventScroll: true });
    } catch (_) {
      candidate.focus();
    }
  }
}

function setOptionsButtonExpanded(target, expanded) {
  if (!target || typeof target.setAttribute !== 'function') {
    return;
  }
  target.setAttribute('aria-expanded', expanded ? 'true' : 'false');
}

function rememberCurrentFocus() {
  if (typeof document === 'undefined') {
    lastFocusedBeforeOptions = null;
    return;
  }

  const activeElement = document.activeElement;
  if (!activeElement || typeof activeElement.focus !== 'function') {
    lastFocusedBeforeOptions = null;
    return;
  }

  lastFocusedBeforeOptions = activeElement;
}

function restorePreviousFocus(fallback) {
  const target = lastFocusedBeforeOptions && typeof lastFocusedBeforeOptions.focus === 'function'
    ? lastFocusedBeforeOptions
    : fallback;

  if (target && typeof target.focus === 'function') {
    try {
      target.focus({ preventScroll: true });
    } catch (_) {
      target.focus();
    }
  }

  lastFocusedBeforeOptions = null;
}

function openOptionsScreen(source = 'title') {
  if (!elements.optionsScreen) {
    return;
  }

  const normalizedSource = source === 'game' ? 'game' : 'title';
  rememberCurrentFocus();

  optionsVisible = true;
  optionsSource = normalizedSource;

  elements.optionsScreen.classList.remove('hidden');
  elements.optionsScreen.setAttribute('aria-hidden', 'false');
  elements.optionsScreen.setAttribute('data-open-source', normalizedSource);

  if (normalizedSource === 'title') {
    if (elements.titleScreen) {
      elements.titleScreen.classList.add('hidden');
      elements.titleScreen.setAttribute('aria-hidden', 'true');
    }
    setOptionsButtonExpanded(elements.optionsButton, true);
  } else {
    setOptionsButtonExpanded(elements.inGameOptions, true);
    if (elements.gameContainer) {
      elements.gameContainer.setAttribute('aria-hidden', 'true');
    }
  }

  focusFirstOptionsControl();
}

function closeOptionsScreen(options = {}) {
  const { returnFocus = true } = options;

  const previousSource = optionsSource;
  optionsVisible = false;
  optionsSource = null;

  if (!elements.optionsScreen) {
    return previousSource;
  }

  elements.optionsScreen.classList.add('hidden');
  elements.optionsScreen.setAttribute('aria-hidden', 'true');
  elements.optionsScreen.removeAttribute('data-open-source');

  if (previousSource === 'title') {
    setOptionsButtonExpanded(elements.optionsButton, false);
    if (elements.titleScreen) {
      elements.titleScreen.classList.remove('hidden');
      elements.titleScreen.setAttribute('aria-hidden', 'false');
    }
  } else if (previousSource === 'game') {
    setOptionsButtonExpanded(elements.inGameOptions, false);
    if (elements.gameContainer) {
      elements.gameContainer.removeAttribute('aria-hidden');
    }
  }

  if (returnFocus) {
    const fallback = previousSource === 'game' ? elements.inGameOptions : elements.optionsButton;
    restorePreviousFocus(fallback);
  } else {
    lastFocusedBeforeOptions = null;
  }

  return previousSource;
}

function syncInputsWithSettings() {
  if (elements.mapSizeSelect) {
    elements.mapSizeSelect.value = state.settings.mapSize;
  }
  if (elements.worldMapSizeSelect) {
    elements.worldMapSizeSelect.value = state.settings.mapSize;
  }
  updateWorldInfoSizeDisplay();
  if (elements.worldGenerationTypeSelect) {
    elements.worldGenerationTypeSelect.value = state.settings.worldGenerationType;
  }
  if (elements.worldInfoGenerationTypeSelect) {
    elements.worldInfoGenerationTypeSelect.value = state.settings.worldGenerationType;
  }
  updateWorldInfoGenerationTypeDisplay();
  if (elements.seedInput) {
    elements.seedInput.value = state.settings.seedString;
  }
  if (elements.worldSeedInput) {
    elements.worldSeedInput.value = state.settings.seedString;
  }
  updateWorldInfoSeedDisplay(state.settings.seedString);
  // Overlay toggle buttons are bound inside attachEvents to avoid duplicate listeners.
  if (elements.forestFrequencyInput) {
    const value = sanitizeFrequencyValue(
      state.settings.forestFrequency,
      defaultForestFrequency
    );
    elements.forestFrequencyInput.value = value.toString();
    updateFrequencyDisplay(elements.forestFrequencyValue, value);
  }
  if (elements.mountainFrequencyInput) {
    const value = sanitizeFrequencyValue(
      state.settings.mountainFrequency,
      defaultMountainFrequency
    );
    elements.mountainFrequencyInput.value = value.toString();
    updateFrequencyDisplay(elements.mountainFrequencyValue, value);
  }
  if (elements.riverFrequencyInput) {
    const value = sanitizeFrequencyValue(state.settings.riverFrequency, 50);
    elements.riverFrequencyInput.value = value.toString();
    updateFrequencyDisplay(elements.riverFrequencyValue, value);
  }
  if (elements.humanSettlementFrequencyInput) {
    const value = sanitizeFrequencyValue(state.settings.humanSettlementFrequency, 50);
    elements.humanSettlementFrequencyInput.value = value.toString();
    updateFrequencyDisplay(elements.humanSettlementFrequencyValue, value);
  }
  if (elements.dwarfSettlementFrequencyInput) {
    const value = sanitizeFrequencyValue(state.settings.dwarfSettlementFrequency, 50);
    elements.dwarfSettlementFrequencyInput.value = value.toString();
    updateFrequencyDisplay(elements.dwarfSettlementFrequencyValue, value);
  }
  if (elements.woodElfSettlementFrequencyInput) {
    const value = sanitizeFrequencyValue(state.settings.woodElfSettlementFrequency, 50);
    elements.woodElfSettlementFrequencyInput.value = value.toString();
    updateFrequencyDisplay(elements.woodElfSettlementFrequencyValue, value);
  }
  if (elements.lizardmenSettlementFrequencyInput) {
    const value = sanitizeFrequencyValue(state.settings.lizardmenSettlementFrequency, 50);
    elements.lizardmenSettlementFrequencyInput.value = value.toString();
    updateFrequencyDisplay(elements.lizardmenSettlementFrequencyValue, value);
  }

  if (elements.forestFrequencyInput) {
    elements.forestFrequencyInput.addEventListener('input', (event) => {
      const value = sanitizeFrequencyValue(event.target.value, state.settings.forestFrequency);
      updateFrequencyDisplay(elements.forestFrequencyValue, value);
    });
  }

  if (elements.mountainFrequencyInput) {
    elements.mountainFrequencyInput.addEventListener('input', (event) => {
      const value = sanitizeFrequencyValue(event.target.value, state.settings.mountainFrequency);
      updateFrequencyDisplay(elements.mountainFrequencyValue, value);
    });
  }

  if (elements.riverFrequencyInput) {
    elements.riverFrequencyInput.addEventListener('input', (event) => {
      const value = sanitizeFrequencyValue(event.target.value, state.settings.riverFrequency);
      updateFrequencyDisplay(elements.riverFrequencyValue, value);
    });
  }

  if (elements.humanSettlementFrequencyInput) {
    elements.humanSettlementFrequencyInput.addEventListener('input', (event) => {
      const value = sanitizeFrequencyValue(
        event.target.value,
        state.settings.humanSettlementFrequency
      );
      updateFrequencyDisplay(elements.humanSettlementFrequencyValue, value);
    });
  }

  if (elements.dwarfSettlementFrequencyInput) {
    elements.dwarfSettlementFrequencyInput.addEventListener('input', (event) => {
      const value = sanitizeFrequencyValue(
        event.target.value,
        state.settings.dwarfSettlementFrequency
      );
      updateFrequencyDisplay(elements.dwarfSettlementFrequencyValue, value);
    });
  }

  if (elements.woodElfSettlementFrequencyInput) {
    elements.woodElfSettlementFrequencyInput.addEventListener('input', (event) => {
      const value = sanitizeFrequencyValue(
        event.target.value,
        state.settings.woodElfSettlementFrequency
      );
      updateFrequencyDisplay(elements.woodElfSettlementFrequencyValue, value);
    });
  }

  if (elements.lizardmenSettlementFrequencyInput) {
    elements.lizardmenSettlementFrequencyInput.addEventListener('input', (event) => {
      const value = sanitizeFrequencyValue(
        event.target.value,
        state.settings.lizardmenSettlementFrequency
      );
      updateFrequencyDisplay(elements.lizardmenSettlementFrequencyValue, value);
    });
  }

  if (elements.optionsForm) {
    elements.optionsForm.addEventListener('submit', (event) => {
      event.preventDefault();
      applyFormSettings();
      const previousSource = closeOptionsScreen();
      if (previousSource === 'game' && elements.gameContainer) {
        runWithLoadingScreen(() => generateAndRender(), { statusText: 'Updating the realm…' }).catch((error) => {
          console.error('Failed to apply new world settings.', error);
        });
      }
    });
  }

  if (elements.worldInfoForm) {
    elements.worldInfoForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const selectedMapSizeKey = elements.worldMapSizeSelect
        ? elements.worldMapSizeSelect.value
        : state.settings.mapSize;
      const selectedPreset = getMapSizePreset(selectedMapSizeKey);
      applyMapSizePresetToState(state, selectedPreset);
      if (elements.worldMapSizeSelect) {
        elements.worldMapSizeSelect.value = state.settings.mapSize;
      }
      if (elements.mapSizeSelect) {
        elements.mapSizeSelect.value = state.settings.mapSize;
      }
      updateWorldInfoSizeDisplay();
      const selectedGenerationType = elements.worldInfoGenerationTypeSelect
        ? elements.worldInfoGenerationTypeSelect.value
        : state.settings.worldGenerationType;
      setWorldGenerationType(selectedGenerationType);

      if (elements.worldSeedInput) {
        state.settings.seedString = elements.worldSeedInput.value.trim();
      }
      let finalSeed = state.settings.seedString;
      if (!finalSeed) {
        finalSeed = ensureSeedString();
        if (elements.worldSeedInput) {
          elements.worldSeedInput.value = finalSeed;
        }
      }
      state.settings.lastSeedString = finalSeed;
      if (elements.seedInput) {
        elements.seedInput.value = finalSeed;
      }
      updateWorldInfoSeedDisplay(finalSeed);

      const submittedName = elements.worldNameInput ? elements.worldNameInput.value.trim() : '';
      state.worldName = submittedName || getRandomWorldName(state.worldName);
      const submittedChronology = getSanitisedChronologyFromInputs();
      if (submittedChronology) {
        state.worldChronology = submittedChronology;
      } else {
        state.worldChronology = generateRandomChronology();
        if (elements.worldYearInput) {
          elements.worldYearInput.value = state.worldChronology.year.toString();
        }
        if (elements.worldAgeInput) {
          elements.worldAgeInput.value = state.worldChronology.age.toString();
        }
      }
      updateChronologyDisplay();
      openDwarfCustomizer();
    });
  }

  if (elements.worldInfoCancel) {
    elements.worldInfoCancel.addEventListener('click', () => {
      closeWorldInfoModal({ returnFocus: true });
    });
  }

  if (elements.worldYearInput) {
    elements.worldYearInput.addEventListener('input', updateChronologyDisplay);
  }

  if (elements.worldAgeInput) {
    elements.worldAgeInput.addEventListener('input', updateChronologyDisplay);
  }

  if (elements.worldChronologyRandom) {
    elements.worldChronologyRandom.addEventListener('click', () => {
      const newChronology = generateRandomChronology();
      state.worldChronology = newChronology;
      if (elements.worldYearInput) {
        elements.worldYearInput.value = newChronology.year.toString();
        elements.worldYearInput.focus();
        elements.worldYearInput.select();
      }
      if (elements.worldAgeInput) {
        elements.worldAgeInput.value = newChronology.age.toString();
      }
      updateChronologyDisplay();
    });
  }

  if (elements.worldNameRandom) {
    elements.worldNameRandom.addEventListener('click', () => {
      const newName = getRandomWorldName(state.worldName);
      state.worldName = newName;
      if (elements.worldNameInput) {
        elements.worldNameInput.value = newName;
        elements.worldNameInput.focus();
        elements.worldNameInput.select();
      }
    });
  }

  if (elements.worldMapSizeSelect) {
    elements.worldMapSizeSelect.addEventListener('change', (event) => {
      const preset = getMapSizePreset(event.target.value);
      applyMapSizePresetToState(state, preset);
      if (elements.mapSizeSelect) {
        elements.mapSizeSelect.value = state.settings.mapSize;
      }
      updateWorldInfoSizeDisplay();
    });
  }

  if (elements.worldInfoGenerationTypeSelect) {
    elements.worldInfoGenerationTypeSelect.addEventListener('change', (event) => {
      setWorldGenerationType(event.target.value);
      if (elements.worldGenerationTypeSelect) {
        elements.worldGenerationTypeSelect.value = state.settings.worldGenerationType;
      }
    });
  }

  if (elements.worldSeedInput) {
    elements.worldSeedInput.addEventListener('input', (event) => {
      const newValue = event.target.value;
      state.settings.seedString = newValue.trim();
      updateWorldInfoSeedDisplay(newValue);
      if (elements.seedInput && elements.seedInput !== event.target) {
        elements.seedInput.value = newValue;
      }
    });
  }

  elements.regenerate.addEventListener('click', handleRegenerate);

  if (elements.dwarfPrev) {
    elements.dwarfPrev.addEventListener('click', () => {
      changeActiveDwarf(-1);
    });
  }

  if (elements.dwarfNext) {
    elements.dwarfNext.addEventListener('click', () => {
      changeActiveDwarf(1);
    });
  }

  if (elements.dwarfRandomise) {
    elements.dwarfRandomise.addEventListener('click', () => {
      randomiseActiveDwarf();
      playSoundEffect(soundEffects.randomiseClick);
      elements.dwarfRandomise.classList.add('randomise-button__dice--rolled');
    });
  }

  if (elements.dwarfBack) {
    elements.dwarfBack.addEventListener('click', () => {
      closeDwarfCustomizer({ returnFocus: true });
    });
  }

    if (elements.dwarfCustomizerForm) {
      elements.dwarfCustomizerForm.addEventListener('submit', (event) => {
        event.preventDefault();
        beginGame();
        ensureMusicStarted();
      });
    }

  if (elements.dwarfNameInput) {
    elements.dwarfNameInput.addEventListener('input', (event) => {
      updateDwarfTrait('name', event.target.value);
    });
    elements.dwarfNameInput.addEventListener('blur', (event) => {
      const trimmed = event.target.value.trim();
      if (trimmed !== event.target.value) {
        event.target.value = trimmed;
      }
      updateDwarfTrait('name', trimmed);
    });
  }

  if (elements.dwarfGenderButtons) {
    elements.dwarfGenderButtons.addEventListener('click', (event) => {
      const button = event.target.closest('[data-gender-value]');
      if (!button || !elements.dwarfGenderButtons.contains(button)) {
        return;
      }
      const { genderValue } = button.dataset;
      if (!genderValue) {
        return;
      }
      updateDwarfTrait('gender', genderValue);
    });

    elements.dwarfGenderButtons.addEventListener('keydown', (event) => {
      if (!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(event.key)) {
        return;
      }
      event.preventDefault();
      const buttons = Array.from(
        elements.dwarfGenderButtons.querySelectorAll('[data-gender-value]')
      );
      if (buttons.length === 0) {
        return;
      }
      const currentIndex = buttons.findIndex((button) => button.classList.contains('active'));
      const direction = event.key === 'ArrowLeft' || event.key === 'ArrowUp' ? -1 : 1;
      const nextIndex = currentIndex === -1 ? 0 : (currentIndex + direction + buttons.length) % buttons.length;
      const nextButton = buttons[nextIndex];
      if (!nextButton) {
        return;
      }
      nextButton.focus();
      const { genderValue } = nextButton.dataset;
      if (genderValue) {
        updateDwarfTrait('gender', genderValue);
      }
    });
  }

  if (elements.dwarfClanSelect) {
    elements.dwarfClanSelect.addEventListener('change', (event) => {
      updateDwarfTrait('clan', event.target.value);
    });
  }

  if (elements.dwarfProfessionSelect) {
    elements.dwarfProfessionSelect.addEventListener('change', (event) => {
      updateDwarfTrait('profession', event.target.value);
    });
  }

  setupTraitSliderControl('skin', elements.dwarfSkinSlider, elements.dwarfSkinSliderValue);
  setupTraitSliderControl('eyes', elements.dwarfEyeSlider, elements.dwarfEyeSliderValue);
  setupTraitSliderControl(
    'hairStyle',
    elements.dwarfHairStyleSlider,
    elements.dwarfHairStyleSliderValue
  );
  setupTraitSliderControl('hair', elements.dwarfHairSlider, elements.dwarfHairSliderValue);

  setupTraitSliderControl('beard', elements.dwarfBeardSlider, elements.dwarfBeardSliderValue);

  document.addEventListener('keydown', (event) => {
    const activeElement = document.activeElement;
    const isFormControl =
      activeElement && ['INPUT', 'SELECT', 'TEXTAREA'].includes(activeElement.tagName);

      if (isDwarfCustomizerVisible() && !isFormControl) {
        if (event.key === 'ArrowLeft') {
          event.preventDefault();
          changeActiveDwarf(-1);
          return;
        }
        if (event.key === 'ArrowRight') {
          event.preventDefault();
          changeActiveDwarf(1);
          return;
        }
      }

      if (event.key === 'Escape') {
        if (state.localView && state.localView.active) {
          hideLocalView();
          return;
        }
      if (structureDetailsState.visible) {
        hideStructureDetails({ returnFocus: true });
        return;
      }
      if (isDwarfCustomizerVisible()) {
        closeDwarfCustomizer({ returnFocus: true });
        return;
      }
      if (elements.worldInfoModal && !elements.worldInfoModal.classList.contains('hidden')) {
        closeWorldInfoModal({ returnFocus: true });
        return;
      }
      if (optionsVisible) {
        closeOptionsScreen();
      }
    }
  });

  refreshOverlayToggleButtons();
}

function initialise() {
  syncInputsWithSettings();
  setupAudioControls();
  setupSoundEffectControls();
  ensureMapEditorState();
  refreshMapEditorUI();
  setupMapInteractions();
  handleResize();
}
function autoStartGameIfNeeded() {
  showTitleScreen({ focusStartButton: true });
}
function ensureClanSelectOptions() {
  if (elements.dwarfClanSelect) {
    populateClanSelectFromOptions(dwarfOptions.clan);
  }
}

function ensureProfessionSelectOptions() {
  if (elements.dwarfProfessionSelect) {
    populateProfessionSelectFromOptions(dwarfOptions.profession);
  }
}

function bootApplication() {
  hydrateElements();
  ensureClanSelectOptions();
  ensureProfessionSelectOptions();

  attachEvents(elements, {
    structureContextMenuState,
    hideStructureContextMenu,
    openOptionsScreen,
    closeOptionsScreen,
    hideStructureDetails,
    showLocalViewAt,
    showDwarfholdInterior,
    showStructureDetails,
    hideLocalView,
    adjustLocalMapZoom,
    resetLocalMapZoom,
    closeDwarfholdInterior,
    state,
    refreshOverlayToggleButtons,
    refreshStructureHighlightControls,
    ensureStructureHighlightState,
    drawWorld,
    updateFrequencyDisplay,
    sanitizeFrequencyValue,
    defaultForestFrequency,
    defaultMountainFrequency,
    ensureSeedString,
    getRandomWorldName,
    getSanitisedChronologyFromInputs,
    generateRandomChronology,
    updateChronologyDisplay,
    openDwarfCustomizer,
    closeWorldInfoModal,
    openWorldInfoModal,
    applyMapSizePresetToState,
    getMapSizePreset,
    handleRegenerate,
    changeActiveDwarf,
    randomiseActiveDwarf,
    playSoundEffect,
    soundEffects,
    ensureMusicStarted,
    beginGame,
    updateDwarfTrait,
    setupTraitSliderControl,
    isDwarfCustomizerVisible,
    closeDwarfCustomizer,
    structureDetailsState,
    setActiveStructureDetailsTab,
    isOptionsVisible: () => optionsVisible,
    updateWorldInfoSeedDisplay,
    updateWorldInfoSizeDisplay,
    updateWorldInfoGenerationTypeDisplay,
    setWorldGenerationType,
    toggleMapEditor,
    closeMapEditor,
    setMapEditorTerrainKey,
    setMapEditorStructureKey,
    setMapEditorApplyTerrain,
    setMapEditorApplyStructure,
    setMapEditorBrushSize,
    clearMapEditorStructure
  });

  initialise();
  autoStartGameIfNeeded();

  if (typeof document !== 'undefined' && document.documentElement) {
    try {
      document.documentElement.setAttribute('data-app-initialised', 'true');
    } catch (_) {}
  }

  try {
    if (typeof window !== 'undefined' && typeof beginGame === 'function') {
      window.beginGame = beginGame;
    }
  } catch (_) {}
}

function startApplicationWhenReady() {
  if (typeof document === 'undefined') {
    bootApplication();
    return;
  }

  if (document.readyState === 'loading') {
    const handleReady = () => {
      document.removeEventListener('DOMContentLoaded', handleReady);
      bootApplication();
    };
    document.addEventListener('DOMContentLoaded', handleReady);
    return;
  }

  bootApplication();
}

startApplicationWhenReady();
